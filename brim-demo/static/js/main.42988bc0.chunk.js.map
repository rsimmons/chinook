{"version":3,"sources":["uid.ts","EditReducer.ts","vendor/fts_fuzzy_match.js","ExpressionChooser.js","Editor.js","App.tsx","serviceWorker.ts","index.tsx"],"names":["gen32","Math","random","toString","substring","uid","isProgramNode","node","type","isExpressionNode","isUndefinedExpressionNode","isIntegerLiteralNode","isArrayLiteralNode","isStreamReferenceNode","SCHEMA_NODES","Program","fields","expressions","Identifier","name","UndefinedExpression","streamId","identifier","IntegerLiteral","value","ArrayLiteral","items","StreamReference","targetStreamId","SCHEMA_CLASSES","Expression","Any","nodeFromPath","root","path","cur","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","err","return","nodeSplitPath","idx","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","seg","slice","Error","equiv","a","b","JSON","stringify","HANDLERS","_ref","subpath","action","length","newIdx","max","min","newExpressionIdx","_ref2","removeIdx","newNode","Object","objectSpread","concat","toConsumableArray","push","genuid","deleteExpression","_ref3","_ref4","_ref5","_ref6","trimmedName","trim","_ref7","editingSelected","_ref8","afterIdx","_ref9","_ref10","_ref11","_ref12","_ref13","_ref14","_ref15","recursiveReducer","state","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","nodeOnPath","selectionPath","nodeInfo","newSelPath","newEditingSelected","handled","indexableNode","_i","_Object$entries","entries","_ref20","_ref17","slicedToArray","fieldName","childNode","recResult","_recResult","n","sp","es","newArr","childNodes","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","arrn","_recResult3","isIdentifierNode","isNode","_i2","_HANDLERS","_ref21","_ref19","nt","acts","hfunc","includes","_nodeSplitPath","_nodeSplitPath2","pathBefore","handlerResult","console","log","_handlerResult","handlerNewNode","handlerNewSubpath","handlerNewEditingSelected","addDerivedState","streamIdToNode","Map","nameToNodes","recursiveBuildStreamMaps","set","nodes","get","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","reducer","_recResult4","newRoot","newSelectionPath","fooId","initialState","fuzzy_match","pattern","str","score","patternIdx","patternLength","strIdx","strLength","prevMatched","prevLower","prevSeparator","bestLetter","bestLower","bestLetterIdx","bestLetterScore","matchedIndices","patternChar","charAt","strChar","patternLower","toLowerCase","strLower","strUpper","toUpperCase","nextMatch","rematch","newScore","formattedStr","lastIdx","i","substr","FLOAT_REGEX","generateChoices","text","mainState","choices","envSearchResults","query","names","results","_fuzzy_match","_fuzzy_match2","hit","sort","fuzzySearchNames","keys","result","test","Number","Choice","choice","react_default","createElement","ExpressionChooser","dispatch","_useState","useState","targetExpressionNode","_useState2","setText","realizeChoice","index","recomputeDropdownChoices","newState","adjustDropdownIndex","amount","setDropdownState","oldState","_useState3","_useState4","dropdownState","className","onChange","e","newText","target","onKeyDown","key","stopPropagation","preventDefault","autoFocus","map","keyMap","MOVE_UP","MOVE_DOWN","MOVE_LEFT","MOVE_RIGHT","ZOOM_IN","ZOOM_OUT","BEGIN_EDIT","INSERT_AFTER","DELETE","NAME","COMMAND_CHARS","DispatchContext","createContext","SelectedNodeContext","useWithSelectedClass","obj","cns","arguments","useContext","FullStateContext","ProgramView","program","expression","ExpressionView","IdentifierChooser","initialName","onUpdateName","onEndEdit","NotEditingIdentifierView","ExpressionIdentifierView","selected","IntegerLiteralView","integerLiteral","ArrayLiteralView","arrayLiteral","item","UndefinedExpressionView","undefinedExpression","StreamReferenceView","streamReference","NotEditingExpressionView","ExpressionChooser_ExpressionChooser","Editor","_useReducer","useReducer","_useReducer2","plainState","editorElem","useRef","constAutoFocus","useEffect","current","focus","previouslyEditingSelected","handlers","_loop","k","_Object$keys","index_es","only","tagName","altkey","ctrlKey","metaKey","tabIndex","ref","Provider","App","Editor_Editor","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.42988bc0.chunk.js","sourcesContent":["const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","import genuid from './uid';\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  char?: string;\n  newNode?: Node;\n}\n\ntype StreamID = string;\n\ninterface ProgramNode {\n  type: 'Program';\n  expressions: ExpressionNode[];\n}\nfunction isProgramNode(node: Node): node is ProgramNode {\n  return node.type === 'Program';\n}\n\ninterface IdentifierNode {\n  type: 'Identifier';\n  name: string;\n}\nfunction isIdentifierNode(node: Node): node is IdentifierNode {\n  return node.type === 'Identifier';\n}\n\ntype ExpressionNode = UndefinedExpressionNode | IntegerLiteralNode | ArrayLiteralNode | StreamReferenceNode;\nfunction isExpressionNode(node: Node): node is ExpressionNode {\n  return isUndefinedExpressionNode(node) || isIntegerLiteralNode(node) || isArrayLiteralNode(node)|| isStreamReferenceNode(node);\n}\n\ninterface UndefinedExpressionNode {\n  type: 'UndefinedExpression';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n}\nfunction isUndefinedExpressionNode(node: Node): node is UndefinedExpressionNode {\n  return node.type === 'UndefinedExpression';\n}\n\ninterface IntegerLiteralNode {\n  type: 'IntegerLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  value: number;\n}\nfunction isIntegerLiteralNode(node: Node): node is IntegerLiteralNode {\n  return node.type === 'IntegerLiteral';\n}\n\ninterface ArrayLiteralNode {\n  type: 'ArrayLiteral';\n  streamId: StreamID;\n  identifier: IdentifierNode | null;\n  items: ExpressionNode[];\n}\nfunction isArrayLiteralNode(node: Node): node is ArrayLiteralNode {\n  return node.type === 'ArrayLiteral';\n}\n\ninterface StreamReferenceNode {\n  type: 'StreamReference',\n  streamId: StreamID,\n  identifier: IdentifierNode | null;\n  targetStreamId: StreamID,\n}\nfunction isStreamReferenceNode(node: Node): node is StreamReferenceNode {\n  return node.type === 'StreamReference';\n}\n\ntype Node = ProgramNode | IdentifierNode | ExpressionNode;\nfunction isNode(node: any): node is Node {\n  return isProgramNode(node) || isIdentifierNode(node) || isExpressionNode(node);\n}\n\ntype Path = (string | number)[];\n\ninterface HandlerArgs {\n  node: Node,\n  subpath: Path,\n  editingSelected: boolean,\n  action: Action;\n}\ntype HandlerResult = (undefined | [Node, Path, boolean]);\ntype Handler = [string, string[], (args: HandlerArgs) => HandlerResult];\n\ninterface State {\n  root: ProgramNode;\n  selectionPath: Path;\n  editingSelected: boolean;\n}\n\nconst SCHEMA_NODES = {\n  Program: {\n    fields: {\n      expressions: {type: 'nodes'},\n    }\n  },\n\n  Identifier: {\n    fields: {\n      name: {type: 'value'},\n    }\n  },\n\n  UndefinedExpression: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n    }\n  },\n\n  IntegerLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      value: {type: 'value'},\n    }\n  },\n\n  ArrayLiteral: {\n    fields: {\n      streamId: {type: 'uid'},\n      identifier: {type: 'node'},\n      items: {type: 'nodes'},\n    }\n  },\n\n  StreamReference: {\n    fields: {\n      streamId: {type: 'uid'},\n      targetStreamId: {type: 'uid'},\n    }\n  },\n};\n\n// TODO: If we want to include other classes in the lists, generate an expansion over the closure\nconst SCHEMA_CLASSES: {[nodeType: string]: string[]} = {\n  Expression: ['UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference'],\n  Any: ['Program', 'Identifier', 'UndefinedExpression', 'IntegerLiteral', 'ArrayLiteral', 'StreamReference'],\n}\n\nexport function nodeFromPath(root: Node, path: Path): Node {\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n  }\n  return cur;\n}\n\nexport function nodeOnPath(node: Node, root: Node, path: Path): boolean {\n  if (node === root) {\n    return true;\n  }\n\n  let cur: any = root;\n  for (const seg of path) {\n    cur = cur[seg];\n    if (node === cur) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function nodeSplitPath(node: Node, root: Node, path: Path): [Path, Path] {\n  let cur: any = root;\n  let idx = 0;\n  for (const seg of path) {\n    if (node === cur) {\n      return [path.slice(0, idx), path.slice(idx)];\n    }\n    cur = cur[seg];\n    idx++;\n  }\n\n  if (node === cur) {\n    return [path.slice(0, idx), path.slice(idx)];\n  } else {\n    throw new Error('node was not in path');\n  }\n}\n\nconst equiv = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\nfunction deleteExpression(node: ProgramNode, removeIdx: number): [ProgramNode, Path, boolean] {\n  // TODO: Handle case where we delete all expressions\n  if (typeof(removeIdx) !== 'number') {\n    throw new Error();\n  }\n  const newNode = {\n    ...node,\n    expressions: [\n      ...node.expressions.slice(0, removeIdx),\n      ...node.expressions.slice(removeIdx+1),\n    ],\n  };\n\n  if (newNode.expressions.length) {\n    let newIdx = removeIdx-1;\n    newIdx = Math.max(newIdx, 0);\n    newIdx = Math.min(newIdx, node.expressions.length-1);\n    return [newNode, ['expressions', newIdx], false];\n  } else {\n    // We've deleted all expressions, so make a single empty one.\n    newNode.expressions.push({\n      type: 'UndefinedExpression',\n      streamId: genuid(),\n      identifier: null,\n    });\n    return [newNode, ['expressions', 0], true];\n  }\n}\n\nconst HANDLERS: Handler[] = [\n  ['Program', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n\n    // NOTE: This assumes that selection is on/in one of the expressions\n    const newExpressionIdx = () => {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      let newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n      newIdx = Math.max(newIdx, 0);\n      newIdx = Math.min(newIdx, node.expressions.length-1);\n      return newIdx;\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      return [node, ['expressions', newExpressionIdx()], false];\n    }\n  }],\n\n  ['Program', ['DELETE'], ({node, subpath}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'expressions')) {\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      return deleteExpression(node, removeIdx);\n    }\n  }],\n\n  ['Expression', ['BEGIN_EDIT'], ({node, subpath}) => {\n    switch (node.type) {\n      case 'IntegerLiteral':\n      case 'UndefinedExpression':\n      case 'StreamReference':\n        return [node, subpath, true];\n\n      case 'ArrayLiteral':\n        // Can't directly edit\n        break;\n\n      default:\n        throw new Error();\n    }\n  }],\n\n  ['Expression', ['BEGIN_EDIT_FRESH'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    return [{\n      type: 'UndefinedExpression',\n      streamId: node.streamId,\n      identifier: node.identifier,\n    }, subpath, true];\n  }],\n\n  ['Expression', ['END_EXPRESSION_EDIT'], ({node, subpath}) => {\n    return [node, subpath, false];\n  }],\n\n  ['Expression', ['END_EXPRESSION_IDENTIFIER_EDIT'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (!equiv(subpath, ['identifier'])) {\n      throw new Error();\n    }\n    if (!node.identifier) {\n      throw new Error();\n    }\n    const trimmedName = node.identifier.name.trim();\n    return [{\n      ...node,\n      identifier: trimmedName ? {\n        type: 'Identifier',\n        name: trimmedName,\n      } : null,\n    }, [], false];\n  }],\n\n  ['Any', ['UPDATE_NODE'], ({subpath, action, editingSelected}) => {\n    if (!action.newNode) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      return [action.newNode, subpath, editingSelected];\n    }\n  }],\n\n  ['Program', ['INSERT_AFTER'], ({node, subpath}) => {\n    if (!isProgramNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length >= 2) && (subpath[0] === 'expressions')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ProgramNode = {\n        ...node,\n        expressions: [\n          ...node.expressions.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.expressions.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['expressions', afterIdx+1], true];\n    }\n  }],\n\n  /**\n   * NAME on an expression will move to editing identifer.\n   */\n  ['Expression', ['NAME'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n    if (equiv(subpath, [])) {\n      return [{\n        ...node,\n        identifier: node.identifier ? node.identifier : {type: 'Identifier', name: ''},\n      }, ['identifier'], true];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_LEFT to act as ZOOM_OUT here because we know array is displayed vertically for now\n  ['ArrayLiteral', ['ZOOM_OUT', 'MOVE_LEFT'], ({node, subpath}) => {\n    if (subpath.length === 2) {\n      if ((subpath[0] !== 'items') || (typeof(subpath[1]) !== 'number')) {\n        throw Error();\n      }\n      return [node, [], false];\n    }\n  }],\n\n  // NOTE: We only allow MOVE_RIGHT to act as ZOOM_IN here because we know it will be in a vertical-list container\n  ['ArrayLiteral', ['ZOOM_IN', 'MOVE_RIGHT'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 0) {\n      // We do a special thing here: If the array is empty, we create a single undefined item.\n      // This gives us a way to add a new element to an empty array.\n      if (node.items.length === 0) {\n        return [{\n          ...node,\n          items: [\n            {\n              type: 'UndefinedExpression',\n              streamId: genuid(),\n              identifier: null,\n            }\n          ],\n        }, ['items', 0], true];\n      } else {\n        return [node, ['items', 0], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['MOVE_UP', 'MOVE_DOWN'], ({node, subpath, action}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const idx = subpath[1];\n      if (typeof idx !== 'number') {\n        throw new Error();\n      }\n      const newIdx = idx + ((action.type === 'MOVE_UP') ? -1 : 1);\n\n      if ((newIdx < 0) || (newIdx >= node.items.length)) {\n        return [node, [], false];\n      } else {\n        return [node, ['items', newIdx], false];\n      }\n    }\n  }],\n\n  ['ArrayLiteral', ['INSERT_AFTER'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if ((subpath.length === 2) && (subpath[0] === 'items')) {\n      const afterIdx = subpath[1];\n      if (typeof(afterIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode: ArrayLiteralNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, afterIdx+1),\n          {\n            type: 'UndefinedExpression',\n            streamId: genuid(),\n            identifier: null,\n          },\n          ...node.items.slice(afterIdx+1),\n        ],\n      };\n      return [newNode, ['items', afterIdx+1], true];\n    }\n  }],\n\n  ['ArrayLiteral', ['DELETE'], ({node, subpath}) => {\n    if (!isArrayLiteralNode(node)) {\n      throw new Error();\n    }\n    if (subpath.length === 2) {\n      if (node.items.length === 0) {\n        throw new Error();\n      }\n\n      const removeIdx = subpath[1];\n      if (typeof(removeIdx) !== 'number') {\n        throw new Error();\n      }\n      const newNode = {\n        ...node,\n        items: [\n          ...node.items.slice(0, removeIdx),\n          ...node.items.slice(removeIdx+1),\n        ],\n      };\n\n      if (newNode.items.length > 0) {\n        let newIdx = removeIdx-1;\n        newIdx = Math.max(newIdx, 0);\n        newIdx = Math.min(newIdx, node.items.length-1);\n        return [newNode, ['items', newIdx], false];\n      } else {\n        return [newNode, [], false];\n      }\n    }\n  }],\n\n  ['Expression', ['CREATE_ARRAY'], ({node, subpath}) => {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    if (subpath.length === 0) {\n      return [{\n        type: 'ArrayLiteral',\n        streamId: node.streamId,\n        identifier: node.identifier,\n        items: [\n          {\n            type: 'UndefinedExpression',\n            identifier: null,\n            streamId: genuid(),\n          }\n        ],\n      }, ['items', 0], true];\n    }\n  }],\n];\n\n/**\n * Returns null or [newNode, newSelectionPath, newTextEdit]\n */\nfunction recursiveReducer(state: State, node: Node, action: Action): (null | [Node, Path, boolean]) {\n  // If this node is not on the selection path, we can short circuit\n  if (!nodeOnPath(node, state.root, state.selectionPath)) {\n    return null;\n  }\n\n  // Build new node, recursing into any child nodes\n  // If nothing has changed, we try to return the original object to allow callers to memoize\n  const nodeInfo = SCHEMA_NODES[node.type];\n  if (!nodeInfo) {\n    throw new Error();\n  }\n  const newNode: any = {\n    type: node.type,\n  };\n  let newSelPath = null;\n  let newEditingSelected = false;\n  let handled = false;\n  const indexableNode = node as {[prop: string]: any}; // to avoid type errors\n  for (const [fieldName, fieldInfo] of Object.entries(nodeInfo.fields)) {\n    switch (fieldInfo.type) {\n      case 'node': {\n        const childNode = indexableNode[fieldName];\n        const recResult = recursiveReducer(state, childNode, action);\n        if (recResult) {\n          if (handled) {\n            throw new Error('already handled');\n          }\n          const [n, sp, es] = recResult;\n          newNode[fieldName] = n;\n          newSelPath = sp;\n          newEditingSelected = es;\n          handled = true;\n        } else {\n          newNode[fieldName] = childNode;\n        }\n        break;\n      }\n\n      case 'nodes': {\n        const newArr = [];\n        const childNodes = indexableNode[fieldName];\n        for (const arrn of childNodes) {\n          const recResult = recursiveReducer(state, arrn, action);\n          if (recResult) {\n            if (handled) {\n              throw new Error('already handled');\n            }\n            const [n, sp, es] = recResult;\n            newArr.push(n);\n            newSelPath = sp;\n            newEditingSelected = es;\n            handled = true;\n          } else {\n            newArr.push(arrn);\n          }\n        }\n        newNode[fieldName] = newArr;\n        break;\n      }\n\n      case 'value':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      case 'uid':\n        newNode[fieldName] = indexableNode[fieldName];\n        break;\n\n      default:\n        throw new Error();\n    }\n  }\n\n  // If the action has been handled, we can return now\n  if (handled) {\n    if (!isNode(newNode)) {\n      throw new Error();\n    }\n    if (!newSelPath) {\n      throw new Error();\n    }\n    return [newNode, newSelPath, newEditingSelected];\n  }\n\n  // Try any matching handlers\n  for (const [nt, acts, hfunc] of HANDLERS) {\n    const matchingTypes = SCHEMA_CLASSES[nt] ? SCHEMA_CLASSES[nt] : [nt];\n    if (matchingTypes.includes(node.type) && acts.includes(action.type)) {\n      const [pathBefore, pathAfter] = nodeSplitPath(node, state.root, state.selectionPath);\n      const handlerResult = hfunc({\n        node,\n        subpath: pathAfter,\n        editingSelected: state.editingSelected,\n        action,\n      });\n      if (handlerResult) {\n        console.log('handlerResult', handlerResult);\n        const [handlerNewNode, handlerNewSubpath, handlerNewEditingSelected] = handlerResult;\n        return [handlerNewNode, pathBefore.concat(handlerNewSubpath), handlerNewEditingSelected];\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction recursiveBuildStreamMaps(node: Node, streamIdToNode: Map<StreamID, Node>, nameToNodes: Map<string, Node[]>): void {\n  if (SCHEMA_CLASSES['Expression'].includes(node.type)) {\n    if (!isExpressionNode(node)) {\n      throw new Error();\n    }\n\n    streamIdToNode.set(node.streamId, node);\n\n    if (node.identifier) {\n      const name = node.identifier.name;\n      let nodes = nameToNodes.get(name);\n      if (nodes) {\n        nodes.push(node);\n      } else {\n        nameToNodes.set(name, [node]);\n      }\n    }\n\n    return;\n  }\n\n  switch (node.type) {\n    case 'Program':\n      for (const expression of node.expressions) {\n        recursiveBuildStreamMaps(expression, streamIdToNode, nameToNodes);\n      }\n      break;\n\n    default:\n      throw new Error();\n  }\n}\n\nexport function addDerivedState(state: State) {\n  const streamIdToNode: Map<StreamID, Node> = new Map();\n  const nameToNodes: Map<string, Node[]> = new Map();\n\n  recursiveBuildStreamMaps(state.root, streamIdToNode, nameToNodes);\n\n  return {\n    ...state,\n    streamIdToNode,\n    nameToNodes,\n  }\n}\n\nexport function reducer(state: State, action: Action): State {\n  console.log('action', action.type);\n\n  const recResult = recursiveReducer(state, state.root, action);\n  if (recResult) {\n    console.log('handled');\n    const [newRoot, newSelectionPath, newEditingSelected] = recResult;\n    console.log('new selectionPath is', newSelectionPath, 'newEditingSelected is', newEditingSelected);\n\n    if (!isProgramNode(newRoot)) {\n      throw new Error();\n    }\n\n    return {\n      root: newRoot,\n      selectionPath: newSelectionPath,\n      editingSelected: newEditingSelected,\n    };\n  } else {\n    console.log('not handled');\n    return state;\n  }\n}\n\nconst fooId = genuid();\nexport const initialState: State = {\n  root: {\n    type: 'Program',\n    expressions: [\n      {\n        type: 'IntegerLiteral',\n        streamId: fooId,\n        identifier: {\n          type: 'Identifier',\n          name: 'foo',\n        },\n        value: 123,\n      },\n      {\n        type: 'IntegerLiteral',\n        streamId: genuid(),\n        identifier: null,\n        value: 456,\n      },\n      {\n        type: 'IntegerLiteral',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'bar',\n        },\n        value: 789,\n      },\n      {\n        type: 'ArrayLiteral',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'an array literal',\n        },\n        items: [\n          {\n            type: 'IntegerLiteral',\n            streamId: genuid(),\n            identifier: null,\n            value: 123,\n          },\n          {\n            type: 'ArrayLiteral',\n            streamId: genuid(),\n            identifier: {\n              type: 'Identifier',\n              name: 'nice subarray',\n            },\n                items: [\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 345,\n              },\n              {\n                type: 'IntegerLiteral',\n                streamId: genuid(),\n                identifier: null,\n                value: 456,\n              },\n            ],\n          },\n          {\n            type: 'IntegerLiteral',\n            streamId: genuid(),\n            identifier: null,\n            value: 234,\n          },\n        ],\n      },\n      {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: {\n          type: 'Identifier',\n          name: 'quux',\n        },\n      },\n      {\n        type: 'StreamReference',\n        streamId: genuid(),\n        identifier: null,\n        targetStreamId: fooId,\n      },\n    ]\n  },\n  selectionPath: ['expressions', 0],\n  editingSelected: false,\n};\n","// slightly adapted from https://github.com/forrestthewoods/lib_fts/blob/master/code/fts_fuzzy_match.js\r\n\r\n// LICENSE\r\n//\r\n//   This software is dual-licensed to the public domain and under the following\r\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\r\n//   publish, and distribute this file as you see fit.\r\n//\r\n// VERSION\r\n//   0.1.0  (2016-03-28)  Initial release\r\n//\r\n// AUTHOR\r\n//   Forrest Smith\r\n//\r\n// CONTRIBUTORS\r\n//   J�rgen Tjern� - async helper\r\n\r\n\r\n// Returns true if each character in pattern is found sequentially within str\r\nexport function fuzzy_match_simple(pattern, str) {\r\n\r\n    var patternIdx = 0;\r\n    var strIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strLength = str.length;\r\n\r\n    while (patternIdx !== patternLength && strIdx !== strLength) {\r\n        var patternChar = pattern.charAt(patternIdx).toLowerCase();\r\n        var strChar = str.charAt(strIdx).toLowerCase();\r\n        if (patternChar === strChar)\r\n            ++patternIdx;\r\n        ++strIdx;\r\n    }\r\n\r\n    return patternLength !== 0 && strLength !== 0 && patternIdx === patternLength ? true : false;\r\n}\r\n\r\n// Returns [bool, score, formattedStr]\r\n// bool: true if each character in pattern is found sequentially within str\r\n// score: integer; higher is better match. Value has no intrinsic meaning. Range varies with pattern.\r\n//        Can only compare scores with same search pattern.\r\n// formattedStr: input str with matched characters marked in <b> tags. Delete if unwanted.\r\nexport function fuzzy_match(pattern, str) {\r\n\r\n    // Score consts\r\n    var adjacency_bonus = 5;                // bonus for adjacent matches\r\n    var separator_bonus = 10;               // bonus if match occurs after a separator\r\n    var camel_bonus = 10;                   // bonus if match is uppercase and prev is lower\r\n    var leading_letter_penalty = -3;        // penalty applied for every letter in str before the first match\r\n    var max_leading_letter_penalty = -9;    // maximum penalty for leading letters\r\n    var unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\r\n\r\n    // Loop variables\r\n    var score = 0;\r\n    var patternIdx = 0;\r\n    var patternLength = pattern.length;\r\n    var strIdx = 0;\r\n    var strLength = str.length;\r\n    var prevMatched = false;\r\n    var prevLower = false;\r\n    var prevSeparator = true;       // true so if first letter match gets separator bonus\r\n\r\n    // Use \"best\" matched letter if multiple string letters match the pattern\r\n    var bestLetter = null;\r\n    var bestLower = null;\r\n    var bestLetterIdx = null;\r\n    var bestLetterScore = 0;\r\n\r\n    var matchedIndices = [];\r\n\r\n    // Loop over strings\r\n    while (strIdx !== strLength) {\r\n        var patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\r\n        var strChar = str.charAt(strIdx);\r\n\r\n        var patternLower = patternChar !== null ? patternChar.toLowerCase() : null;\r\n        var strLower = strChar.toLowerCase();\r\n        var strUpper = strChar.toUpperCase();\r\n\r\n        var nextMatch = patternChar && patternLower === strLower;\r\n        var rematch = bestLetter && bestLower === strLower;\r\n\r\n        var advanced = nextMatch && bestLetter;\r\n        var patternRepeat = bestLetter && patternChar && bestLower === patternLower;\r\n        if (advanced || patternRepeat) {\r\n            score += bestLetterScore;\r\n            matchedIndices.push(bestLetterIdx);\r\n            bestLetter = null;\r\n            bestLower = null;\r\n            bestLetterIdx = null;\r\n            bestLetterScore = 0;\r\n        }\r\n\r\n        if (nextMatch || rematch) {\r\n            var newScore = 0;\r\n\r\n            // Apply penalty for each letter before the first pattern match\r\n            // Note: std::max because penalties are negative values. So max is smallest penalty.\r\n            if (patternIdx === 0) {\r\n                var penalty = Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\r\n                score += penalty;\r\n            }\r\n\r\n            // Apply bonus for consecutive bonuses\r\n            if (prevMatched)\r\n                newScore += adjacency_bonus;\r\n\r\n            // Apply bonus for matches after a separator\r\n            if (prevSeparator)\r\n                newScore += separator_bonus;\r\n\r\n            // Apply bonus across camel case boundaries. Includes \"clever\" isLetter check.\r\n            if (prevLower && strChar === strUpper && strLower !== strUpper)\r\n                newScore += camel_bonus;\r\n\r\n            // Update patter index IFF the next pattern letter was matched\r\n            if (nextMatch)\r\n                ++patternIdx;\r\n\r\n            // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\r\n            if (newScore >= bestLetterScore) {\r\n\r\n                // Apply penalty for now skipped letter\r\n                if (bestLetter !== null)\r\n                    score += unmatched_letter_penalty;\r\n\r\n                bestLetter = strChar;\r\n                bestLower = bestLetter.toLowerCase();\r\n                bestLetterIdx = strIdx;\r\n                bestLetterScore = newScore;\r\n            }\r\n\r\n            prevMatched = true;\r\n        }\r\n        else {\r\n            // Append unmatch characters\r\n            // formattedStr += strChar; // NOTE: This line appears to be useless, and generates warning -Russ\r\n\r\n            score += unmatched_letter_penalty;\r\n            prevMatched = false;\r\n        }\r\n\r\n        // Includes \"clever\" isLetter check.\r\n        prevLower = strChar === strLower && strLower !== strUpper;\r\n        prevSeparator = strChar === '_' || strChar === ' ';\r\n\r\n        ++strIdx;\r\n    }\r\n\r\n    // Apply score for last match\r\n    if (bestLetter) {\r\n        score += bestLetterScore;\r\n        matchedIndices.push(bestLetterIdx);\r\n    }\r\n\r\n    // Finish out formatted string after last pattern matched\r\n    // Build formated string based on matched letters\r\n    var formattedStr = \"\";\r\n    var lastIdx = 0;\r\n    for (var i = 0; i < matchedIndices.length; ++i) {\r\n        var idx = matchedIndices[i];\r\n        formattedStr += str.substr(lastIdx, idx - lastIdx) + \"<b>\" + str.charAt(idx) + \"</b>\";\r\n        lastIdx = idx + 1;\r\n    }\r\n    formattedStr += str.substr(lastIdx, str.length - lastIdx);\r\n\r\n    var matched = patternIdx === patternLength;\r\n    return [matched, score, formattedStr];\r\n}\r\n\r\n\r\n// Strictly optional utility to help make using fts_fuzzy_match easier for large data sets\r\n// Uses setTimeout to process matches before a maximum amount of time before sleeping\r\n//\r\n// To use:\r\n//      var asyncMatcher = new fts_fuzzy_match(fuzzy_match, \"fts\", \"ForrestTheWoods\",\r\n//                                              function(results) { console.log(results); });\r\n//      asyncMatcher.start();\r\n//\r\nexport function fts_fuzzy_match_async(matchFn, pattern, dataSet, onComplete) {\r\n    var ITEMS_PER_CHECK = 1000;         // performance.now can be very slow depending on platform\r\n\r\n    var max_ms_per_frame = 1000.0/30.0; // 30FPS\r\n    var dataIndex = 0;\r\n    var results = [];\r\n    var resumeTimeout = null;\r\n\r\n    // Perform matches for at most max_ms\r\n    function step() {\r\n        clearTimeout(resumeTimeout);\r\n        resumeTimeout = null;\r\n\r\n        var stopTime = performance.now() + max_ms_per_frame;\r\n\r\n        for (; dataIndex < dataSet.length; ++dataIndex) {\r\n            if ((dataIndex % ITEMS_PER_CHECK) === 0) {\r\n                if (performance.now() > stopTime) {\r\n                    resumeTimeout = setTimeout(step, 1);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            var str = dataSet[dataIndex];\r\n            var result = matchFn(pattern, str);\r\n\r\n            // A little gross because fuzzy_match_simple and fuzzy_match return different things\r\n            if (matchFn === fuzzy_match_simple && result === true)\r\n                results.push(str);\r\n            else if (matchFn === fuzzy_match && result[0] === true)\r\n                results.push(result);\r\n        }\r\n\r\n        onComplete(results);\r\n        return null;\r\n    };\r\n\r\n    // Abort current process\r\n    this.cancel = function() {\r\n        if (resumeTimeout !== null)\r\n            clearTimeout(resumeTimeout);\r\n    };\r\n\r\n    // Must be called to start matching.\r\n    // I tried to make asyncMatcher auto-start via \"var resumeTimeout = step();\"\r\n    // However setTimout behaving in an unexpected fashion as onComplete insisted on triggering twice.\r\n    this.start = function() {\r\n        step();\r\n    }\r\n\r\n    // Process full list. Blocks script execution until complete\r\n    this.flush = function() {\r\n        max_ms_per_frame = Infinity;\r\n        step();\r\n    }\r\n};\r\n","import React, { useState } from 'react';\nimport './ExpressionChooser.css';\nimport { fuzzy_match } from './vendor/fts_fuzzy_match';\n\n/*\nexport default class NodePool {\n  constructor() {\n    // Build pool\n    this.pool = [];\n    for (const k in nodeDefs) {\n      this.pool.push({\n        id: k,\n        def: nodeDefs[k],\n      });\n    }\n\n    // Sort alphabetically for now since we have no other relevance signals\n    this.pool.sort((a, b) => {\n      const sa = a.id.toUpperCase();\n      const sb = b.id.toUpperCase();\n      if (sa < sb) {\n        return -1;\n      }\n      if (sa > sb) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n\n  lookup(id) {\n    return nodeDefs[id];\n  }\n\n  search(query) {\n    const results = [];\n    for (const node of this.pool) {\n      const [hit, score, formattedStr] = fuzzy_match(query, node.id);\n      if (hit) {\n        results.push({\n          score,\n          formattedStr,\n          node,\n        });\n      }\n    }\n    if (query !== '') { // TOOD: this is a hack, is query is empty, scoring is dumb\n      results.sort((a, b) => (b.score - a.score));\n    }\n    return results;\n  }\n}\n*/\n\nfunction fuzzySearchNames(query, names) {\n  const results = [];\n\n  for (const name of names) {\n    const [hit, score, formattedStr] = fuzzy_match(query, name);\n    if (hit) {\n      results.push({\n        score,\n        formattedStr,\n        name,\n      });\n    }\n  }\n  if (query !== '') { // TOOD: this is a hack, is query is empty, scoring is dumb\n    results.sort((a, b) => (b.score - a.score));\n  }\n  return results;\n}\n\nconst FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\nfunction generateChoices(text, mainState) {\n  const choices = [];\n\n  const envNames = mainState.nameToNodes.keys();\n  const envSearchResults = fuzzySearchNames(text, envNames);\n  for (const result of envSearchResults) {\n    const nodes = mainState.nameToNodes.get(result.name);\n    for (const node of nodes) {\n      choices.push({\n        type: 'streamref',\n        node,\n      })\n    }\n  }\n\n  if (FLOAT_REGEX.test(text)) {\n    choices.push({\n      type: 'number',\n      value: Number(text),\n    });\n  }\n\n  if (choices.length === 0) {\n    choices.push({\n      type: 'undefined',\n    });\n  }\n\n  return choices;\n}\n\nfunction Choice({ choice }) {\n  switch (choice.type) {\n    case 'undefined':\n      return <em>undefined</em>\n\n    case 'number':\n      return <span>{choice.value}</span>\n\n    case 'streamref':\n      return <span>{choice.node.identifier.name} ({choice.node.streamId})</span>\n\n    default:\n      throw new Error();\n  }\n}\n\nexport default function ExpressionChooser({ node, mainState, dispatch }) {\n  const [text, setText] = useState(() => {\n    // Initialize text based on existing node\n    switch (node.type) {\n      case 'UndefinedExpression':\n        return '';\n\n      case 'IntegerLiteral':\n        return node.value.toString();\n\n      case 'StreamReference': {\n        const targetExpressionNode = mainState.streamIdToNode.get(node.targetStreamId);\n        return targetExpressionNode.identifier ? targetExpressionNode.identifier.name : '';\n      }\n\n      default:\n        throw new Error();\n    }\n  });\n\n  // Update the expression node to reflect the current choice\n  const realizeChoice = (state) => {\n    const choice = state.choices[state.index];\n\n    let newNode;\n    switch (choice.type) {\n      case 'undefined':\n        newNode = {\n          type: 'UndefinedExpression',\n        }\n        break;\n\n      case 'number':\n        newNode = {\n          type: 'IntegerLiteral',\n          value: choice.value,\n        };\n        break;\n\n      case 'streamref':\n        newNode = {\n          type: 'StreamReference',\n          targetStreamId: choice.node.streamId,\n        };\n        break;\n\n      default:\n        throw new Error();\n    }\n\n    newNode.streamId = node.streamId;\n    newNode.identifier = node.identifier;\n\n    dispatch({type: 'UPDATE_NODE', newNode});\n  };\n\n  const recomputeDropdownChoices = (text) => {\n    const newState = {\n      choices: generateChoices(text, mainState),\n      index: 0, // reset index to 0\n    };\n    realizeChoice(newState);\n    return newState;\n  };\n\n  const adjustDropdownIndex = (amount) => {\n    setDropdownState(oldState => {\n      const newState = {\n        ...oldState,\n        index: (oldState.index + amount + oldState.choices.length) % oldState.choices.length,\n      };\n      realizeChoice(newState);\n      return newState;\n    });\n  };\n\n  const [dropdownState, setDropdownState] = useState(() => recomputeDropdownChoices(text));\n\n  const onChange = e => {\n    const newText = e.target.value;\n\n    if (newText === '[') {\n      // This is a special case, we bypass the normal dropdown/choice stuff\n      dispatch({type: 'END_EXPRESSION_EDIT'});\n      dispatch({type: 'CREATE_ARRAY'});\n    } else {\n      setText(newText);\n      setDropdownState(recomputeDropdownChoices(newText));\n    }\n  };\n\n  const onKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n        e.stopPropagation();\n        dispatch({type: 'END_EXPRESSION_EDIT'});\n        break;\n\n      case 'Backspace':\n        if (!e.target.value) {\n          dispatch({type: 'END_EXPRESSION_EDIT'});\n          dispatch({type: 'DELETE'});\n        }\n        break;\n\n      case 'ArrowUp':\n        e.stopPropagation();\n        e.preventDefault();\n        adjustDropdownIndex(-1);\n        break;\n\n      case 'ArrowDown':\n        e.stopPropagation();\n        e.preventDefault();\n        adjustDropdownIndex(1);\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return (\n    <div>\n      <input className=\"Editor-text-edit-input\" value={text} onChange={onChange} onKeyDown={onKeyDown} autoFocus />\n      <ul className=\"ExpressionChooser-dropdown\">\n        {dropdownState.choices.map((choice, idx) =>\n          <li key={idx} className={(idx === dropdownState.index) ? 'ExpressionChooser-dropdown-selected' : ''}><Choice choice={choice} /></li>\n        )}\n      </ul>\n    </div>\n  );\n}\n","import React, { createContext, useContext, useReducer, useRef, useEffect, useState } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, addDerivedState, nodeFromPath } from './EditReducer';\nimport ExpressionChooser from './ExpressionChooser';\nimport './Editor.css';\n\nconst keyMap = {\n  MOVE_UP: 'up',\n  MOVE_DOWN: 'down',\n  MOVE_LEFT: 'left',\n  MOVE_RIGHT: 'right',\n\n  ZOOM_IN: 'shift+right',\n  ZOOM_OUT: 'shift+left',\n\n  BEGIN_EDIT: 'enter',\n\n  INSERT_AFTER: [';', ','],\n\n  DELETE: 'backspace',\n  NAME: '=',\n};\n\n// \"Regular\" (printable, basically) characters that are used as commands.\n// We want to handle them as commands even if they happen in an input element,\n// and we don't want them to trigger an edit to begin.\nconst COMMAND_CHARS = [\n  '=',\n  ';',\n  ',',\n];\n\nconst DispatchContext = createContext();\n\nconst SelectedNodeContext = createContext();\nfunction useWithSelectedClass(obj, cns = '') {\n  const selectedNode = useContext(SelectedNodeContext);\n  return (obj === selectedNode) ? (cns + ' Editor-selected') : cns;\n}\n\nconst FullStateContext = createContext();\n\nfunction ProgramView({ program }) {\n  return (\n    <div className=\"Editor-program\">\n      {program.expressions.map((expression) => (\n        <div className=\"Editor-program-expression\" key={expression.streamId}>\n          <ExpressionView expression={expression} />\n        </div>\n      ))}\n    </div>\n  );\n}\n\nfunction IdentifierChooser({ initialName, onUpdateName, onEndEdit }) {\n  const [text, setText] = useState(initialName || '');\n\n  const handleChange = e => {\n    const newText = e.target.value;\n    setText(newText);\n    if (onUpdateName) {\n      onUpdateName(newText);\n    }\n  };\n\n  const handleKeyDown = e => {\n    switch (e.key) {\n      case 'Enter':\n        e.stopPropagation();\n        if (onEndEdit) {\n          onEndEdit();\n        }\n        break;\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return <div><input className=\"Editor-text-edit-input\" value={text} onChange={handleChange} onKeyDown={handleKeyDown} autoFocus /></div>\n}\n\nfunction NotEditingIdentifierView({ identifier }) {\n  return identifier.name;\n}\n\nfunction ExpressionIdentifierView({ expression }) {\n  const identifier = expression.identifier;\n  const selected = (identifier === useContext(SelectedNodeContext));\n  const {editingSelected} = useContext(FullStateContext);\n  const dispatch = useContext(DispatchContext);\n\n  const handleUpdateName = (name) => {\n    dispatch({\n      type: 'UPDATE_NODE',\n      newNode: {\n        type: 'Identifier',\n        name,\n      },\n    });\n  };\n\n  const handleEndEdit = () => {\n    dispatch({type: 'END_EXPRESSION_IDENTIFIER_EDIT'});\n  };\n\n  return (\n    <div className={useWithSelectedClass(identifier)}>{(selected && editingSelected)\n      ? <IdentifierChooser initialName={identifier.name} onUpdateName={handleUpdateName} onEndEdit={handleEndEdit} />\n      : <NotEditingIdentifierView identifier={identifier} />\n    }</div>\n  );\n}\n\nfunction IntegerLiteralView({ integerLiteral }) {\n  return <div>{integerLiteral.value}</div>;\n}\n\nfunction ArrayLiteralView({ arrayLiteral }) {\n  return (\n    <div>\n      <div>[</div>\n      <div className=\"Editor-array-items\">\n        {arrayLiteral.items.map(item => (\n          <div className=\"Editor-array-item\" key={item.streamId}><ExpressionView expression={item} /></div>\n        ))}\n      </div>\n      <div>]</div>\n    </div>\n  );\n}\n\nfunction UndefinedExpressionView({ undefinedExpression }) {\n  return <div className=\"Editor-undefined-expression\">&nbsp;</div>;\n}\n\nfunction StreamReferenceView({ streamReference }) {\n  const {streamIdToNode} = useContext(FullStateContext);\n  const targetExpressionNode = streamIdToNode.get(streamReference.targetStreamId);\n  if (!targetExpressionNode) {\n    throw new Error();\n  }\n  return <div>{(targetExpressionNode.identifier && targetExpressionNode.identifier.name) ? targetExpressionNode.identifier.name : '<stream>'}</div>\n}\n\nfunction NotEditingExpressionView({ expression }) {\n  switch (expression.type) {\n    case 'IntegerLiteral':\n      return <IntegerLiteralView integerLiteral={expression} />\n\n    case 'ArrayLiteral':\n      return <ArrayLiteralView arrayLiteral={expression} />\n\n    case 'UndefinedExpression':\n      return <UndefinedExpressionView undefinedExpression={expression} />\n\n    case 'StreamReference':\n      return <StreamReferenceView streamReference={expression} />\n\n    default:\n      throw new Error();\n  }\n}\n\nfunction ExpressionView({ expression }) {\n  const selected = (expression === useContext(SelectedNodeContext));\n  const mainState = useContext(FullStateContext);\n  const dispatch = useContext(DispatchContext);\n\n  return (\n    <div className={useWithSelectedClass(expression, 'Editor-expression')}>\n      <div className=\"Editor-expression-main\">\n        {(selected && mainState.editingSelected)\n        ? <ExpressionChooser node={expression} mainState={mainState} dispatch={dispatch} />\n        : <NotEditingExpressionView expression={expression} />\n        }\n      </div>\n      {expression.identifier\n        ? <div className=\"Editor-expression-identifier\"><ExpressionIdentifierView expression={expression} /></div>\n        : null\n      }\n    </div>\n  );\n}\n\nexport default function Editor({ autoFocus }) {\n  const [plainState, dispatch] = useReducer(reducer, initialState);\n  const state = addDerivedState(plainState);\n\n  const editorElem = useRef();\n\n  // Do auto-focus if prop is set\n  const [constAutoFocus] = useState(autoFocus);\n  useEffect(() => {\n    if (constAutoFocus) {\n      // Focus editor after initial render\n      editorElem.current.focus();\n    }\n  }, [constAutoFocus]);\n\n  // Restore focus to editor elem if input box just went away.\n  // NOTE: This is hacky, but don't know better way to handle.\n  const previouslyEditingSelected = useRef(false);\n  useEffect(() => {\n    if (previouslyEditingSelected.current && !state.editingSelected) {\n      editorElem.current.focus();\n    }\n    previouslyEditingSelected.current = state.editingSelected;\n  });\n\n  // TODO: memoize generation of this\n  const handlers = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e) => {\n      e.preventDefault(); // If we attempted to handle this, prevent default (scrolling window, entering character, etc.)\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = e => {\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if ((e.target.tagName.toLowerCase() !== 'input') && ([...e.key].length === 1) && !e.altkey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.includes(e.key)) {\n      // Interestingly, the key here will still end up going into the input element, which is what we want.\n      dispatch({type: 'BEGIN_EDIT_FRESH'});\n    }\n  };\n\n  return (\n    <HotKeys keyMap={keyMap} handlers={handlers}>\n      <ObserveKeys only={COMMAND_CHARS}>\n        <div className=\"Editor\" onKeyDown={onKeyDown} tabIndex=\"0\" ref={editorElem}>\n          <DispatchContext.Provider value={dispatch}>\n            <SelectedNodeContext.Provider value={nodeFromPath(state.root, state.selectionPath)}>\n              <FullStateContext.Provider value={state}>\n                <ProgramView program={state.root} />\n              </FullStateContext.Provider>\n            </SelectedNodeContext.Provider>\n          </DispatchContext.Provider>\n        </div>\n      </ObserveKeys>\n    </HotKeys>\n  );\n}\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      <div>\n        <h2>Notes</h2>\n        <ul>\n          <li><strong>The goal of this is to explore if there's a good way to do keyboard-driven structured code editing that doesn't suck. To not suck, I believe that there must be a very small number of keyboard commands, and they should be rather intuitive/obvious. As a bonus, it would be nice if it behaved similarly to spreadsheets or normal programming editors.</strong></li>\n          <li>Warning: A bunch of shit only half-works.</li>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>There's no mouse/touch support yet, only keyboard.</li>\n          <li>The AST always stays \"well-formed\", but some bits are allowed to be temporarily unspecified or invalid. The program may still be able to run with unspecified values, and it will be very clear to the user (red boxes) what is invalid/missing.</li>\n          <li>This code doesn't yet \"run\", it's just a fake language for now.</li>\n          <li>Up/down arrows move up and down between expressions and array items.</li>\n          <li>Shift-left (or just left, if unambiguous) \"zooms out\" selection and shift-right (Or just right, if unambiguous) \"zooms in\" selection (into nested structures).</li>\n          <li>Pressing enter on an expression (or sub-expression) will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Pressing the = key on on an expression will move to editing its name.</li>\n          <li>A red box indicates an undefined expression.</li>\n          <li>If you enter an invalid number as an expression, it will ignore it and leave an undefined box.</li>\n          <li>Semicolon or comma (interchangeable) will both add a new assignment or array item below the current one (even during a text edit).</li>\n          <li>Delete will delete expressions, array items, etc.</li>\n          <li>Typeing just [ when editing an expression will create an array literal.</li>\n          <li><strong>TODO</strong> Escape will revert any in-progress edit.</li>\n        </ul>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}