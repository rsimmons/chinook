{"version":3,"sources":["../../riv-runtime/lib/index.js","../../riv-snabbdom/src/index.js","icons/quotes.svg","icons/boolean.svg","../../riv-demo-lib/src/index.js","uid.ts","Tree.ts","TreeUtil.ts","Environment.ts","Traversal.ts","Compiler.ts","globalNatives.ts","EditReducer.ts","LiveFunction.ts","StoragePanel.tsx","SyntaxTemplate.ts","TreeView.tsx","FunctionUI.ts","Chooser.tsx","Editor.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["Object","defineProperty","exports","value","currentUpdateFrame","ExecutionContext","streamFunc","onRequestUpdate","afterTerminate","this","hookRecordChain","data","cleanup","next","recordCursor","openRecord","updateCount","prototype","update","args","_i","arguments","length","retval","newFrame","executionContext","previousFrame","apply","Error","poppedFrame","terminate","c","_beginHook","_endHook","_requestUpdate","_setStreamFunc","newStreamFunc","currentBatch","enqueueBatchedUpdate","callback","callbacks","add","getTopUpdatingExecutionContext","useVar","initVal","ctx","record","actualInitVal","Function","current","useRequestUpdate","requestUpdate","useEventReceiver","stream","queue_1","data_1","queue","lastStream","unsubscribe","onValue","push","recordData","subscribe","pop","beginBatch","Set","endBatch","forEach","cb","createNullaryVoidRootExecutionContext","updateCtx","t0","performance","now","dt","console","log","toFixed","useInitialize","initializer","useEventEmitter","subscribers_1","delete","emit","sub","useDynamic","oru_1","data_2","activeContexts","createContext","useReducer","evts","reducerFunc","initialState","state","evt","useReducers","streamReducerPairs","numStreams","evtCount","streamReducerPairs_1","_a","reducer","useCallbackReducer","action","useCallbackReducers","reducerFuncs","map","useMachine","states","initialTransition","takeTransition","trans","activeContext","newState","newStateArg","newCtx","activeState","activeArgument","data_3","tmpRetval","transition","patch","init","default","h","cloneNode","vnode","sel","children","text","key","elm","renderDOMIntoElement","containerElement","savedContainerElement","previousVnode","innerHTML","clonedVnode","elem","document","createElement","appendChild","renderDOMIntoSelector","containerSelector","querySelector","e","renderDOMAppendedToBody","body","removeChild","module","_require","_require2","showString","v","style","border","color","fontSize","padding","marginTop","undefined","toString","animationFrameEvts","reqId","_useEventEmitter","_useEventEmitter2","frameEvts","emitFrame","requestAnimationFrame","onFrame","t","cancelAnimationFrame","latestValue","initialValue","_","animationTime","countEvents","previousCount","domEvts","eventTarget","type","extra","_useEventEmitter9","_useEventEmitter10","onEvent","addEventListener","removeEventListener","mouseClickEvts","mouseDown","downEvts","upEvts","mousePosition","inputEvts","inputEvt","_useEventEmitter3","_useEventEmitter4","outputEvts","emitOutput","mapEvts","x","y","random","repickEvts","Math","audioDriver","generator","createGenerator","generatorCtx","frameCount","sampleRate","_useEventEmitter11","_useEventEmitter12","advanceFrameEvts","emitAdvanceFrameEvt","audioContext","window","AudioContext","webkitAudioContext","scriptNode","createScriptProcessor","onaudioprocess","buffer","outputBuffer","getChannelData","i","frameVal","Number","isNaN","connect","destination","disconnect","close","sampleUpon","toSample","uponEvts","everySecond","_useEventEmitter13","_useEventEmitter14","tickEvts","emitTick","timerId","setInterval","clearInterval","loadAudioAsArray","url","pcm","audioCtx","cleanedUp","request","XMLHttpRequest","open","responseType","onload","audioData","response","decodeAudioData","send","abort","integral","integrandFunc","time","accum","prevTime","integrand","expFollow","targetValue","speedConstant","currentValue","redCircle","position","radius","p","halfRadius","borderRadius","background","pointerEvents","userSelect","left","top","width","height","followAtSpeed2d","target","speed","initial","pos","delta","dist","sqrt","eventAfter","seconds","valueToEmit","_useEventEmitter15","_useEventEmitter16","setTimeout","clearTimeout","received","previousState","event","streamMap","f","arr","createFContext","fContexts","outs","changeCount","s","count","previous","is","gen32","substring","generateStreamId","genuid","generateFunctionId","NodeKind","generateApplicationId","isStreamExpressionNode","node","kind","UndefinedLiteral","NumberLiteral","TextLiteral","BooleanLiteral","isSimpleLiteralNode","ArrayLiteral","StreamReference","Application","isBodyExpressionNode","isFunctionExpressionNode","YieldExpression","isFunctionDefinitionNode","TreeFunctionDefinition","NativeFunctionDefinition","FunctionReference","streamExprReturnedId","sid","ref","out","name","functionExprId","fid","Environment","outer","local","Map","has","get","set","entries","concat","entriesArray","iterChildren","Name","SignatureStreamParameter","SignatureFunctionParameter","SignatureYield","Signature","StreamParameter","FunctionParameter","TreeFunctionBody","elems","func","sargs","fargs","streamParams","funcParams","yields","expr","exprs","sig","sparams","fparams","visitArray","nodeArr","visit","result","visitChildren","visitOuts","CompilationError","compileGlobalTreeDefinition","definition","globalFunctionEnvironment","streamEnv","compGlobalFuncEnv","defNode","compileTreeDefinition","outerStreamEnvironment","outerFunctionEnvironment","streamEnvironment","functionEnvironment","localStreamIds","localFunctionIds","visitToFindLocals","constStreams","apps","localDefs","yieldIds","externalReferencedStreamIds","funcDef","innerCompiledDef","def","temporaryMarked","permanentMarked","traverseStreamExpr","val","streamArgIds","elemRetSid","sids","appId","aid","funcId","sargIds","fargIds","targetExpressionNode","funcArgIds","sarg","sargRetSid","exprRetSid","idx","streamParamIds","funcParamIds","compiledDefinition","size","require","simpleSig","ptypes","pn","returnedIdx","nativeFunctions","cond","_then","_else","a","b","cos","spacing","vecs","prefill","safePrefill","inputHandler","on","input","attrs","templateNames","initStaticEnv","globalFunctions","globalFunctionEnv","fdef","functionEnv","extendStaticEnv","sparam","param","getStaticEnvForSelected","selTree","selectedNodeEnv","env","newEnv","selectedNode","mainDefinition","replaceNode","newNode","parentLookup","parent","oldChild","newChild","replaceSignature","n","replaceStreamExprArr","replaceFunctionExpression","replaceName","replaceStreamExpr","replaceBodyExprArr","replaceTreeBody","replaceChild","handleInstantEditAction","deleteFromArr","nodeToRemove","indexOf","newArr","slice","newRoot","newElems","newSibSel","newParent","newExprs","deleteNodeSubtree","computeParentLookup","root","child","attemptBeginEditSelected","stableSelTree","editing","sessionId","initSelTree","curSelTree","compileError","isInsert","infixMode","arrInsertBeforeAfter","before","newIdx","attemptInsertBeforeAfter","newElem","newMain","pushUndo","undoStack","fixupDanglingRefs","globalEnv","oldNodeToNew","transform","newNewNode","xStreamExprArr","changed","el","nel","xSignature","tn","newFunc","xFuncExpr","newOuts","newName","xOuts","newSargs","newFargs","xFuncExprArr","newExpr","xStreamExpr","xName","xBodyExprArr","newSig","newSparams","xStreamParamArr","newFparams","xFunctionParamArr","newBody","xTreeBody","transformChildren","compileSelTree","nf","updateExecution","newCompiledDefinition","execution","updateCompiledDefinition","createLiveFunction","initialDefinition","outerStreamEnv","outerFuncEnv","activations","currentDefinition","activation","funcEnv","applicationContexts","updateLocalDef","context","sf","updateDef","expectedArgCount","appFunc","getExisting","sargVals","fargVals","error","newDefinition","JSON","stringify","oldDefStreams","newDefStreams","oldAppMap","newAppMap","app","oldLocalDefsMap","newLocalDefsMap","nativeFunctionEnvironment","liveStreamFunc","attemptCommitEdit","newSelTree","fixedSelTree","nodeIsHole","findNextHoleUnder","recur","newProgram","initialStateFromDefinition","info","programInfo","insertAgain","tryInsert","editNode","editSelTree","under","parentsChildren","nodeIdx","sib","attemptChainEdit","newSelectedNode","handleEditActionResult","globalNativeFunctions","ui","signature","tmplStr","clipboardStack","Array","of","id","jsFunc","mdId","StoragePanel","onChangeName","onLoadProgram","ls","localStorage","useState","selectedProgramId","setSelectedProgramId","savedPrograms","setSavedPrograms","refreshSavedPrograms","useCallback","setProgramId","newProgramId","sp","k","startsWith","json","getItem","obj","parse","savedProgramIds","prog","includes","useEffect","selectRef","useRef","className","onChange","onClick","setItem","disabled","progId","hits","filter","removeItem","parseTemplateString","splits","split","trim","substr","useSelectable","isHovered","setIsHovered","classes","isSelected","markedNodes","selected","isReferent","referentName","useLayoutEffect","focusSelected","focus","handlers","tagName","stopPropagation","setSelectedNode","onMouseOver","onMouseOut","tabIndex","SimpleNodeView","treeNode","content","icon","bgColor","selectionClasses","selectionHandlers","join","src","alt","sizedSimpleNodeView","singleLineWidth","reactNode","objKeyWeakMap","WeakMap","nextKey","RowView","layout","groupingLines","selectionRows","onKeyDown","getModifierState","located","row","rowIdx","item","itemIdx","contains","newItemIdx","newRowIdx","selectionRow","itemElems","items","React","createRef","newKey","objKey","sizedReactNode","indent","sizedRowView","sizedTemplateView","template","nodeMap","createLayout","trySingleLine","accumItems","accumLength","totalWidth","emitAccumItems","piece","nodes","ellipsis","singleLayout","multiLayout","sizedNameView","sizedStreamExpressionView","quotesIcon","booleanIcon","sizedBodyExpressionView","sizedArrayLiteralView","streamDef","staticEnv","sizedStreamReferenceView","functionNode","farg","sizedFunctionExpressionView","sizedApplicationView","StreamExpressionView","sizedTreeFunctionDefinitionView","fparam","bodyExpr","sizedFunctionDefinitionView","TreeFunctionDefinitionView","functionUIAsPlainText","resultPieces","templateToPlainText","FLOAT_REGEX","ChoiceView","choice","treeViewCtx","ExpressionChooser","dispatch","useMemo","atRoot","inputRef","select","selectedListElem","scrollIntoView","block","inline","initNode","setText","generateChoices","choices","test","envStreamSearchItems","sdef","envStreamSearchResults","Fuse","keys","search","envFuncSearchItems","defAsText","envFuncSearchResults","funcDefNode","thisYieldReturned","bv","realizeChoice","index","recomputeDropdownChoices","adjustDropdownIndex","amount","setDropdownState","oldState","dropdownState","newText","initElemNode","newArrNode","preventDefault","inputText","bindNode","autoFocus","classNames","NameChooser","Chooser","keyMap","TOGGLE_EDIT","ABORT_EDIT","INFIX_EDIT","INSERT_BEFORE","INSERT_AFTER","DELETE_SUBTREE","EDIT_NEXT_UNDEFINED","UNDO","CUT","PASTE","COMMAND_CHARS","CATCH_IN_INPUTS","Editor","editorElem","firstRender","displayedSelTree","referentNameNode","selectedEnv","getReferentNameNodeOfSelected","positionedForEditSessionId","editingSessionId","cpElem","selElem","selRect","getBoundingClientRect","bottom","only","toLowerCase","altKey","ctrlKey","metaKey","chooserTreeViewCtx","App","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e3ebe777.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar currentUpdateFrame = null;\n\nvar ExecutionContext =\n/** @class */\nfunction () {\n  function ExecutionContext(streamFunc, onRequestUpdate, afterTerminate) {\n    if (afterTerminate === void 0) {\n      afterTerminate = null;\n    }\n\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      data: null,\n      cleanup: null,\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.openRecord = null;\n    this.updateCount = 0;\n  }\n\n  ExecutionContext.prototype.update = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // Push a new update frame onto the update stack for this context\n\n\n    var newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    var retval;\n\n    try {\n      retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn't get to, and something is amiss\n\n      if (this.recordCursor.next) {\n        throw new Error('Did not reach all hook records in update');\n      }\n    } finally {\n      // Pop the top frame from the update stack\n      var poppedFrame = currentUpdateFrame;\n\n      if (!poppedFrame) {\n        throw new Error('Cannot pop update frame because current is null');\n      }\n\n      if (poppedFrame.executionContext !== this) {\n        throw new Error(\"Popped frame from update stack but context did not match\");\n      }\n\n      currentUpdateFrame = poppedFrame.previousFrame;\n    }\n\n    this.updateCount++;\n    return retval;\n  };\n\n  ExecutionContext.prototype.terminate = function () {\n    // NOTE: Might we want to sanity check that this context isn't anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (var c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  };\n\n  ExecutionContext.prototype._beginHook = function () {\n    if (this.openRecord) {\n      throw new Error('This is already an open hook when beginning another');\n    }\n\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error('Expecting to create new hook record in chain, but already present');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: null,\n        cleanup: null,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error('Expecting to find hook record in chain, but not present');\n    }\n\n    this.openRecord = this.recordCursor.next;\n    return this.recordCursor.next;\n  };\n\n  ExecutionContext.prototype._endHook = function () {\n    if (!this.recordCursor) {\n      throw new Error();\n    }\n\n    if (this.openRecord !== this.recordCursor.next) {\n      throw new Error('Hook close does not match open');\n    }\n\n    this.openRecord = null;\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  };\n\n  ExecutionContext.prototype._requestUpdate = function () {\n    this.onRequestUpdate();\n  };\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It's currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  ExecutionContext.prototype._setStreamFunc = function (newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  };\n\n  return ExecutionContext;\n}();\n\nexports.ExecutionContext = ExecutionContext;\nvar currentBatch = null;\n\nfunction beginBatch() {\n  if (currentBatch) {\n    throw new Error('cannot begin batch when one is already active');\n  }\n\n  currentBatch = {\n    callbacks: new Set()\n  };\n}\n\nexports.beginBatch = beginBatch;\n\nfunction endBatch() {\n  if (!currentBatch) {\n    throw new Error('cannot end batch when none is active');\n  }\n\n  currentBatch.callbacks.forEach(function (cb) {\n    cb();\n  });\n  currentBatch = null;\n}\n\nexports.endBatch = endBatch;\n\nfunction enqueueBatchedUpdate(callback) {\n  if (currentBatch) {\n    currentBatch.callbacks.add(callback);\n  } else {\n    // NOTE: If there is no current batch, we just call the callback immediately\n    callback();\n  }\n}\n\nexports.enqueueBatchedUpdate = enqueueBatchedUpdate;\n\nfunction createNullaryVoidRootExecutionContext(streamFunc) {\n  var updateCount = 0;\n\n  var updateCtx = function updateCtx() {\n    var t0 = performance.now();\n    ctx.update();\n    var dt = performance.now() - t0;\n    updateCount++;\n    console.log('root update', 'count', updateCount, 'time', dt.toFixed(2) + 'ms');\n  };\n\n  var onRequestUpdate = function onRequestUpdate() {\n    enqueueBatchedUpdate(updateCtx);\n  };\n\n  var ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n\nexports.createNullaryVoidRootExecutionContext = createNullaryVoidRootExecutionContext;\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error('Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n/**\n * If initVal is a function, it will be called on first update to generate initial value.\n */\n\n\nfunction useVar(initVal) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    var actualInitVal = initVal instanceof Function ? initVal() : initVal;\n    record.data = {\n      current: actualInitVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n\nexports.useVar = useVar;\n/**\n * Why do we need a hook? Why can't we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: function requestUpdate() {\n        ctx._requestUpdate(); // it's important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\n\nexports.useRequestUpdate = useRequestUpdate;\n\nfunction useInitialize(initializer) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer() || null;\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\n\nexports.useInitialize = useInitialize;\n\nfunction useEventEmitter() {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var subscribers_1 = new Set();\n    var stream = {\n      subscribe: function subscribe(onValue) {\n        subscribers_1.add(onValue);\n        return function () {\n          subscribers_1.delete(onValue);\n        };\n      }\n    };\n\n    var emit = function emit(value) {\n      subscribers_1.forEach(function (sub) {\n        sub(value);\n      });\n    };\n\n    record.data = {\n      stream: stream,\n      emit: emit\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\n\nexports.useEventEmitter = useEventEmitter;\n\nfunction useEventReceiver(stream) {\n  ;\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    var queue_1 = [];\n    var data_1 = {\n      queue: queue_1,\n      lastStream: null,\n      unsubscribe: null,\n      onValue: function onValue(value) {\n        queue_1.push(value);\n      }\n    };\n    record.data = data_1;\n\n    record.cleanup = function () {\n      if (data_1.unsubscribe) {\n        data_1.unsubscribe();\n      }\n    };\n  }\n\n  var retval;\n  var recordData = record.data;\n\n  if (stream !== recordData.lastStream) {\n    // Stream changed identity\n    // I _think_ we want to disallow this, since semantics are unclear\n    if (recordData.queue.length) {\n      throw new Error('useEventReceiver stream changed, but value is in queue');\n    }\n\n    if (recordData.lastStream) {\n      if (!recordData.unsubscribe) {\n        throw new Error('should not be possible');\n      }\n\n      recordData.unsubscribe();\n      recordData.lastStream = null;\n      recordData.unsubscribe = null;\n    } // TODO: We could validate that it's either undefined or null or a valid stream object\n\n\n    recordData.lastStream = stream;\n\n    if (stream) {\n      recordData.unsubscribe = stream.subscribe(recordData.onValue);\n    }\n  } else {\n    // Stream did not change identity. Check if there is an value in the queue\n    if (recordData.queue.length) {\n      if (recordData.queue.length > 1) {\n        throw new Error('useEventReceiver found more than one enqueued value');\n      }\n\n      var eventValue = recordData.queue.pop(); // assertion is OK because we verified length is 1\n\n      retval = {\n        value: eventValue\n      };\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useEventReceiver = useEventReceiver;\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new \"version\" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    // If no onRequestUpdate is provided, default to requesting update on the current context\n    var oru_1 = onRequestUpdate || function () {\n      ctx._requestUpdate();\n    };\n\n    var data_2 = {\n      // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n      activeContexts: new Set(),\n      // Create \"factory\" function to instantiate new contexts\n      createContext: function createContext() {\n        var ctx = new ExecutionContext(data_2.streamFunc, oru_1, function () {\n          data_2.activeContexts.delete(ctx);\n        });\n        data_2.activeContexts.add(ctx);\n        return ctx;\n      },\n      streamFunc: function streamFunc() {\n        throw new Error('should be unreachable');\n      }\n    };\n    record.data = data_2;\n\n    record.cleanup = function () {\n      data_2.activeContexts.forEach(function (ctx) {\n        return ctx.terminate();\n      });\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n  record.data.activeContexts.forEach(function (ctx) {\n    ctx._setStreamFunc(streamFunc);\n  });\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\n\nexports.useDynamic = useDynamic;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useReducer(evts, reducerFunc, initialState) {\n  var state = useVar(initialState);\n  var evt = useEventReceiver(evts);\n\n  if (evt) {\n    state.current = reducerFunc(state.current, evt.value);\n  }\n\n  return state.current;\n}\n\nexports.useReducer = useReducer;\n/**\n * NOTE: streamReducerPairs must not change length.\n */\n\nfunction useReducers(streamReducerPairs, initialState) {\n  var state = useVar(initialState);\n  var numStreams = useVar(streamReducerPairs.length);\n\n  if (streamReducerPairs.length !== numStreams.current) {\n    // NOTE: We could allow this with some extra work\n    throw new Error('The number of streams/reducers supplied to useMultiReducer cannot change');\n  } // It's safe to call hook in this loop because we made sure that the length is the same\n\n\n  var evtCount = 0;\n\n  for (var _i = 0, streamReducerPairs_1 = streamReducerPairs; _i < streamReducerPairs_1.length; _i++) {\n    var _a = streamReducerPairs_1[_i],\n        evts = _a[0],\n        reducer = _a[1];\n    var evt = useEventReceiver(evts);\n\n    if (evt) {\n      if (evtCount > 0) {\n        // TODO: We _could_ handle these sequentially.. should we have a flag that says whether to allow or not?\n        throw new Error('useMultiReducer got multiple events, cannot merge');\n      }\n\n      state.current = reducer(state.current, evt.value);\n      evtCount++;\n    }\n  }\n\n  return state.current;\n}\n\nexports.useReducers = useReducers;\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n * If initialState is a function, it will be called on first update to generate initial state.\n */\n\nfunction useCallbackReducer(reducerFunc, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState); // We cache the callback, though I don't think we really need to?\n\n  var callback = useVar(function () {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callback.current];\n}\n\nexports.useCallbackReducer = useCallbackReducer;\n\nfunction useCallbackReducers(reducerFuncs, initialState) {\n  var requestUpdate = useRequestUpdate();\n  var state = useVar(initialState);\n  var callbacks = reducerFuncs.map(function (reducerFunc) {\n    return function (action) {\n      state.current = reducerFunc(state.current, action);\n      requestUpdate();\n    };\n  });\n  return [state.current, callbacks];\n}\n\nexports.useCallbackReducers = useCallbackReducers;\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  var ctx = getTopUpdatingExecutionContext();\n\n  var record = ctx._beginHook();\n\n  var takeTransition = function takeTransition(trans) {\n    // If there's an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    var newState = trans[0],\n        newStateArg = trans[1]; // Create a new context and store it in record (but don't update it)\n\n    var newCtx = new ExecutionContext(states[newState], function () {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    var data_3 = {\n      activeContext: null\n    };\n    record.data = data_3;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = function () {\n      if (!data_3.activeContext) {\n        throw new Error('should have been initialized');\n      }\n\n      data_3.activeContext.terminate();\n    };\n  }\n\n  var retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    var _a = record.data.activeContext.update(record.data.activeArgument),\n        tmpRetval = _a[0],\n        transition = _a[1];\n\n    retval = tmpRetval; // Did the state function return a transition to take?\n\n    if (transition) {\n      takeTransition(transition); // And loop again\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n\nexports.useMachine = useMachine;","import { useVar, useInitialize } from 'riv-runtime';\n\nvar snabbdom = require('snabbdom');\n\nvar patch = snabbdom.init([require('snabbdom/modules/class').default, require('snabbdom/modules/attributes').default, require('snabbdom/modules/style').default, require('snabbdom/modules/eventlisteners').default]);\nexport var h = require('snabbdom/h').default; // helper function for creating vnodes\n\nfunction cloneNode(vnode) {\n  return {\n    sel: vnode.sel,\n    data: vnode.data,\n    children: vnode.children && vnode.children.map(cloneNode),\n    text: vnode.text,\n    key: vnode.key,\n    elm: vnode.elm // I think this should be unset in our usage, since we only clone before passing to patch\n\n  };\n}\n/**\n * Note that element is only read upon init\n */\n\n\nexport function renderDOMIntoElement(vnode, containerElement) {\n  var savedContainerElement = useVar();\n  var previousVnode = useVar();\n  useInitialize(function () {\n    return function () {\n      // cleanup\n      if (savedContainerElement.current) {\n        savedContainerElement.current.innerHTML = ''; // I think we want to do this\n      }\n    };\n  });\n\n  if (!containerElement || !vnode) {\n    return;\n  }\n\n  savedContainerElement.current = containerElement; // It's important that we clone the incoming vnode, because snabbdom will mutate it when we\n  // pass it to patch.\n\n  var clonedVnode = cloneNode(vnode);\n\n  if (previousVnode.current) {\n    patch(previousVnode.current, clonedVnode);\n  } else {\n    // First patch\n    // Insert a dummy element because snabbdom replaces it (rather than inserting under)\n    var elem = document.createElement('div');\n    savedContainerElement.current.appendChild(elem);\n    patch(elem, clonedVnode);\n  }\n\n  previousVnode.current = clonedVnode;\n} // selector may change, but once a valid one is passed, further changes will be ignored\n\nexport function renderDOMIntoSelector(vnode, containerSelector) {\n  var containerElement;\n\n  try {\n    containerElement = document.querySelector(containerSelector);\n  } catch (e) {// ignore\n  }\n\n  renderDOMIntoElement(vnode, containerElement);\n}\nexport function renderDOMAppendedToBody(vnode) {\n  var savedContainerElement = useVar();\n  useInitialize(function () {\n    var containerElement = document.createElement('div');\n    document.body.appendChild(containerElement);\n    savedContainerElement.current = containerElement;\n    return function () {\n      // cleanup\n      document.body.removeChild(containerElement);\n    };\n  });\n  renderDOMIntoElement(vnode, savedContainerElement.current);\n}","module.exports = __webpack_public_path__ + \"static/media/quotes.afec1851.svg\";","module.exports = __webpack_public_path__ + \"static/media/boolean.3e99c949.svg\";","import _toConsumableArray from \"/Users/russ/tmp/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/russ/tmp/riv/packages/brim/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _require = require('riv-runtime'),\n    useVar = _require.useVar,\n    useRequestUpdate = _require.useRequestUpdate,\n    useInitialize = _require.useInitialize,\n    useEventEmitter = _require.useEventEmitter,\n    useEventReceiver = _require.useEventReceiver,\n    useDynamic = _require.useDynamic,\n    useReducer = _require.useReducer,\n    useReducers = _require.useReducers;\n\nvar _require2 = require('riv-snabbdom'),\n    renderDOMAppendedToBody = _require2.renderDOMAppendedToBody,\n    h = _require2.h;\n\nexport function showString(v) {\n  var vnode = h('div', {\n    style: {\n      border: '1px solid red',\n      color: 'black',\n      fontSize: '24px',\n      padding: '5px',\n      marginTop: '20px'\n    }\n  }, 'showString: ' + (v === undefined ? '(undefined)' : v.toString()));\n  renderDOMAppendedToBody(vnode);\n}\nexport function animationFrameEvts() {\n  var requestUpdate = useRequestUpdate();\n  var reqId = useVar();\n\n  var _useEventEmitter = useEventEmitter(),\n      _useEventEmitter2 = _slicedToArray(_useEventEmitter, 2),\n      frameEvts = _useEventEmitter2[0],\n      emitFrame = _useEventEmitter2[1];\n\n  useInitialize(function () {\n    var onFrame = function onFrame(t) {\n      emitFrame(0.001 * t);\n      requestUpdate();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return function () {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\nexport function latestValue(evts, initialValue) {\n  return useReducer(evts, function (_, value) {\n    return value;\n  }, initialValue);\n}\n\nfunction mapEvts(inputEvts) {\n  var inputEvt = useEventReceiver(inputEvts);\n\n  var _useEventEmitter3 = useEventEmitter(),\n      _useEventEmitter4 = _slicedToArray(_useEventEmitter3, 2),\n      outputEvts = _useEventEmitter4[0],\n      emitOutput = _useEventEmitter4[1];\n\n  if (inputEvt) {\n    emitOutput(inputEvt.value);\n  } // TODO: We don't need to request update since we are already being updated\n\n\n  return outputEvts;\n}\n\nfunction mergeEvts(streams) {\n  var _useEventEmitter5 = useEventEmitter(),\n      _useEventEmitter6 = _slicedToArray(_useEventEmitter5, 2),\n      outputEvts = _useEventEmitter6[0],\n      emitOutput = _useEventEmitter6[1]; // TODO: This is a hack that assumes array length never changes\n\n\n  var evts = _toConsumableArray(streams).map(function (stream) {\n    return useEventReceiver(stream);\n  }).filter(function (e) {\n    return e;\n  });\n\n  if (evts.length > 1) {\n    throw new Error('Failed to merge events since more than one present');\n  } else if (evts.length === 1) {\n    emitOutput(evts[0].value);\n  }\n\n  return outputEvts;\n}\n\nexport function animationTime() {\n  return latestValue(animationFrameEvts(), function () {\n    return 0.001 * performance.now();\n  });\n}\nexport function countEvents(evts) {\n  return useReducer(evts, function (previousCount) {\n    return previousCount + 1;\n  }, 0);\n}\n\nfunction makeAsyncCallback() {\n  var _useEventEmitter7 = useEventEmitter(),\n      _useEventEmitter8 = _slicedToArray(_useEventEmitter7, 2),\n      evts = _useEventEmitter8[0],\n      emit = _useEventEmitter8[1];\n\n  var requestUpdate = useRequestUpdate();\n\n  var callback = function callback() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    emit(args);\n    requestUpdate();\n  };\n\n  return [callback, evts];\n}\n\nfunction domEvts(eventTarget, type, extra) {\n  // TODO: We should cache type/extra\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter9 = useEventEmitter(),\n      _useEventEmitter10 = _slicedToArray(_useEventEmitter9, 2),\n      evts = _useEventEmitter10[0],\n      emit = _useEventEmitter10[1];\n\n  useInitialize(function () {\n    var onEvent = function onEvent(e) {\n      emit(e);\n      requestUpdate();\n    };\n\n    document.addEventListener(type, onEvent, extra);\n    return function () {\n      // cleanup\n      document.removeEventListener(type, onEvent, extra);\n    };\n  });\n  return evts;\n}\n\nexport function mouseClickEvts() {\n  return domEvts(document, 'mousedown');\n}\nexport function mouseDown() {\n  var downEvts = domEvts(document, 'mousedown');\n  var upEvts = domEvts(document, 'mouseup');\n  return useReducers([[upEvts, function () {\n    return false;\n  }], [downEvts, function () {\n    return true;\n  }]], false); // We can't poll down-ness, so we assume it's initially not down\n}\nexport function mousePosition() {\n  return latestValue(mapEvts(domEvts(document, 'mousemove'), function (e) {\n    return {\n      x: e.clientX || e.pageX,\n      y: e.clientY || e.pageY\n    };\n  }), {\n    x: 0,\n    y: 0\n  });\n}\nexport function random(repickEvts) {\n  return useReducer(repickEvts, function () {\n    return Math.random();\n  }, function () {\n    return Math.random();\n  });\n}\nexport function audioDriver(generator) {\n  var createGenerator = useDynamic(generator);\n  var generatorCtx = useVar();\n  var frameCount = useVar(0);\n  var sampleRate = useVar();\n\n  var _useEventEmitter11 = useEventEmitter(),\n      _useEventEmitter12 = _slicedToArray(_useEventEmitter11, 2),\n      advanceFrameEvts = _useEventEmitter12[0],\n      emitAdvanceFrameEvt = _useEventEmitter12[1];\n\n  useInitialize(function () {\n    generatorCtx.current = createGenerator();\n    var BUFFER_SIZE = 1024;\n    var audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    var scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = function (e) {\n      var buffer = e.outputBuffer.getChannelData(0);\n\n      for (var i = 0; i < buffer.length; i++) {\n        emitAdvanceFrameEvt();\n        var frameVal = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n\n        if (!frameVal || Number.isNaN(frameVal)) {\n          frameVal = 0;\n        } else if (frameVal > 1) {\n          frameVal = 1;\n        } else if (frameVal < -1) {\n          frameVal = -1;\n        }\n\n        buffer[i] = frameVal;\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return function () {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\nexport function sampleUpon(toSample, uponEvts, initialValue) {\n  return useReducer(uponEvts, function () {\n    return toSample;\n  }, initialValue);\n}\nexport function everySecond() {\n  var requestUpdate = useRequestUpdate();\n\n  var _useEventEmitter13 = useEventEmitter(),\n      _useEventEmitter14 = _slicedToArray(_useEventEmitter13, 2),\n      tickEvts = _useEventEmitter14[0],\n      emitTick = _useEventEmitter14[1];\n\n  useInitialize(function () {\n    var onInterval = function onInterval() {\n      emitTick();\n      requestUpdate();\n    };\n\n    var timerId = setInterval(onInterval, 1000);\n    return function () {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\nexport function loadAudioAsArray(url) {\n  var requestUpdate = useRequestUpdate();\n  var pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(function () {\n    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    var cleanedUp = false;\n    var request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = function () {\n      var audioData = request.response;\n      audioCtx.decodeAudioData(audioData, function (buffer) {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return function () {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nexport function integral(integrandFunc, time) {\n  var initialValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var accum = useVar(initialValue);\n  var prevTime = useVar(time);\n  var integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\nexport function expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(function (currentValue) {\n    return speedConstant * (targetValue - currentValue);\n  }, time, initialValue);\n}\nexport function redCircle(position) {\n  var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 25;\n  var p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  var halfRadius = 0.5 * radius;\n  var vnode = h('div', {\n    style: {\n      position: 'absolute',\n      borderRadius: '50%',\n      background: 'red',\n      pointerEvents: 'none',\n      userSelect: 'none',\n      left: p.x - halfRadius + 'px',\n      top: p.y - halfRadius + 'px',\n      width: radius + 'px',\n      height: radius + 'px'\n    }\n  });\n  renderDOMAppendedToBody(vnode);\n}\nexport function followAtSpeed2d(target, speed, time, initial) {\n  var pos = useVar(initial);\n  var prevTime = useVar(time);\n  var dt = time - prevTime.current;\n  var delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  var dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\nfunction eventWhen(condition, valueToEmit) {\n  var prevCondition = useVar(false);\n  var bcond = !!condition;\n  var retval = bcond && !prevCondition.current ? {\n    value: valueToEmit\n  } : undefined;\n  prevCondition.current = bcond;\n  return retval;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nexport function eventAfter(seconds, valueToEmit) {\n  var _useEventEmitter15 = useEventEmitter(),\n      _useEventEmitter16 = _slicedToArray(_useEventEmitter15, 2),\n      evts = _useEventEmitter16[0],\n      emit = _useEventEmitter16[1];\n\n  var value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(function () {\n    var timerId = setTimeout(function () {\n      emit(value.current);\n    }, 1000 * seconds);\n    return function () {\n      clearTimeout(timerId);\n    };\n  });\n  return evts;\n}\nexport function received(evts) {\n  return useReducer(evts, function (previousState, event) {\n    return true;\n  }, false);\n}\n/**\n * F is a stream function that must stay hook-equivalent.\n */\n\nexport function streamMap(f) {\n  var arr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var createFContext = useDynamic(f);\n  var fContexts = useVar([]); // Create or destrooy contexts as needed to match arr length\n\n  while (arr.length > fContexts.current.length) {\n    fContexts.current.push(createFContext());\n  }\n\n  while (arr.length < fContexts.current.length) {\n    var ctx = fContexts.current.pop();\n    ctx.terminate();\n  }\n\n  var outs = fContexts.current.map(function (ctx, i) {\n    return ctx.update(arr[i]);\n  });\n  return outs;\n}\nexport function changeCount(s) {\n  var count = useVar(0);\n  var previous = useVar(s);\n\n  if (!Object.is(s, previous.current)) {\n    count.current++;\n  }\n\n  previous.current = s;\n  return count.current;\n}","const gen32 = (): string => Math.random().toString(16).substring(2, 10);\n\nexport default (): string => gen32() + gen32();\n","import genuid from './uid';\nimport { FunctionUI } from './FunctionUI';\n\n/**\n * IDS\n */\nexport type StreamID = string;\nexport type FunctionID = string;\nexport type ApplicationID = string;\n\nconst STREAM_ID_PREFIX = 'S-';\nexport function generateStreamId(): StreamID {\n  return STREAM_ID_PREFIX + genuid();\n}\nexport function validStreamId(s: string): s is StreamID {\n  return s.startsWith(STREAM_ID_PREFIX);\n}\n\nconst FUNCTION_ID_PREFIX = 'F-';\nexport function generateFunctionId(): FunctionID {\n  return FUNCTION_ID_PREFIX + genuid();\n}\nexport function validFunctionId(s: string): s is FunctionID {\n  return s.startsWith(FUNCTION_ID_PREFIX);\n}\n\nconst APPLICATION_ID_PREFIX = 'A-';\nexport function generateApplicationId(): ApplicationID {\n  return APPLICATION_ID_PREFIX + genuid();\n}\nexport function validApplicationId(s: string): s is ApplicationID {\n  return s.startsWith(APPLICATION_ID_PREFIX);\n}\n\n/**\n * NODE KINDS\n */\nexport enum NodeKind {\n  Name = 'name',\n  UndefinedLiteral = 'und',\n  NumberLiteral = 'num',\n  TextLiteral = 'str',\n  BooleanLiteral = 'bool',\n  ArrayLiteral = 'arr',\n  StreamReference = 'sref',\n  Application = 'app',\n  FunctionReference = 'fref',\n  SignatureStreamParameter = 'sig-sparam',\n  SignatureFunctionParameter = 'sig-fparam',\n  SignatureYield = 'sig-yield',\n  Signature = 'sig',\n  YieldExpression = 'yield',\n  StreamParameter = 'sparam',\n  FunctionParameter = 'fparam',\n  TreeFunctionBody = 'tbody',\n  TreeFunctionDefinition = 'tdef',\n  NativeFunctionDefinition = 'ndef',\n}\n\n/**\n * COMMON NODES\n */\nexport interface NameNode {\n  readonly kind: NodeKind.Name;\n  readonly text: string;\n}\n\n/**\n * STREAM NODES\n */\nexport interface UndefinedLiteralNode {\n  readonly kind: NodeKind.UndefinedLiteral;\n  readonly sid: StreamID;\n}\n\nexport interface NumberLiteralNode {\n  readonly kind: NodeKind.NumberLiteral;\n  readonly sid: StreamID;\n  readonly val: number;\n}\n\nexport interface TextLiteralNode {\n  readonly kind: NodeKind.TextLiteral;\n  readonly sid: StreamID;\n  readonly val: string;\n}\n\nexport interface BooleanLiteralNode {\n  readonly kind: NodeKind.BooleanLiteral;\n  readonly sid: StreamID;\n  readonly val: boolean;\n}\n\nexport type SimpleLiteralNode = UndefinedLiteralNode | NumberLiteralNode | TextLiteralNode | BooleanLiteralNode;\nexport function isSimpleLiteralNode(node: Node): node is SimpleLiteralNode {\n  return (node.kind === NodeKind.UndefinedLiteral) || (node.kind === NodeKind.NumberLiteral) || (node.kind === NodeKind.TextLiteral) || (node.kind === NodeKind.BooleanLiteral);\n}\n\nexport interface ArrayLiteralNode {\n  readonly kind: NodeKind.ArrayLiteral;\n  readonly aid: ApplicationID;\n  readonly sid: StreamID;\n  readonly elems: ReadonlyArray<StreamExpressionNode>;\n}\n\nexport interface StreamReferenceNode {\n  readonly kind: NodeKind.StreamReference;\n  readonly ref: StreamID; // the stream id we are referencing\n}\n\nexport interface ApplicationOut {\n  readonly sid: StreamID;\n  readonly name: NameNode | null; // if this output was given a local name\n}\n\nexport interface ApplicationNode {\n  readonly kind: NodeKind.Application;\n  readonly aid: ApplicationID;\n  readonly outs: ReadonlyArray<ApplicationOut>; // array since there can be multiple yields\n  readonly func: FunctionExpressionNode; // function being applied\n  readonly sargs: ReadonlyArray<StreamExpressionNode>;\n  readonly fargs: ReadonlyArray<FunctionExpressionNode>;\n}\n\n// Stream parameter definitions (on the \"inside\" of a function def) are _not_ expressions.\nexport type StreamExpressionNode = SimpleLiteralNode | ArrayLiteralNode | StreamReferenceNode | ApplicationNode;\nexport function isStreamExpressionNode(node: Node): node is StreamExpressionNode {\n  return isSimpleLiteralNode(node) || (node.kind === NodeKind.ArrayLiteral) || (node.kind === NodeKind.StreamReference) || (node.kind === NodeKind.Application);\n}\n\n/**\n * FUNCTION NODES\n */\n\nexport interface SignatureStreamParameterNode {\n  readonly kind: NodeKind.SignatureStreamParameter;\n  // eventually, type info will go here\n}\n\n// When we auto-generate a function as an argument for this function-parameter,\n//  prefill its (internal) parameter/yield names as such.\nexport interface SignatureFunctionParameterTemplateNames {\n  readonly streamParams: ReadonlyArray<string>;\n  readonly funcParams: ReadonlyArray<string>;\n  readonly yields: ReadonlyArray<string>;\n}\n\nexport interface SignatureFunctionParameterNode {\n  readonly kind: NodeKind.SignatureFunctionParameter;\n  readonly sig: SignatureNode;\n  readonly templateNames: SignatureFunctionParameterTemplateNames;\n}\n\nexport interface SignatureYieldNode {\n  readonly kind: NodeKind.SignatureYield;\n  // eventually, type info will go here\n}\n\nexport interface SignatureNode {\n  readonly kind: NodeKind.Signature;\n  readonly streamParams: ReadonlyArray<SignatureStreamParameterNode>;\n  readonly funcParams: ReadonlyArray<SignatureFunctionParameterNode>;\n  readonly yields: ReadonlyArray<SignatureYieldNode>;\n  readonly returnedIdx: number | undefined; // which of the yields (if any) is returned to the tree-parent\n}\n\nexport interface YieldExpressionNode {\n  readonly kind: NodeKind.YieldExpression;\n  readonly idx: number;\n  readonly name: NameNode;\n  readonly expr: StreamExpressionNode;\n}\n\nexport type BodyExpressionNode = StreamExpressionNode | FunctionExpressionNode | YieldExpressionNode;\nexport function isBodyExpressionNode(node: Node): node is BodyExpressionNode {\n  return isStreamExpressionNode(node) || isFunctionExpressionNode(node) || (node.kind === NodeKind.YieldExpression);\n}\n\nexport interface TreeFunctionBodyNode {\n  readonly kind: NodeKind.TreeFunctionBody;\n  readonly exprs: ReadonlyArray<BodyExpressionNode>;\n}\n\nexport interface StreamParameterNode {\n  readonly kind: NodeKind.StreamParameter;\n  readonly sid: StreamID;\n  readonly name: NameNode;\n}\n\nexport interface FunctionParameterNode {\n  readonly kind: NodeKind.FunctionParameter;\n  readonly fid: FunctionID;\n  readonly name: NameNode;\n}\n\nexport interface TreeFunctionDefinitionNode {\n  readonly kind: NodeKind.TreeFunctionDefinition;\n  readonly fid: FunctionID;\n  readonly sig: SignatureNode;\n  readonly ui: FunctionUI;\n\n  readonly sparams: ReadonlyArray<StreamParameterNode>;\n  readonly fparams: ReadonlyArray<FunctionParameterNode>;\n  readonly body: TreeFunctionBodyNode;\n}\n\nexport interface NativeFunctionDefinitionNode {\n  readonly kind: NodeKind.NativeFunctionDefinition;\n  readonly fid: FunctionID;\n  readonly sig: SignatureNode;\n  readonly ui: FunctionUI;\n\n  // TODO: JS code as string?\n}\n\nexport type FunctionDefinitionNode = TreeFunctionDefinitionNode | NativeFunctionDefinitionNode;\nexport function isFunctionDefinitionNode(node: Node): node is FunctionDefinitionNode {\n  return (node.kind === NodeKind.TreeFunctionDefinition) || (node.kind === NodeKind.NativeFunctionDefinition);\n}\n\nexport interface FunctionReferenceNode {\n  readonly kind: NodeKind.FunctionReference;\n  readonly ref: FunctionID; // the function id we are referencing\n}\n\nexport type FunctionExpressionNode = FunctionReferenceNode | FunctionDefinitionNode;\nexport function isFunctionExpressionNode(node: Node): node is FunctionExpressionNode {\n  return (node.kind === NodeKind.FunctionReference) || isFunctionDefinitionNode(node);\n}\n\nexport type Node = NameNode | SignatureNode | StreamParameterNode | FunctionParameterNode | TreeFunctionBodyNode | BodyExpressionNode | SignatureStreamParameterNode | SignatureFunctionParameterNode | SignatureYieldNode;\n","import { NodeKind, StreamID, FunctionID, StreamExpressionNode, FunctionExpressionNode } from './Tree';\n\nexport function streamExprReturnedId(node: StreamExpressionNode): StreamID | undefined {\n  switch (node.kind) {\n    case NodeKind.UndefinedLiteral:\n    case NodeKind.NumberLiteral:\n    case NodeKind.TextLiteral:\n    case NodeKind.BooleanLiteral:\n    case NodeKind.ArrayLiteral:\n      return node.sid;\n\n    case NodeKind.StreamReference:\n      return node.ref;\n\n    case NodeKind.Application:\n      // NOTE: This is hacky, but works.\n      //  We could be more robust by looking up the function definition and checking its signature.\n      //  That would require having the environment available.\n      for (const out of node.outs) {\n        if (!out.name) {\n          return out.sid;\n        }\n      }\n      return undefined;\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n}\n\nexport function functionExprId(node: FunctionExpressionNode): FunctionID {\n  switch (node.kind) {\n    case NodeKind.FunctionReference:\n      return node.ref;\n\n    case NodeKind.TreeFunctionDefinition:\n    case NodeKind.NativeFunctionDefinition:\n      return node.fid;\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n}\n","export default class Environment<K, V> {\n  private local: Map<K, V>;\n  private outer: Environment<K, V> | undefined;\n\n  constructor(outer: Environment<K, V> | undefined = undefined) {\n    this.local = new Map();\n    this.outer = outer;\n  }\n\n  has(key: K): boolean {\n    return this.local.has(key) || (!!this.outer && this.outer.has(key));\n  }\n\n  get(key: K): V | undefined {\n    return this.local.has(key) ? this.local.get(key) : (this.outer ? this.outer.get(key) : undefined);\n  }\n\n  getExisting(key: K): V {\n    if (!this.has(key)) {\n      throw new Error();\n    }\n    return this.get(key)!;\n  }\n\n  set(key: K, value: V): void {\n    this.local.set(key, value);\n  }\n\n  setNew(key: K, value: V): void {\n    if (this.has(key)) {\n      throw new Error();\n    }\n    this.set(key, value);\n  }\n\n  setExisting(key: K, value: V): void {\n    if (!this.local.has(key)) {\n      throw new Error();\n    }\n    this.set(key, value);\n  }\n\n  delete(key: K): boolean {\n    if (this.outer && this.outer.has(key)) {\n      throw new Error(); // prevent bugs\n    }\n    return this.local.delete(key);\n  }\n\n  forEach(cb: (value: V, key: K, map: Map<K, V>) => void): void {\n    this.local.forEach(cb);\n    if (this.outer) {\n      this.outer.forEach(cb);\n    }\n  }\n\n  entriesArray(): Array<[K, V]> {\n    let entries = [...this.local.entries()];\n    if (this.outer) {\n      entries = entries.concat(this.outer.entriesArray());\n    }\n    return entries;\n  }\n}\n","// import { Path, pathIsPrefix } from './State';\nimport { NodeKind, Node, SignatureNode, NameNode, StreamExpressionNode, isStreamExpressionNode, BodyExpressionNode, isBodyExpressionNode, TreeFunctionBodyNode, FunctionExpressionNode, isFunctionExpressionNode, ApplicationOut, StreamParameterNode, FunctionParameterNode } from './Tree';\n\nexport function firstChild(node: Node): Node | undefined {\n  const res = iterChildren(node).next();\n  return res.done ? undefined : res.value;\n}\n\nexport function lastChild(node: Node): Node | undefined {\n  const children = [...iterChildren(node)];\n  return children.pop();\n}\n\nexport function* iterChildren(node: Node) {\n  switch (node.kind) {\n    case NodeKind.Name:\n    case NodeKind.UndefinedLiteral:\n    case NodeKind.NumberLiteral:\n    case NodeKind.TextLiteral:\n    case NodeKind.BooleanLiteral:\n    case NodeKind.StreamReference:\n    case NodeKind.FunctionReference:\n      // no children\n      break;\n\n    case NodeKind.SignatureStreamParameter:\n    case NodeKind.SignatureFunctionParameter:\n    case NodeKind.SignatureYield:\n      // no children\n      break;\n\n    case NodeKind.ArrayLiteral:\n      yield* node.elems;\n      break;\n\n    case NodeKind.Application:\n      yield node.func;\n      for (const out of node.outs) {\n        if (out.name) {\n          yield out.name;\n        }\n      }\n      yield* node.sargs;\n      yield* node.fargs;\n      break;\n\n    case NodeKind.Signature:\n      yield* node.streamParams;\n      yield* node.funcParams;\n      yield* node.yields;\n      break;\n\n    case NodeKind.StreamParameter:\n    case NodeKind.FunctionParameter:\n      yield node.name;\n      break;\n\n    case NodeKind.YieldExpression:\n      yield node.expr;\n      break;\n\n    case NodeKind.TreeFunctionBody:\n      yield* node.exprs;\n      break;\n\n    case NodeKind.TreeFunctionDefinition:\n      yield node.sig;\n      yield* node.sparams;\n      yield* node.fparams;\n      yield node.body;\n      break;\n\n    case NodeKind.NativeFunctionDefinition:\n      yield node.sig;\n      break;\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n    }\n  }\n}\n\nfunction visitArray<N, C>(nodeArr: ReadonlyArray<Node>, visit: (node: Node, ctx: C) => N | undefined, ctx: C): N | undefined {\n  for (const node of nodeArr) {\n    const result = visit(node, ctx);\n    if (result) {\n      return result;\n    }\n  }\n}\n\nfunction visitOuts<N, C>(outs: ReadonlyArray<ApplicationOut>, visit: (node: Node, ctx: C) => N | undefined, ctx: C): N | undefined {\n  for (const out of outs) {\n    if (out.name) {\n      const result = visit(out.name, ctx);\n      if (result) {\n        return result;\n      }\n    }\n  }\n}\n\n/**\n * Note that this aborts if the visit function returns a truthy value.\n */\nexport function visitChildren<N, C>(node: Node, visit: (node: Node, ctx: C) => N | undefined, ctx: C): N | undefined {\n  switch (node.kind) {\n    case NodeKind.Name:\n    case NodeKind.UndefinedLiteral:\n    case NodeKind.NumberLiteral:\n    case NodeKind.TextLiteral:\n    case NodeKind.BooleanLiteral:\n    case NodeKind.StreamReference:\n    case NodeKind.FunctionReference:\n      // no children\n      return;\n\n    case NodeKind.SignatureStreamParameter:\n    case NodeKind.SignatureFunctionParameter:\n    case NodeKind.SignatureYield:\n      // no children\n      return;\n\n    case NodeKind.ArrayLiteral:\n      return visitArray(node.elems, visit, ctx);\n\n    case NodeKind.Application:\n      return visit(node.func, ctx) || visitOuts(node.outs, visit, ctx) || visitArray(node.sargs, visit, ctx) || visitArray(node.fargs, visit, ctx);\n\n    case NodeKind.Signature:\n      return visitArray(node.streamParams, visit, ctx) || visitArray(node.funcParams, visit, ctx) || visitArray(node.yields, visit, ctx);\n\n    case NodeKind.StreamParameter:\n    case NodeKind.FunctionParameter:\n      return visit(node.name, ctx);\n\n    case NodeKind.YieldExpression:\n      return visit(node.name, ctx) || visit(node.expr, ctx);\n\n    case NodeKind.TreeFunctionBody:\n      return visitArray(node.exprs, visit, ctx);\n\n    case NodeKind.TreeFunctionDefinition:\n      return visit(node.sig, ctx) || visitArray(node.sparams, visit, ctx) || visitArray(node.fparams, visit, ctx) || visit(node.body, ctx);\n\n    case NodeKind.NativeFunctionDefinition:\n      return visit(node.sig, ctx);\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n    }\n  }\n}\n\n// This will always return a node of the same kind, but I can't seem to express this with generics,\n// which makes the code way more complicated than it should be, but we ensure type safety.\nexport function transformChildren<T>(node: Node, transform: (node: Node, ctx: T) => Node, ctx: T): Node {\n  const xName = (n: NameNode): NameNode => {\n    const tn = transform(n, ctx);\n    if (tn.kind !== NodeKind.Name) {\n      throw new Error();\n    }\n    return tn;\n  };\n\n  const xOuts = (outs: ReadonlyArray<ApplicationOut>): ReadonlyArray<ApplicationOut> => {\n    let changed = false;\n    const newOuts = outs.map(out => {\n      if (out.name) {\n        const newName = transform(out.name, ctx);\n        if (newName.kind !== NodeKind.Name) {\n          throw new Error();\n        }\n        if (newName !== out.name) {\n          changed = true;\n        }\n        return {\n          ...out,\n          name: newName,\n        };\n      } else {\n        return out;\n      }\n    });\n    return changed ? newOuts : outs;\n  };\n\n  const xStreamExpr = (n: StreamExpressionNode): StreamExpressionNode => {\n    const tn = transform(n, ctx);\n    if (!isStreamExpressionNode(tn)) {\n      throw new Error();\n    }\n    return tn;\n  };\n\n  const xStreamExprArr = (arr: ReadonlyArray<StreamExpressionNode>): ReadonlyArray<StreamExpressionNode> => {\n    let changed = false;\n    const newArr = arr.map(el => {\n      const nel = transform(el, ctx);\n      if (!isStreamExpressionNode(nel)) {\n        throw new Error();\n      }\n      if (nel !== el) {\n        changed = true;\n      }\n      return nel;\n    });\n    return changed ? newArr : arr;\n  };\n\n  const xStreamParamArr = (arr: ReadonlyArray<StreamParameterNode>): ReadonlyArray<StreamParameterNode> => {\n    let changed = false;\n    const newArr = arr.map(el => {\n      const nel = transform(el, ctx);\n      if (nel.kind !== NodeKind.StreamParameter) {\n        throw new Error();\n      }\n      if (nel !== el) {\n        changed = true;\n      }\n      return nel;\n    });\n    return changed ? newArr : arr;\n  };\n\n  const xFunctionParamArr = (arr: ReadonlyArray<FunctionParameterNode>): ReadonlyArray<FunctionParameterNode> => {\n    let changed = false;\n    const newArr = arr.map(el => {\n      const nel = transform(el, ctx);\n      if (nel.kind !== NodeKind.FunctionParameter) {\n        throw new Error();\n      }\n      if (nel !== el) {\n        changed = true;\n      }\n      return nel;\n    });\n    return changed ? newArr : arr;\n  };\n\n  const xBodyExprArr = (arr: ReadonlyArray<BodyExpressionNode>): ReadonlyArray<BodyExpressionNode> => {\n    let changed = false;\n    const newArr = arr.map(el => {\n      const nel = transform(el, ctx);\n      if (!isBodyExpressionNode(nel)) {\n        throw new Error();\n      }\n      if (nel !== el) {\n        changed = true;\n      }\n      return nel;\n    });\n    return changed ? newArr : arr;\n  };\n\n  const xFuncExpr = (n: FunctionExpressionNode): FunctionExpressionNode => {\n    const tn = transform(n, ctx);\n    if (!isFunctionExpressionNode(tn)) {\n      throw new Error();\n    }\n    return tn;\n  };\n\n  const xFuncExprArr = (arr: ReadonlyArray<FunctionExpressionNode>): ReadonlyArray<FunctionExpressionNode> => {\n    let changed = false;\n    const newArr = arr.map(el => {\n      const nel = transform(el, ctx);\n      if (!isFunctionExpressionNode(nel)) {\n        throw new Error();\n      }\n      if (nel !== el) {\n        changed = true;\n      }\n      return nel;\n    });\n    return changed ? newArr : arr;\n  };\n\n  const xSignature = (n: SignatureNode): SignatureNode => {\n    const tn = transform(n, ctx);\n    if (tn.kind !== NodeKind.Signature) {\n      throw new Error();\n    }\n    return tn;\n  };\n\n  const xTreeBody = (n: TreeFunctionBodyNode): TreeFunctionBodyNode => {\n    const tn = transform(n, ctx);\n    if (tn.kind !== NodeKind.TreeFunctionBody) {\n      throw new Error();\n    }\n    return tn;\n  };\n\n  switch (node.kind) {\n    case NodeKind.Name:\n    case NodeKind.UndefinedLiteral:\n    case NodeKind.NumberLiteral:\n    case NodeKind.TextLiteral:\n    case NodeKind.BooleanLiteral:\n    case NodeKind.StreamReference:\n    case NodeKind.FunctionReference:\n      // no children to transform\n      return node;\n\n    case NodeKind.SignatureStreamParameter:\n    case NodeKind.SignatureFunctionParameter:\n    case NodeKind.SignatureYield:\n      // no children to transform\n      return node;\n\n    case NodeKind.ArrayLiteral:\n      const newElems = xStreamExprArr(node.elems);\n      if (newElems === node.elems) {\n        return node;\n      } else {\n        return {\n          ...node,\n          elems: newElems,\n        };\n      }\n\n    case NodeKind.Application: {\n      const newFunc = xFuncExpr(node.func);\n      const newOuts = xOuts(node.outs);\n      const newSargs = xStreamExprArr(node.sargs);\n      const newFargs = xFuncExprArr(node.fargs);\n      if ((newFunc === node.func) && (newOuts === node.outs) && (newSargs === node.sargs) && (newFargs === node.fargs)) {\n        return node;\n      } else {\n        return {\n          ...node,\n          func: newFunc,\n          outs: newOuts,\n          sargs: newSargs,\n          fargs: newFargs,\n        };\n      }\n    }\n\n    case NodeKind.Signature:\n      // TODO: implement\n      return node;\n\n    case NodeKind.YieldExpression: {\n      const newExpr = xStreamExpr(node.expr);\n      if (newExpr === node.expr) {\n        return node;\n      } else {\n        return {\n          ...node,\n          expr: newExpr,\n        };\n      }\n    }\n\n    case NodeKind.StreamParameter:\n    case NodeKind.FunctionParameter:\n      const newName = xName(node.name);\n      if (newName === node.name) {\n        return node;\n      } else {\n        return {\n          ...node,\n          name: newName,\n        };\n      }\n\n    case NodeKind.TreeFunctionBody: {\n      const newExprs = xBodyExprArr(node.exprs);\n      if (newExprs === node.exprs) {\n        return node;\n      } else {\n        return {\n          ...node,\n          exprs: newExprs,\n        };\n      }\n    }\n\n    case NodeKind.TreeFunctionDefinition: {\n      const newSig = xSignature(node.sig);\n      const newSparams = xStreamParamArr(node.sparams);\n      const newFparams = xFunctionParamArr(node.fparams);\n      const newBody = xTreeBody(node.body);\n      if ((newSig === node.sig) && (newSparams === node.sparams) && (newFparams === node.fparams) && (newBody === node.body)) {\n        return node;\n      } else {\n        return {\n          ...node,\n          sig: newSig,\n          sparams: newSparams,\n          fparams: newFparams,\n          body: newBody,\n        };\n      }\n    }\n\n    case NodeKind.NativeFunctionDefinition: {\n      const newSig = xSignature(node.sig);\n      if (newSig === node.sig) {\n        return node;\n      } else {\n        return {\n          ...node,\n          sig: newSig,\n        };\n      }\n    }\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n}\n\nexport function replaceChild(node: Node, oldChild: Node, newChild: Node): Node {\n  const replaceName = (n: NameNode): NameNode => {\n    if (n === oldChild) {\n      if (newChild.kind !== NodeKind.Name) {\n        throw new Error();\n      }\n      return newChild;\n    } else {\n      return n;\n    }\n  };\n\n  const replaceSignature = (n: SignatureNode): SignatureNode => {\n    if (n === oldChild) {\n      if (newChild.kind !== NodeKind.Signature) {\n        throw new Error();\n      }\n      return newChild;\n    } else {\n      return n;\n    }\n  };\n\n  const replaceTreeBody = (n: TreeFunctionBodyNode): TreeFunctionBodyNode => {\n    if (n === oldChild) {\n      if (newChild.kind !== NodeKind.TreeFunctionBody) {\n        throw new Error();\n      }\n      return newChild;\n    } else {\n      return n;\n    }\n  };\n\n  const replaceStreamExpr = (n: StreamExpressionNode): StreamExpressionNode => {\n    if (n === oldChild) {\n      if (!isStreamExpressionNode(newChild)) {\n        throw new Error();\n      }\n      return newChild;\n    } else {\n      return n;\n    }\n  };\n\n  const replaceStreamExprArr = (arr: ReadonlyArray<StreamExpressionNode>): ReadonlyArray<StreamExpressionNode> => {\n    return arr.map((n: StreamExpressionNode) => {\n      if (n === oldChild) {\n        if (!isStreamExpressionNode(newChild)) {\n          throw new Error();\n        }\n        return newChild;\n      } else {\n        return n;\n      }\n    });\n  };\n\n  const replaceFunctionExpression = (n: FunctionExpressionNode): FunctionExpressionNode => {\n    if (n === oldChild) {\n      if (!isFunctionExpressionNode(newChild)) {\n        throw new Error();\n      }\n      return newChild;\n    } else {\n      return n;\n    }\n  };\n\n  const replaceFuncExprArr = (arr: ReadonlyArray<FunctionExpressionNode>): ReadonlyArray<FunctionExpressionNode> => {\n    return arr.map((n: FunctionExpressionNode) => {\n      if (n === oldChild) {\n        if (!isFunctionExpressionNode(newChild)) {\n          throw new Error();\n        }\n        return newChild;\n      } else {\n        return n;\n      }\n    });\n  };\n\n  const replaceBodyExprArr = (arr: ReadonlyArray<BodyExpressionNode>): ReadonlyArray<BodyExpressionNode> => {\n    return arr.map((n: BodyExpressionNode) => {\n      if (n === oldChild) {\n        if (!isBodyExpressionNode(newChild)) {\n          throw new Error();\n        }\n        return newChild;\n      } else {\n        return n;\n      }\n    });\n  };\n\n  const replaceOuts = (outs: ReadonlyArray<ApplicationOut>): ReadonlyArray<ApplicationOut> => {\n    return outs.map((out: ApplicationOut) => {\n      if (out.name === oldChild) {\n        if (newChild.kind !== NodeKind.Name) {\n          throw new Error();\n        }\n        return {\n          ...out,\n          name: newChild,\n        };\n      } else {\n        return out;\n      }\n    });\n  };\n\n  switch (node.kind) {\n    case NodeKind.Name:\n    case NodeKind.UndefinedLiteral:\n    case NodeKind.NumberLiteral:\n    case NodeKind.TextLiteral:\n    case NodeKind.BooleanLiteral:\n    case NodeKind.StreamReference:\n    case NodeKind.FunctionReference:\n      throw new Error('no children to replace');\n\n    case NodeKind.SignatureStreamParameter:\n    case NodeKind.SignatureFunctionParameter:\n    case NodeKind.SignatureYield:\n      throw new Error('no children to replace');\n\n    case NodeKind.ArrayLiteral:\n      return {\n        ...node,\n        elems: replaceStreamExprArr(node.elems),\n      };\n\n    case NodeKind.Application:\n      return {\n        ...node,\n        func: replaceFunctionExpression(node.func),\n        outs: replaceOuts(node.outs),\n        sargs: replaceStreamExprArr(node.sargs),\n        fargs: replaceFuncExprArr(node.fargs),\n      };\n\n    case NodeKind.Signature:\n      return {\n        ...node,\n        // TODO: members\n      };\n\n    case NodeKind.StreamParameter:\n    case NodeKind.FunctionParameter:\n      return {\n        ...node,\n        name: replaceName(node.name),\n      };\n\n    case NodeKind.YieldExpression:\n      return {\n        ...node,\n        expr: replaceStreamExpr(node.expr),\n      };\n\n    case NodeKind.TreeFunctionBody:\n      return {\n        ...node,\n        exprs: replaceBodyExprArr(node.exprs),\n      };\n\n    case NodeKind.TreeFunctionDefinition:\n      return {\n        ...node,\n        sig: replaceSignature(node.sig),\n        body: replaceTreeBody(node.body),\n      };\n\n    case NodeKind.NativeFunctionDefinition:\n      return {\n        ...node,\n        sig: replaceSignature(node.sig),\n      };\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n      throw new Error(); // should be unreachable\n    }\n  }\n}\n","import { StreamID, FunctionID, Node, FunctionDefinitionNode, TreeFunctionDefinitionNode, StreamExpressionNode, NodeKind, isFunctionDefinitionNode, isStreamExpressionNode } from './Tree';\nimport { streamExprReturnedId, functionExprId } from './TreeUtil';\nimport { CompiledDefinition, ConstStreamSpec, LocalFunctionDefinition, AppSpec } from './CompiledDefinition';\nimport Environment from './Environment';\nimport { visitChildren } from './Traversal';\n\nexport class CompilationError extends Error {\n};\n\n// A stream id can be defined by either a stream expression or a parameter. If a stream id was\n// created by a parameter, then it maps to null (because we don't need to traverse from the param).\ntype CompilationStreamEnvironment = Environment<StreamID, StreamExpressionNode | null>;\ntype CompilationFunctionEnvironment = Environment<FunctionID, FunctionDefinitionNode>;\n\nfunction compileTreeDefinition(definition: TreeFunctionDefinitionNode, outerStreamEnvironment: CompilationStreamEnvironment, outerFunctionEnvironment: CompilationFunctionEnvironment): [CompiledDefinition, Set<StreamID>] {\n  const streamEnvironment: CompilationStreamEnvironment = new Environment(outerStreamEnvironment);\n  const functionEnvironment: CompilationFunctionEnvironment = new Environment(outerFunctionEnvironment);\n  const localStreamIds: Set<StreamID> = new Set();\n  const localFunctionIds: Set<FunctionID> = new Set();\n\n  // TODO: verify that internal parameters (sparams, fparams) match the signature\n\n  // Identify locally defined stream and function ids\n  definition.sparams.forEach(({sid}) => {\n    if (streamEnvironment.has(sid)) {\n      throw new Error('must be unique');\n    }\n    streamEnvironment.set(sid, null);\n    localStreamIds.add(sid);\n  });\n\n  // TODO: handle fparams as well\n\n  const visitToFindLocals = (node: Node): void => {\n    if (isStreamExpressionNode(node)) {\n      switch (node.kind) {\n        case NodeKind.UndefinedLiteral:\n        case NodeKind.NumberLiteral:\n        case NodeKind.TextLiteral:\n        case NodeKind.BooleanLiteral:\n        case NodeKind.ArrayLiteral:\n          if (streamEnvironment.has(node.sid)) {\n            throw new Error('must be unique');\n          }\n          streamEnvironment.set(node.sid, node);\n          localStreamIds.add(node.sid);\n          break;\n\n        case NodeKind.StreamReference:\n          // ignore because it doesn't define a stream id\n          break;\n\n        case NodeKind.Application:\n          node.outs.forEach(out => {\n            if (streamEnvironment.has(out.sid)) {\n              throw new Error('must be unique');\n            }\n            streamEnvironment.set(out.sid, node);\n            localStreamIds.add(out.sid);\n          });\n          break;\n\n        default: {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n          throw new Error();\n        }\n      }\n    } else if (isFunctionDefinitionNode(node)) {\n      // A local definition\n      if (functionEnvironment.has(node.fid)) {\n        throw new Error('must be unique');\n      }\n      functionEnvironment.set(node.fid, node);\n      localFunctionIds.add(node.fid);\n    }\n\n    if (!isFunctionDefinitionNode(node)) {\n      // Don't traverse into definitions, we want to stay local\n      visitChildren(node, visitToFindLocals, undefined);\n    }\n  };\n  visitChildren(definition.body, visitToFindLocals, undefined);\n\n  const constStreams: Array<ConstStreamSpec> = [];\n  const apps: Array<AppSpec> = [];\n  const localDefs: Array<LocalFunctionDefinition> = [];\n  const yieldIds: Array<StreamID> = [];\n  const externalReferencedStreamIds: Set<StreamID> = new Set();\n\n  // Compile local tree function definitions\n  for (const fid of localFunctionIds) {\n    const funcDef = functionEnvironment.get(fid);\n    if (!funcDef) {\n      throw new Error();\n    }\n    if (funcDef.kind === NodeKind.TreeFunctionDefinition) {\n      const [innerCompiledDef, ] = compileTreeDefinition(funcDef, streamEnvironment, functionEnvironment);\n      localDefs.push({fid, def: innerCompiledDef});\n    }\n  }\n\n  // Using terminology from https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search\n  const temporaryMarked: Set<StreamExpressionNode> = new Set();\n  const permanentMarked: Set<StreamExpressionNode> = new Set();\n\n  function traverseStreamExpr(node: StreamExpressionNode): void {\n    if (permanentMarked.has(node)) {\n      return;\n    }\n\n    if (temporaryMarked.has(node)) {\n      throw new CompilationError('graph cycle');\n    }\n\n    switch (node.kind) {\n      case NodeKind.UndefinedLiteral:\n        constStreams.push({sid: node.sid, val: undefined});\n        break;\n\n      case NodeKind.NumberLiteral:\n      case NodeKind.TextLiteral:\n      case NodeKind.BooleanLiteral:\n        constStreams.push({sid: node.sid, val: node.val});\n        break;\n\n      case NodeKind.ArrayLiteral: {\n        const streamArgIds: Array<StreamID> = [];\n\n        temporaryMarked.add(node);\n\n        for (const elem of node.elems) {\n          traverseStreamExpr(elem);\n          const elemRetSid = streamExprReturnedId(elem);\n          if (!elemRetSid) {\n            throw new Error();\n          }\n          streamArgIds.push(elemRetSid);\n        }\n\n        temporaryMarked.delete(node);\n\n        apps.push({\n          sids: [node.sid],\n          appId: node.aid,\n          funcId: 'Array_of',\n          sargIds: streamArgIds,\n          fargIds: [],\n        });\n\n        break;\n      }\n\n      case NodeKind.StreamReference:\n        if (localStreamIds.has(node.ref)) {\n          const targetExpressionNode = streamEnvironment.get(node.ref);\n          if (targetExpressionNode === null) {\n            // The reference is to a parameter, so we don't need to traverse\n          } else if (targetExpressionNode === undefined) {\n            throw Error();\n          } else {\n            temporaryMarked.add(node); // not really necessary to mark node here but might as well\n            traverseStreamExpr(targetExpressionNode);\n            temporaryMarked.delete(node);\n          }\n        } else {\n          if (!streamEnvironment.has(node.ref)) {\n            throw new CompilationError();\n          }\n          externalReferencedStreamIds.add(node.ref);\n        }\n        break;\n\n      case NodeKind.Application: {\n        const functionNode = functionEnvironment.get(functionExprId(node.func));\n        if (!functionNode) {\n          throw new CompilationError();\n        }\n\n        // TODO: make sure that sargs, fargs, yields all match signature\n\n        const streamArgIds: Array<StreamID> = [];\n        const funcArgIds: Array<FunctionID> = [];\n\n        temporaryMarked.add(node);\n\n        for (const sarg of node.sargs) {\n          traverseStreamExpr(sarg);\n          const sargRetSid = streamExprReturnedId(sarg);\n          if (!sargRetSid) {\n            throw new Error();\n          }\n          streamArgIds.push(sargRetSid);\n        }\n\n        for (const farg of node.fargs) {\n          const fid = functionExprId(farg);\n          const funcDef = functionEnvironment.get(fid);\n          if (!funcDef) {\n            throw new Error();\n          }\n\n          /*\n          if (funcDef.kind === NodeKind.TreeFunctionDefinition) {\n            const compiledContainedDef = compileTreeDefinition(funcDef, streamEnvironment, functionEnvironment);\n\n            compiledContainedDef.externalReferencedStreamIds.forEach((sid) => {\n              compiledDefinition.externalReferencedStreamIds.add(sid);\n            });\n\n            // An application needs to traverse from its function-arguments out to any streams (in this exact scope)\n            // that it refers to (outer-scope references), because these are dependencies. So this would be an invalid cycle:\n            // x = map(v => x, [1,2,3])\n            compiledContainedDef.externalReferencedStreamIds.forEach((sid) => {\n              if (localStreamIds.has(sid)) {\n                const depLocalExprNode = streamEnvironment.get(sid);\n                if (depLocalExprNode === undefined) {\n                  throw new Error();\n                }\n                traverseFromStreamCreation(depLocalExprNode, context);\n              }\n            });\n\n            compiledDefinition.containedFunctionDefinitions.push({\n              id: argument.id,\n              definition: compiledContainedDef,\n            });\n          }\n          */\n\n          funcArgIds.push(fid);\n        }\n\n        temporaryMarked.delete(node);\n\n        apps.push({\n          sids: node.outs.map(out => out.sid),\n          appId: node.aid,\n          funcId: functionExprId(node.func),\n          sargIds: streamArgIds,\n          fargIds: funcArgIds,\n        });\n        break;\n      }\n\n      default: {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n        throw new Error();\n      }\n    }\n\n    permanentMarked.add(node);\n  }\n\n  for (const node of definition.body.exprs) {\n    if (node.kind === NodeKind.YieldExpression) {\n      traverseStreamExpr(node.expr);\n\n      const exprRetSid = streamExprReturnedId(node.expr);\n      if (!exprRetSid) {\n        throw new Error();\n      }\n      yieldIds[node.idx] = exprRetSid;\n    } else if (isStreamExpressionNode(node)) {\n      traverseStreamExpr(node);\n    } else {\n      // TODO: this could also be a function expression\n      throw new Error();\n    }\n  }\n\n  // TODO: verify that yieldIds doesn't have any \"holes\" and matches signature\n\n  const compiledDefinition: CompiledDefinition = {\n    streamParamIds: definition.sparams.map(({sid}) => sid),\n    funcParamIds: definition.fparams.map(({fid}) => fid),\n    constStreams,\n    apps,\n    localDefs,\n    yieldIds,\n  };\n\n  return [compiledDefinition, externalReferencedStreamIds];\n}\n\nexport function compileGlobalTreeDefinition(definition: TreeFunctionDefinitionNode, globalFunctionEnvironment: Environment<FunctionID, FunctionDefinitionNode>): CompiledDefinition {\n  const streamEnv: CompilationStreamEnvironment = new Environment();\n\n  const compGlobalFuncEnv: CompilationFunctionEnvironment = new Environment();\n  globalFunctionEnvironment.forEach((defNode, fid) => {\n    compGlobalFuncEnv.set(fid, defNode);\n  });\n  const funcEnv: CompilationFunctionEnvironment = new Environment(compGlobalFuncEnv);\n\n  const [compiledDefinition, externalReferencedStreamIds] = compileTreeDefinition(definition, streamEnv, funcEnv);\n\n  if (externalReferencedStreamIds.size > 0) {\n    throw new Error();\n  }\n\n  return compiledDefinition;\n}\n","import { SignatureNode, NodeKind } from './Tree';\nimport { useCallbackReducer } from 'riv-runtime';\nconst { showString, animationTime, mouseDown, changeCount, streamMap, audioDriver, random, mouseClickEvts, redCircle, mousePosition, latestValue } = require('riv-demo-lib');\nconst { h, renderDOMIntoSelector } = require('riv-snabbdom');\n\ninterface Vec2d {\n  x: number;\n  y: number;\n}\n\nfunction vec2dlen(v: Vec2d) {\n  return Math.sqrt(v.x*v.x + v.y*v.y);\n}\n\nfunction vec2sqgrid(count: number, size: number) {\n  const spacing = size / count;\n  const vecs: Array<Vec2d> = [];\n  for (let y = 0; y < count; y++) {\n    for (let x = 0; x < count; x++) {\n      vecs.push({\n        x: x*spacing,\n        y: y*spacing,\n      });\n    }\n  }\n\n  return vecs;\n}\n\nfunction simpleSig(ptypes: Array<string>, yields: boolean): SignatureNode {\n  return {\n    kind: NodeKind.Signature,\n    streamParams: ptypes.map(pn => ({kind: NodeKind.SignatureStreamParameter})),\n    funcParams: [],\n    yields: yields ? [{kind: NodeKind.SignatureYield}] : [],\n    returnedIdx: yields ? 0 : undefined,\n  };\n}\n\nconst nativeFunctions: Array<[string, string, SignatureNode, Function]> = [\n  // simple\n  ['bind', '$o0 = $s0', {\n    kind: NodeKind.Signature,\n    streamParams: [{kind: NodeKind.SignatureStreamParameter}, {kind: NodeKind.SignatureStreamParameter}],\n    funcParams: [],\n    yields: [{kind: NodeKind.SignatureYield}],\n    returnedIdx: undefined,\n  }, (v: any) => v],\n  ['ifte', 'if $s0 | then $s1 | else $s2', simpleSig(['_cond', 'then', 'else'], true), (cond: any, _then: any, _else: any) => (cond ? _then : _else)],\n  ['equals', '$s0 equals $s1', simpleSig(['', ''], true), (a: any, b: any) => Object.is(a, b)],\n\n  // events\n  ['changeCount', '', simpleSig(['_stream'], true), changeCount],\n  ['latestValue', '', simpleSig(['event stream', 'initial value'], true), latestValue],\n\n  // math\n  ['add', '$s0 + $s1', simpleSig(['', ''], true), (a: number, b: number) => a + b],\n  ['sub', '$s0 - $s1', simpleSig(['', ''], true), (a: number, b: number) => a - b],\n  ['mult', '$s0 * $s1', simpleSig(['', ''], true), (a: number, b: number) => a * b],\n  ['div', '$s0 / $s1', simpleSig(['', ''], true), (a: number, b: number) => a / b],\n  ['cos', 'cosine of $s0 radians', simpleSig([''], true), Math.cos],\n  ['sqr', '$s0 squared', simpleSig([''], true), (v: number) => v*v],\n\n  // dom/browser\n  ['showString', 'show value $s0', simpleSig([''], false), showString],\n  ['animationTime', 'animation time', simpleSig([], true), animationTime],\n  ['mouseDown', 'mouse button is down', simpleSig([], true), mouseDown],\n  ['mousePosition', 'mouse position', simpleSig([], true), mousePosition],\n  ['mouseClickEvts', 'mouse clicks', simpleSig([], true), mouseClickEvts],\n  ['redCircle', 'draw red circle at $s0 radius $s1', simpleSig(['position', 'radius'], false), redCircle],\n  ['random', 'random from 0 to 1, | repick on $s0', simpleSig(['repick'], true), random],\n\n  // vec2\n  ['vec2zero', 'zero 2d vector', simpleSig([], true), () => ({x: 0, y: 0})],\n  ['vec2add', 'add 2d vectors $s0 and $s1', simpleSig(['', ''], true), (a: Vec2d, b: Vec2d) => ({x: a.x+b.x, y: a.y+b.y})],\n  ['vec2sub', 'subtract 2d vectors $s0 and $s1', simpleSig(['', ''], true), (a: Vec2d, b: Vec2d) => ({x: a.x-b.x, y: a.y-b.y})],\n  ['vec2len', 'length of 2d vector $s0', simpleSig([''], true), vec2dlen],\n  ['vec2sqgrid', 'square grid of 2d vectors, $s0 per side, $s1 long', simpleSig(['', ''], true), vec2sqgrid],\n\n  // misc\n  ['text2num', 'text $s0 as a number', simpleSig([''], true), (text: string) => Number(text)],\n\n  // snabbdom\n  ['snabbdom.renderDOMIntoSelector', 'render HTML $s0 | into selector $s1', simpleSig(['', ''], false), renderDOMIntoSelector],\n  ['snabbdom.span', '<span> $s0 </span>', simpleSig([''], true), (text: string) => h('span', {}, text)],\n  ['snabbdom.div', '<div> $s0 </div>', simpleSig([''], true), (children: ReadonlyArray<any>) => h('div', {}, children)],\n  ['snabbdom.input', '<input | text→ $o1 | prefill= $s0 | />', {\n    kind: NodeKind.Signature,\n    streamParams: [\n      {\n        kind: NodeKind.SignatureStreamParameter,\n      },\n    ],\n    funcParams: [],\n    yields: [\n      {\n        kind: NodeKind.SignatureYield,\n      },\n      {\n        kind: NodeKind.SignatureYield,\n      },\n    ],\n    returnedIdx: 0,\n  }, (prefill: string): any => {\n    const safePrefill = (typeof prefill === 'string') ? prefill : '';\n    const [text, inputHandler] = useCallbackReducer<string, any>((_, e) => {\n      const newText = e.target.value;\n      return newText;\n    }, safePrefill);\n    return [\n      h('input', {on: {input: inputHandler}, attrs: {value: text}}), // elem\n      text // text\n    ];\n  }],\n\n  // higher-order\n  ['streamMap', 'map over $s0 with $f0', {\n    kind: NodeKind.Signature,\n    streamParams: [\n      {\n        kind: NodeKind.SignatureStreamParameter,\n      },\n    ],\n    funcParams: [\n      {\n        kind: NodeKind.SignatureFunctionParameter,\n        sig: {\n          kind: NodeKind.Signature,\n          streamParams: [\n            {\n              kind: NodeKind.SignatureStreamParameter,\n            }\n          ],\n          funcParams: [],\n          yields: [\n            {\n              kind: NodeKind.SignatureYield,\n            }\n          ],\n          returnedIdx: 0,\n        },\n        templateNames: {\n          streamParams: ['elem'],\n          funcParams: [],\n          yields: ['new elem'],\n        },\n      },\n    ],\n    yields: [\n      {\n        kind: NodeKind.SignatureYield,\n      },\n    ],\n    returnedIdx: 0,\n  }, (arr: Array<any>, f: (v: any) => any) => streamMap(f, arr)],\n\n  ['audioDriver', 'play audio, computing each sample as $f0', {\n    kind: NodeKind.Signature,\n    streamParams: [],\n    funcParams: [\n      {\n        kind: NodeKind.SignatureFunctionParameter,\n        sig: {\n          kind: NodeKind.Signature,\n          streamParams: [\n            {\n              kind: NodeKind.SignatureStreamParameter,\n            },\n            {\n              kind: NodeKind.SignatureStreamParameter,\n            },\n            {\n              kind: NodeKind.SignatureStreamParameter,\n            },\n          ],\n          funcParams: [],\n          yields: [\n            {\n              kind: NodeKind.SignatureYield,\n            }\n          ],\n          returnedIdx: 0,\n        },\n        templateNames: {\n          streamParams: ['audio time', 'next frame', 'sample rate'],\n          funcParams: [],\n          yields: ['sample'],\n        },\n      },\n    ],\n    yields: [],\n    returnedIdx: undefined,\n  }, audioDriver],\n];\n\nexport default nativeFunctions;\n","import genuid from './uid';\nimport { State, ProgramInfo, SelTree } from './State';\nimport { StreamID, FunctionID, generateStreamId, generateFunctionId, NodeKind, Node, TreeFunctionDefinitionNode, FunctionDefinitionNode, isFunctionDefinitionNode, StreamExpressionNode, NativeFunctionDefinitionNode, isStreamExpressionNode, UndefinedLiteralNode, BodyExpressionNode, generateApplicationId, NameNode, StreamParameterNode, ArrayLiteralNode, TreeFunctionBodyNode } from './Tree';\nimport { CompiledDefinition } from './CompiledDefinition';\nimport { compileGlobalTreeDefinition, CompilationError } from './Compiler';\nimport { createNullaryVoidRootExecutionContext, beginBatch, endBatch } from 'riv-runtime';\nimport { createLiveFunction } from './LiveFunction';\nimport Environment from './Environment';\nimport { iterChildren, visitChildren, replaceChild, transformChildren } from './Traversal';\nimport globalNativeFunctions from './globalNatives';\n\n// We don't make a discriminated union of specific actions, but maybe we could\ninterface Action {\n  type: string;\n  char?: string;\n  newNode?: Node;\n  newName?: string;\n  newProgram?: any;\n}\n\n/*\nfunction cutExpressionNode(program: ProgramNode, selectionPath: Path): [ProgramNode, Path] {\n  let cutNode: ExpressionNode | undefined;\n  let holeNode: ExpressionNode | undefined; // the \"hole\" after we remove\n\n  let newProgram = traverseTree(program, {alongPath: selectionPath}, (node, path) => {\n    if (equiv(path, selectionPath)) {\n      // We are at the node to be cut\n      if (!isExpressionNode(node)) {\n        throw new Error();\n      }\n      if (cutNode) {\n        throw new Error(); // sanity check\n      }\n\n      cutNode = node;\n\n      holeNode = {\n        type: 'UndefinedExpression',\n        streamId: genuid(),\n        identifier: null,\n      };\n\n      return [false, holeNode];\n    } else if (isUserFunctionNode(node)) {\n      if (cutNode) {\n        // Move the node to the top level of this function definition\n        const selectionPathAfter = selectionPath.slice(path.length);\n        if ((selectionPathAfter.length < 2) || (selectionPathAfter[0] !== 'expressions')) {\n          throw new Error();\n        }\n        const idx = selectionPathAfter[1];\n        if (typeof(idx) !== 'number') {\n          throw new Error();\n        }\n\n        const newNode = {\n          ...node,\n          expressions: [\n            ...node.expressions.slice(0, idx),\n            cutNode,\n            ...node.expressions.slice(idx),\n          ],\n        };\n        cutNode = undefined;\n\n        return [false, newNode];\n      }\n    }\n\n    return [false, node];\n  });\n\n  if (newProgram.type !== 'Program') {\n    throw new Error(); // sanity check\n  }\n\n  if (!holeNode) {\n    throw new Error();\n  }\n\n  const nodeToPath = computeNodeToPathMap(newProgram);\n  const newSelectionPath = nodeToPath.get(holeNode);\n  if (!newSelectionPath) {\n    throw new Error();\n  }\n\n  return [newProgram, newSelectionPath];\n}\n\nfunction pasteExpressionNode(pasteNode: ExpressionNode, pasteStreamId: StreamID, program: ProgramNode, selectionPath: Path): [ProgramNode, Path] {\n  let newProgram = traverseTree(program, {}, (node, path) => {\n    if (equiv(path, selectionPath)) {\n      // We are at the node to be pasted over\n      if (!isExpressionNode(node)) {\n        throw new Error();\n      }\n\n      return [false, pasteNode];\n    } else if (isUserFunctionNode(node)) {\n      // NOTE: We assume that the node must be at the top level of a function definition.\n      let removeIdx;\n      node.expressions.forEach((expr, idx) => {\n        if (expr.streamId === pasteStreamId) {\n          // This is the node to remove\n          removeIdx = idx;\n        }\n      });\n\n      if (removeIdx !== undefined) {\n        const [newNode, , ] = deleteDefinitionExpression(node, removeIdx);\n        return [false, newNode];\n      }\n    }\n\n    return [false, node];\n  });\n\n  if (newProgram.type !== 'Program') {\n    throw new Error(); // sanity check\n  }\n\n  const nodeToPath = computeNodeToPathMap(newProgram);\n  const newSelectionPath = nodeToPath.get(pasteNode);\n  if (!newSelectionPath) {\n    throw new Error();\n  }\n\n  return [newProgram, newSelectionPath];\n}\n\nfunction firstUndefinedNode(node: Node, after: Path | undefined = undefined): [Node, Path] | undefined {\n  let passed = false; // have we passed the \"after\" path?\n  let result: [Node, Path] | undefined;\n\n  traverseTree(node, {}, (node, path) => {\n    if (after && pathIsPrefix(after, path)) {\n      passed = true;\n    }\n\n    if (node.type === 'UndefinedLiteral') {\n      if (passed || !after) {\n        result = [node, path];\n        return [true, node];\n      }\n    }\n    return [false, node];\n  });\n\n  return result;\n}\n\n*/\n\ninterface ExprStreamDefinition {\n  kind: 'expr';\n  sid: StreamID;\n  name: NameNode;\n\n  expr: StreamExpressionNode;\n}\n\ninterface ParamStreamDefinition {\n  kind: 'param';\n  sid: StreamID;\n  name: NameNode;\n\n  param: StreamParameterNode;\n}\n\nexport type StreamDefinition = ExprStreamDefinition | ParamStreamDefinition;\n\nexport interface StaticEnvironment {\n  streamEnv: Environment<StreamID, StreamDefinition>;\n  functionEnv: Environment<FunctionID, FunctionDefinitionNode>;\n}\n\nexport function initStaticEnv(globalFunctions: ReadonlyArray<FunctionDefinitionNode>): StaticEnvironment {\n  const globalFunctionEnv: Environment<FunctionID, FunctionDefinitionNode> = new Environment();\n  for (const fdef of globalFunctions) {\n    globalFunctionEnv.set(fdef.fid, fdef);\n  }\n\n  return {\n    streamEnv: new Environment(),\n    functionEnv: globalFunctionEnv,\n  };\n}\n\nexport function extendStaticEnv(outer: StaticEnvironment, def: TreeFunctionDefinitionNode): StaticEnvironment {\n  const streamEnv: Environment<StreamID, StreamDefinition> = new Environment(outer.streamEnv);\n  const functionEnv: Environment<FunctionID, FunctionDefinitionNode> = new Environment(outer.functionEnv);\n\n  def.sparams.forEach(sparam => {\n    const {sid, name} = sparam;\n    if (streamEnv.has(sid)) {\n      throw new Error();\n    }\n    streamEnv.set(sid, {\n      kind: 'param',\n      sid,\n      name,\n      param: sparam,\n    });\n  });\n\n  const visit = (node: Node): void => {\n    if (isStreamExpressionNode(node)) {\n      if (node.kind === NodeKind.Application) {\n        node.outs.forEach(out => {\n          if (streamEnv.has(out.sid)) {\n            throw new Error('stream ids must be unique');\n          }\n          if (out.name) {\n            streamEnv.set(out.sid, {\n              kind: 'expr',\n              sid: out.sid,\n              name: out.name,\n              expr: node,\n            });\n          }\n        });\n      }\n    }\n\n    if (isFunctionDefinitionNode(node)) {\n      if (functionEnv.has(node.fid)) {\n        throw new Error('function ids must be unique');\n      }\n      functionEnv.set(node.fid, node);\n    } else {\n      visitChildren(node, visit, undefined);\n    }\n  };\n\n  visitChildren(def.body, visit, undefined);\n\n  return {\n    streamEnv,\n    functionEnv,\n  };\n}\n\nexport function getStaticEnvForSelected(selTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>): StaticEnvironment {\n  let selectedNodeEnv: StaticEnvironment | undefined;\n\n  const visit = (node: Node, env: StaticEnvironment): void => {\n    let newEnv: StaticEnvironment;\n    if (node.kind === NodeKind.TreeFunctionDefinition) {\n      newEnv = extendStaticEnv(env, node);\n    } else {\n      newEnv = env;\n    }\n\n    if (node === selTree.selectedNode) {\n      selectedNodeEnv = newEnv;\n    }\n\n    visitChildren(node, visit, newEnv);\n  };\n\n  visit(selTree.mainDefinition, initStaticEnv(nativeFunctions));\n\n  if (!selectedNodeEnv) {\n    throw new Error();\n  }\n\n  return selectedNodeEnv;\n}\n\nexport function getReferentNameNodeOfSelected(selTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>): NameNode | undefined {\n  const selectedEnv = getStaticEnvForSelected(selTree, nativeFunctions);\n\n  const node = selTree.selectedNode;\n  if (node.kind === NodeKind.StreamReference) {\n    const streamDef = selectedEnv.streamEnv.get(node.ref);\n    if (!streamDef) {\n      throw new Error();\n    }\n\n    switch (streamDef.kind) {\n      case 'expr':\n        return streamDef.name;\n\n      case 'param':\n        return streamDef.name;\n\n      default: {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const exhaustive: never = streamDef; // this will cause a type error if we haven't handled all cases\n      }\n    }\n  }\n}\n\n/**\n * Note that this returns the new _root_ of the whole tree\n */\nfunction replaceNode(node: Node, newNode: Node, parentLookup: Map<Node, Node>): Node {\n  const parent = parentLookup.get(node);\n  if (!parent) {\n    return newNode;\n  }\n  return replaceNode(parent, replaceChild(parent, node, newNode), parentLookup);\n}\n\nfunction deleteNodeSubtree(node: Node, parentLookup: Map<Node, Node>): SelTree | void {\n  const deleteFromArr = <T extends Node>(nodeToRemove: T, arr: ReadonlyArray<T>): [ReadonlyArray<T>, T | undefined] => {\n    const idx = arr.indexOf(nodeToRemove);\n    if (idx < 0) {\n      throw new Error();\n    }\n\n    const newArr = arr.slice(0, idx).concat(arr.slice(idx + 1));\n\n    let newSibSel: T | undefined;\n    if (newArr.length === 0) {\n      newSibSel = undefined;\n    } else if (idx === (arr.length - 1)) {\n      newSibSel = newArr[idx-1];\n    } else {\n      newSibSel = newArr[idx];\n    }\n\n    return [newArr, newSibSel];\n  };\n\n  const parent = parentLookup.get(node);\n\n  if (!parent) {\n    return;\n  }\n\n  if (isStreamExpressionNode(node)) {\n    if ((parent.kind === NodeKind.Application) || (parent.kind === NodeKind.YieldExpression)) {\n      const newNode: UndefinedLiteralNode = {\n        kind: NodeKind.UndefinedLiteral,\n        sid: generateStreamId(),\n      };\n      const newRoot = replaceNode(node, newNode, parentLookup);\n      if (newRoot.kind !== NodeKind.TreeFunctionDefinition) {\n        throw new Error();\n      }\n      return {\n        mainDefinition: newRoot,\n        selectedNode: newNode,\n      };\n    } else if (parent.kind === NodeKind.ArrayLiteral) {\n      const [newElems, newSibSel] = deleteFromArr(node, parent.elems);\n      const newParent: ArrayLiteralNode = {\n        ...parent,\n        elems: newElems,\n      };\n      const newRoot = replaceNode(parent, newParent, parentLookup);\n      if (newRoot.kind !== NodeKind.TreeFunctionDefinition) {\n        throw new Error();\n      }\n      return {\n        mainDefinition: newRoot,\n        selectedNode: newSibSel || newParent,\n      };\n    } else if (parent.kind === NodeKind.TreeFunctionBody) {\n      const [newExprs, newSibSel] = deleteFromArr(node, parent.exprs);\n      const newParent: TreeFunctionBodyNode = {\n        ...parent,\n        exprs: newExprs,\n      };\n      const newRoot = replaceNode(parent, newParent, parentLookup);\n      if (newRoot.kind !== NodeKind.TreeFunctionDefinition) {\n        throw new Error();\n      }\n      return {\n        mainDefinition: newRoot,\n        selectedNode: newSibSel || newParent,\n      };\n    } else {\n      throw new Error();\n    }\n  }\n}\n\nfunction handleInstantEditAction(action: Action, selTree: SelTree, parentLookup: Map<Node, Node>): SelTree | void {\n  switch (action.type) {\n    case 'DELETE_SUBTREE':\n      return deleteNodeSubtree(selTree.selectedNode, parentLookup);\n  }\n}\n\nexport function computeParentLookup(root: Node): Map<Node, Node> {\n  const parent: Map<Node, Node> = new Map();\n\n  const visit = (node: Node): void => {\n    for (const child of iterChildren(node)) {\n      parent.set(child, node);\n    }\n\n    visitChildren(node, visit, undefined);\n  };\n\n  visit(root);\n\n  return parent;\n}\n\nfunction canBeginEditOnNode(node: Node) {\n  return isStreamExpressionNode(node) || (node.kind === NodeKind.Name);\n}\n\nfunction attemptBeginEditSelected(state: State): State {\n  if (canBeginEditOnNode(state.stableSelTree.selectedNode)) {\n    return {\n      ...state,\n      editing: {\n        sessionId: genuid(),\n        initSelTree: state.stableSelTree,\n        curSelTree: state.stableSelTree,\n        compileError: undefined, // we assume\n        isInsert: false,\n        infixMode: false,\n      },\n    };\n  } else {\n    console.log('Can\\'t edit this node');\n    return state;\n  }\n}\n\nfunction arrInsertBeforeAfter<T>(arr: ReadonlyArray<T>, idx: number, before: boolean, elem: T) {\n  const newIdx = before ? idx : idx+1;\n  return [\n    ...arr.slice(0, newIdx),\n    elem,\n    ...arr.slice(newIdx),\n  ];\n}\n\nfunction attemptInsertBeforeAfter(state: State, before: boolean): State {\n  const parentLookup = computeParentLookup(state.stableSelTree.mainDefinition); // TODO: memoize\n\n  let n: Node = state.stableSelTree.selectedNode;\n  while (true) {\n    const parent = parentLookup.get(n);\n    if (!parent) {\n      return state;\n    }\n\n    if (parent.kind === NodeKind.ArrayLiteral) {\n      const idx = parent.elems.indexOf(n as StreamExpressionNode);\n      const newElem: UndefinedLiteralNode = {\n        kind: NodeKind.UndefinedLiteral,\n        sid: generateStreamId(),\n      };\n      const newArrNode = {\n        ...parent,\n        elems: arrInsertBeforeAfter(parent.elems, idx, before, newElem),\n      };\n      const newMain = replaceNode(parent, newArrNode, parentLookup);\n      if (newMain.kind !== NodeKind.TreeFunctionDefinition) {\n        throw new Error();\n      }\n      const initSelTree = {\n        mainDefinition: newMain,\n        selectedNode: newElem,\n      };\n      return {\n        ...state,\n        editing: {\n          sessionId: genuid(),\n          initSelTree,\n          curSelTree: initSelTree,\n          compileError: undefined, // TODO: assumed, not sure if guaranteed safe\n          isInsert: true,\n          infixMode: false,\n        },\n      };\n    } else if (parent.kind === NodeKind.TreeFunctionBody) {\n      const idx = parent.exprs.indexOf(n as BodyExpressionNode);\n      const newElem: UndefinedLiteralNode = {\n        kind: NodeKind.UndefinedLiteral,\n        sid: generateStreamId(),\n      };\n      const newBodyNode = {\n        ...parent,\n        exprs: arrInsertBeforeAfter(parent.exprs, idx, before, newElem),\n      };\n      const newMain = replaceNode(parent, newBodyNode, parentLookup);\n      if (newMain.kind !== NodeKind.TreeFunctionDefinition) {\n        throw new Error();\n      }\n      const initSelTree = {\n        mainDefinition: newMain,\n        selectedNode: newElem,\n      };\n      return {\n        ...state,\n        editing: {\n          sessionId: genuid(),\n          initSelTree,\n          curSelTree: initSelTree,\n          compileError: undefined, // TODO: assumed, not sure if guaranteed safe\n          isInsert: true,\n          infixMode: false,\n        },\n      };\n    } else {\n      n = parent;\n    }\n  }\n}\n\nfunction pushUndo(state: State): State {\n  return {\n    ...state,\n    undoStack: state.undoStack.concat([state.stableSelTree]),\n  };\n}\n\nfunction fixupDanglingRefs(selTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>): SelTree {\n  const globalEnv = initStaticEnv(nativeFunctions);\n\n  const oldNodeToNew: Map<Node, Node> = new Map();\n\n  const transform = (node: Node, env: StaticEnvironment): Node => {\n    let newNode: Node = node;\n    if (node.kind === NodeKind.StreamReference) {\n      const streamDef = env.streamEnv.get(node.ref);\n      if (!streamDef) {\n        newNode = {\n          kind: NodeKind.UndefinedLiteral,\n          sid: generateStreamId(),\n        };\n      }\n    }\n\n    let newEnv: StaticEnvironment;\n    if (node.kind === NodeKind.TreeFunctionDefinition) {\n      newEnv = extendStaticEnv(env, node);\n    } else {\n      newEnv = env;\n    }\n\n    const newNewNode = transformChildren(newNode, transform, newEnv);\n\n    if (newNewNode !== node) {\n      oldNodeToNew.set(node, newNewNode);\n    }\n\n    return newNewNode;\n  };\n\n  const newMain = transform(selTree.mainDefinition, globalEnv);\n  if (newMain.kind !== NodeKind.TreeFunctionDefinition) {\n    throw new Error();\n  }\n\n  const newSelectedNode = oldNodeToNew.get(selTree.selectedNode) || selTree.selectedNode;\n  // TODO: verify that newSelectedNode is in newMain\n\n  // console.log('fixupDanglingRefs', 'tree changed?', newMain !== selTree.mainDefinition, 'selnode changed?', newSelectedNode !== selTree.selectedNode);\n\n  return {\n    mainDefinition: newMain,\n    selectedNode: newSelectedNode,\n  };\n}\n\n// NOTE: May throw a compiler exception\nfunction compileSelTree(selTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>): CompiledDefinition {\n  // NOTE: We could avoid repeating this work, but this is sort of temporary anyways\n  const globalFunctionEnvironment: Environment<FunctionID, FunctionDefinitionNode> = new Environment();\n  for (const nf of nativeFunctions) {\n    globalFunctionEnvironment.set(nf.fid, nf);\n  }\n\n  return compileGlobalTreeDefinition(selTree.mainDefinition, globalFunctionEnvironment);\n}\n\nfunction updateExecution(state: State, newCompiledDefinition: CompiledDefinition): State {\n  if (state.execution) {\n    const { updateCompiledDefinition } = state.execution;\n\n    beginBatch();\n    updateCompiledDefinition(newCompiledDefinition);\n    endBatch();\n\n    return state;\n  } else {\n    // There is no old state, so we need to create the long-lived stuff\n    const [liveStreamFunc, updateCompiledDefinition] = createLiveFunction(newCompiledDefinition, new Environment(), nativeFunctionEnvironment);\n    const context = createNullaryVoidRootExecutionContext(liveStreamFunc);\n\n    context.update(); // first update that generally kicks off further async updates\n\n    return {\n      ...state,\n      execution: {\n        context,\n        compiledDefinition: newCompiledDefinition,\n        updateCompiledDefinition,\n      },\n    };\n  }\n}\n\n// If the given seltree compiles, make it the new stable one and update execution. Otherwise keep current stable one.\n// Also, end any edit.\nfunction attemptCommitEdit(state: State, newSelTree: SelTree): State {\n  const fixedSelTree = fixupDanglingRefs(newSelTree, state.nativeFunctions);\n\n  let compiledDefinition: CompiledDefinition | undefined;\n  try {\n    compiledDefinition = compileSelTree(fixedSelTree, state.nativeFunctions);\n  } catch (e) {\n    if (e instanceof CompilationError) {\n      compiledDefinition = undefined;\n    } else {\n      throw e;\n    }\n  }\n\n  if (compiledDefinition) {\n    return updateExecution({\n      ...state,\n      stableSelTree: fixedSelTree,\n      editing: null,\n    }, compiledDefinition);\n  } else {\n    return {\n      ...state,\n      editing: null,\n    };\n  }\n}\n\nfunction nodeIsHole(node: Node): boolean {\n  return (node.kind === NodeKind.UndefinedLiteral) ||\n   ((node.kind === NodeKind.Name) && !node.text);\n}\n\nfunction findNextHoleUnder(node: Node): Node | undefined {\n  for (const child of iterChildren(node)) {\n    if (nodeIsHole(child)) {\n      return child;\n    } else {\n      const recur = findNextHoleUnder(child);\n      if (recur) {\n        return recur;\n      }\n    }\n  }\n}\n\nfunction attemptChainEdit(state: State, tryInsert: boolean): State {\n  const editNode = (node: Node): State => {\n    const editSelTree = {\n      mainDefinition: state.stableSelTree.mainDefinition,\n      selectedNode: node,\n    };\n    return {\n      ...state,\n      editing: {\n        sessionId: genuid(),\n        initSelTree: editSelTree,\n        curSelTree: editSelTree,\n        compileError: undefined,\n        isInsert: false,\n        infixMode: false,\n      },\n    };\n  };\n\n  if (state.editing) {\n    throw new Error(); // shouldn't be\n  }\n\n  const parentLookup = computeParentLookup(state.stableSelTree.mainDefinition);\n\n  const under = findNextHoleUnder(state.stableSelTree.selectedNode);\n  if (under) {\n    return editNode(under);\n  }\n\n  let n: Node = state.stableSelTree.selectedNode;\n  while (true) {\n    const parent = parentLookup.get(n);\n    if (!parent) {\n      return state; // reached root, do nothing\n    }\n    if ((parent.kind === NodeKind.ArrayLiteral) || (parent.kind === NodeKind.TreeFunctionBody)) {\n      if (tryInsert) {\n        return attemptInsertBeforeAfter(state, false);\n      } else {\n        return state;\n      }\n    } else {\n      const parentsChildren = [...iterChildren(parent)];\n      const nodeIdx = parentsChildren.indexOf(n);\n      if (nodeIdx < 0) {\n        throw new Error();\n      }\n      for (let i = nodeIdx+1; i < parentsChildren.length; i++) {\n        const sib = parentsChildren[i];\n        if (sib.kind === NodeKind.UndefinedLiteral) {\n          return editNode(sib);\n        }\n        const under = findNextHoleUnder(sib);\n        if (under) {\n          return editNode(under);\n        }\n      }\n\n      n = parent;\n    }\n  }\n}\n\nexport function reducer(state: State, action: Action): State {\n  console.log('action', action);\n\n  if (action.type === 'LOAD_PROGRAM') {\n    if (!action.newProgram) {\n      throw new Error();\n    }\n\n    // Terminate currently running main function\n    if (!state.execution) {\n      throw new Error();\n    }\n    state.execution.context.terminate();\n\n    return initialStateFromDefinition(action.newProgram.mainDefinition, action.newProgram.info as ProgramInfo);\n  } else if (action.type === 'SET_PROGRAM_NAME') {\n    return {\n      ...state,\n      programInfo: {\n        ...state.programInfo,\n        name: action.newName!,\n      },\n    };\n  } else if (action.type === 'BEGIN_EDIT') {\n    if (!state.editing) {\n      return attemptBeginEditSelected(state);\n    }\n  } else if (action.type === 'INSERT_BEFORE') {\n    if (!state.editing) {\n      return attemptInsertBeforeAfter(state, true);\n    }\n  } else if (action.type === 'INSERT_AFTER') {\n    if (!state.editing) {\n      return attemptInsertBeforeAfter(state, false);\n    }\n  } else if (action.type === 'TOGGLE_EDIT') {\n    if (state.editing) {\n      const insertAgain = state.editing.isInsert;\n      const stateAfterCommit = attemptCommitEdit({\n        ...pushUndo(state),\n      }, state.editing.curSelTree);\n\n      return attemptChainEdit(stateAfterCommit, insertAgain);\n    } else {\n      return attemptBeginEditSelected(state);\n    }\n  } else if (action.type === 'INFIX_EDIT') {\n    if (state.editing) {\n      return {\n        ...state,\n        editing: {\n          sessionId: genuid(),\n          initSelTree: state.editing.curSelTree,\n          curSelTree: state.editing.curSelTree,\n          compileError: undefined, // we assume?\n          isInsert: false,\n          infixMode: true,\n        },\n      };\n    } else {\n      return {\n        ...state,\n        editing: {\n          sessionId: genuid(),\n          initSelTree: state.stableSelTree,\n          curSelTree: state.stableSelTree,\n          compileError: undefined, // we assume?\n          isInsert: false,\n          infixMode: true,\n        },\n      };\n    }\n  } else if (action.type === 'ABORT_EDIT') {\n    if (state.editing) {\n      return {\n        ...state,\n        editing: null,\n      };\n    }\n  } else if (action.type === 'UPDATE_EDITING_NODE') {\n    if (!state.editing) {\n      throw new Error();\n    }\n    const parentLookup = computeParentLookup(state.editing.initSelTree.mainDefinition); // TODO: memoize\n    const newMain = replaceNode(state.editing.initSelTree.selectedNode, action.newNode!, parentLookup);\n    if (newMain.kind !== NodeKind.TreeFunctionDefinition) {\n      throw new Error();\n    }\n\n    const fixedSelTree = fixupDanglingRefs({mainDefinition: newMain, selectedNode: action.newNode!}, state.nativeFunctions);\n\n    // Check if tentative tree compiles\n    let compileError: string | undefined;\n    try {\n      compileSelTree(fixedSelTree, state.nativeFunctions);\n      compileError = undefined;\n    } catch (e) {\n      if (e instanceof CompilationError) {\n        compileError = 'cyclic reference';\n      } else {\n        throw e;\n      }\n    }\n\n    return {\n      ...state,\n      editing: {\n        ...state.editing,\n        curSelTree: fixedSelTree,\n        compileError,\n      },\n    };\n  } else if (action.type === 'UNDO') {\n    if (state.undoStack.length > 0) {\n      const newSelTree = state.undoStack[state.undoStack.length-1];\n      return attemptCommitEdit({\n        ...state,\n        undoStack: state.undoStack.slice(0, state.undoStack.length-1),\n      }, newSelTree);\n    } else {\n      console.log('nothing to undo');\n      return state;\n    }\n  } else if (action.type === 'SET_SELECTED_NODE') {\n    const newSelectedNode = action.newNode!;\n    if (newSelectedNode !== state.stableSelTree.selectedNode) {\n      return {\n        ...state,\n        stableSelTree: {\n          ...state.stableSelTree,\n          selectedNode: newSelectedNode,\n        },\n        editing: null, // abort any edits\n      };\n    } else {\n      return state;\n    }\n  }\n\n  const parentLookup = computeParentLookup(state.stableSelTree.mainDefinition); // TODO: memoize\n  const handleEditActionResult = handleInstantEditAction(action, state.stableSelTree, parentLookup);\n  if (handleEditActionResult) {\n    const newSelTree = handleEditActionResult;\n\n    if (newSelTree !== state.stableSelTree) {\n      return attemptCommitEdit({\n        ...pushUndo(state),\n      }, newSelTree);\n    } else {\n      return state;\n    }\n  } else if (action.type === 'CUT') {\n    /*\n    const selectedNode = nodeFromPath(newProgram, newSelectionPath);\n    if (isExpressionNode(selectedNode)) {\n      newClipboardStack = newClipboardStack.concat([{\n        mode: 'cut',\n        streamId: selectedNode.streamId,\n      }]);\n      [newProgram, newSelectionPath] = cutExpressionNode(newProgram, newSelectionPath);\n    }\n    */\n  } else if (action.type === 'PASTE') {\n    /*\n    const selectedNode = nodeFromPath(newProgram, newSelectionPath);\n    if ((newClipboardStack.length > 0) && isExpressionNode(selectedNode)) {\n      const topFrame = newClipboardStack[newClipboardStack.length-1];\n      newClipboardStack = newClipboardStack.slice(0, newClipboardStack.length-1);\n      const topNode = state.derivedLookups.streamIdToNode!.get(topFrame.streamId)!;\n      [newProgram, newSelectionPath] = pasteExpressionNode(topNode, topFrame.streamId, newProgram, newSelectionPath);\n    }\n    */\n  }\n\n  console.log('action not handled');\n  return state;\n}\n\nconst nativeFunctionEnvironment: Environment<FunctionID, Function> = new Environment();\nnativeFunctionEnvironment.set('id', (x: any) => x);\nnativeFunctionEnvironment.set('Array_of', Array.of);\nglobalNativeFunctions.forEach(([id, , , jsFunc]) => {\n  nativeFunctionEnvironment.set(id, jsFunc);\n});\n\nfunction initialStateFromDefinition(mainDefinition: TreeFunctionDefinitionNode, programInfo: ProgramInfo): State {\n  const nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode> = globalNativeFunctions.map(([fid, ui, signature, ]) => ({\n    kind: NodeKind.NativeFunctionDefinition,\n    fid,\n    sig: signature,\n    ui: (typeof ui === 'string') ? {kind: 'tmplstr', tmplStr: ui} : {kind: 'none'},\n  }));\n\n  const initSelTree = {mainDefinition, selectedNode: mainDefinition};\n\n  const compiledDefinition = compileSelTree(initSelTree, nativeFunctions);\n\n  return updateExecution({\n    programInfo,\n    stableSelTree: initSelTree,\n    editing: null,\n    nativeFunctions,\n    undoStack: [],\n    clipboardStack: [],\n    execution: null,\n  }, compiledDefinition);\n}\n\nconst mdId = generateStreamId();\nconst INITIAL_MAIN: TreeFunctionDefinitionNode = {\n  kind: NodeKind.TreeFunctionDefinition,\n  fid: generateFunctionId(),\n  sig: {\n    kind: NodeKind.Signature,\n    streamParams: [],\n    funcParams: [],\n    yields: [],\n    returnedIdx: undefined,\n  },\n  ui: {kind: 'none'},\n  sparams: [],\n  fparams: [],\n  body: {\n    kind: NodeKind.TreeFunctionBody,\n    exprs: [\n      {\n        kind: NodeKind.Application,\n        aid: generateApplicationId(),\n        outs: [{sid: mdId, name: {kind: NodeKind.Name, text: 'md'}}],\n        func: {\n          kind: NodeKind.FunctionReference,\n          ref: 'bind',\n        },\n        sargs: [\n          {\n            kind: NodeKind.Application,\n            aid: generateApplicationId(),\n            outs: [{sid: generateStreamId(), name: null}],\n            func: {\n              kind: NodeKind.FunctionReference,\n              ref: 'mouseDown',\n            },\n            sargs: [],\n            fargs: [],\n          },\n        ],\n        fargs: [],\n      },\n      {\n        kind: NodeKind.Application,\n        aid: generateApplicationId(),\n        outs: [],\n        func: {\n          kind: NodeKind.FunctionReference,\n          ref: 'showString',\n        },\n        sargs: [\n          {\n            kind: NodeKind.Application,\n            aid: generateApplicationId(),\n            outs: [{sid: generateStreamId(), name: null}],\n            func: {\n              kind: NodeKind.FunctionReference,\n              ref: 'ifte',\n            },\n            sargs: [\n              {\n                kind: NodeKind.StreamReference,\n                ref: mdId,\n              },\n              {\n                kind: NodeKind.Application,\n                aid: generateApplicationId(),\n                outs: [{sid: generateStreamId(), name: null}],\n                func: {\n                  kind: NodeKind.FunctionReference,\n                  ref: 'cos',\n                },\n                sargs: [\n                  {\n                    kind: NodeKind.NumberLiteral,\n                    sid: generateStreamId(),\n                    val: 10,\n                  },\n                ],\n                fargs: [],\n              },\n              {\n                kind: NodeKind.NumberLiteral,\n                sid: generateStreamId(),\n                val: 20,\n              },\n            ],\n            fargs: [],\n          },\n        ],\n        fargs: [],\n      },\n    ],\n  }\n};\n\nexport const initialState: State = initialStateFromDefinition(INITIAL_MAIN, {id: genuid(), name: 'my program'});\n","import { ExecutionContext, useVar, useInitialize, useRequestUpdate } from 'riv-runtime';\nimport { CompiledDefinition, AppSpec } from './CompiledDefinition';\nimport { StreamID, FunctionID, ApplicationID } from './Tree';\nimport Environment from './Environment';\n\n/**\n * I think that functions in outer environment are not allowed to change identity.\n */\nexport function createLiveFunction(initialDefinition: CompiledDefinition, outerStreamEnv: Environment<StreamID, any>, outerFuncEnv: Environment<FunctionID, Function>): [Function, (newDefinition: CompiledDefinition) => void] {\n  interface Activation {\n    streamEnv: Environment<StreamID, any>; // local streams ids to their latest values\n    funcEnv: Environment<FunctionID, Function>; // local function ids to their JS functions\n    applicationContexts: Map<ApplicationID, ExecutionContext>;\n    updateLocalDef: Map<FunctionID, (newDefinition: CompiledDefinition) => void>;\n    requestUpdate: () => void;\n  }\n\n  const activations: Set<Activation> = new Set();\n  let currentDefinition = initialDefinition;\n\n  function streamFunc() { // NOTE: this can't be an arrow function because we use \"arguments\"\n    /* eslint-disable react-hooks/rules-of-hooks */\n    const requestUpdate = useRequestUpdate();\n\n    const activation = useVar<Activation>((): Activation => {\n      const streamEnv = new Environment(outerStreamEnv);\n      const funcEnv = new Environment(outerFuncEnv);\n      const applicationContexts: Map<ApplicationID, ExecutionContext> = new Map();\n      const updateLocalDef: Map<FunctionID, (newDefinition: CompiledDefinition) => void> = new Map();\n\n      for (const {sid, val} of currentDefinition.constStreams) {\n        streamEnv.set(sid, val);\n      }\n\n      for (const {appId, funcId} of currentDefinition.apps) {\n        const func = funcEnv.get(funcId);\n        if (!func) {\n          throw Error();\n        }\n        const context = new ExecutionContext(func, requestUpdate);\n        applicationContexts.set(appId, context);\n      }\n\n      for (const {fid, def} of currentDefinition.localDefs) {\n        const [sf, updateDef] = createLiveFunction(def, streamEnv, funcEnv);\n        funcEnv.set(fid, sf);\n        updateLocalDef.set(fid, updateDef);\n      }\n\n      return {\n        streamEnv,\n        funcEnv,\n        applicationContexts,\n        updateLocalDef,\n        requestUpdate,\n      };\n    });\n\n    useInitialize(() => {\n      activations.add(activation.current);\n      return () => {\n        activation.current.applicationContexts.forEach((ctx) => {\n          ctx.terminate();\n        });\n        activations.delete(activation.current);\n      };\n    });\n\n    const { streamEnv, funcEnv, applicationContexts } = activation.current;\n\n    const expectedArgCount = currentDefinition.streamParamIds.length + currentDefinition.funcParamIds.length;\n    if (arguments.length !== expectedArgCount) {\n      throw new Error('wrong number of arguments to live function, got ' + arguments.length + ' expected ' + expectedArgCount);\n    }\n\n    const args = arguments;\n    currentDefinition.streamParamIds.forEach((sid, idx) => {\n      streamEnv.set(sid, args[idx]);\n    });\n\n    for (const {sids, appId, funcId, sargIds, fargIds} of currentDefinition.apps) {\n      const appFunc = funcEnv.getExisting(funcId);\n      const sargVals = sargIds.map(sid => streamEnv.getExisting(sid));\n      const fargVals = fargIds.map(fid => funcEnv.getExisting(fid));\n\n      let context = applicationContexts.get(appId);\n      if (!context) {\n        throw new Error();\n      }\n\n      context._setStreamFunc(appFunc);\n\n      let retval: any;\n      let error: boolean;\n      try {\n        retval = context.update(...sargVals, ...fargVals);\n        error = false;\n      } catch (e) {\n        console.log('application error', e);\n        error = true;\n      }\n\n      if (sids.length === 1) {\n        streamEnv.set(sids[0], error ? undefined : retval);\n      } else if (sids.length > 1) {\n        sids.forEach((sid, idx) => {\n          streamEnv.set(sid, error ? undefined : retval[idx]);\n        });\n      }\n    }\n\n    if (currentDefinition.yieldIds.length === 1) {\n      return streamEnv.get(currentDefinition.yieldIds[0]);\n    } else if (currentDefinition.yieldIds.length > 1) {\n      return currentDefinition.yieldIds.map(sid => streamEnv.get(sid));\n    } else {\n      return undefined;\n    }\n  };\n\n  const updateDefinition = (newDefinition: CompiledDefinition): void => {\n    if (JSON.stringify(newDefinition) === JSON.stringify(currentDefinition)) {\n      return;\n    }\n\n    // Track these so we know which streams to delete\n    const oldDefStreams: Set<StreamID> = new Set();\n    const newDefStreams: Set<StreamID> = new Set();\n\n    // PARAM STREAMS\n    for (const sid of currentDefinition.streamParamIds) {\n      oldDefStreams.add(sid);\n    }\n    for (const sid of newDefinition.streamParamIds) {\n      newDefStreams.add(sid);\n    }\n\n    //\n    // CONST STREAMS\n    //\n    for (const {sid} of currentDefinition.constStreams) {\n      oldDefStreams.add(sid);\n    }\n\n    for (const {sid, val} of newDefinition.constStreams) {\n      // It's easier to just always set regardless of change\n      activations.forEach(activation => {\n        activation.streamEnv.set(sid, val);\n      });\n\n      newDefStreams.add(sid);\n    }\n\n    //\n    // APPLICATIONS\n    //\n    const oldAppMap: Map<ApplicationID, AppSpec> = new Map();\n    const newAppMap: Map<ApplicationID, AppSpec> = new Map();\n    for (const app of currentDefinition.apps) {\n      oldAppMap.set(app.appId, app);\n\n      app.sids.forEach(sid => {\n        oldDefStreams.add(sid);\n      });\n    }\n    for (const app of newDefinition.apps) {\n      newAppMap.set(app.appId, app);\n\n      app.sids.forEach(sid => {\n        newDefStreams.add(sid);\n      });\n    }\n\n    for (const {appId} of currentDefinition.apps) {\n      if (!newAppMap.has(appId)) {\n        activations.forEach(activation => {\n          const context = activation.applicationContexts.get(appId);\n          if (!context) {\n            throw new Error();\n          }\n          context.terminate();\n          activation.applicationContexts.delete(appId);\n        });\n      }\n    }\n\n    for (const {appId, funcId} of newDefinition.apps) {\n      if (!oldAppMap.has(appId)) {\n        activations.forEach(activation => {\n          const func = activation.funcEnv.get(funcId);\n          if (!func) {\n            throw Error();\n          }\n          const context = new ExecutionContext(func, activation.requestUpdate);\n          activation.applicationContexts.set(appId, context);\n        });\n      }\n    }\n\n    // DELETE STREAMS THAT NO LONGER EXIST\n    for (const sid of oldDefStreams) {\n      if (!newDefStreams.has(sid)) {\n        activations.forEach(activation => {\n          activation.streamEnv.delete(sid);\n        });\n      }\n    }\n\n    //\n    // LOCAL FUNCTION DEFINITIONS\n    //\n    const oldLocalDefsMap: Map<string, CompiledDefinition> = new Map();\n    const newLocalDefsMap: Map<string, CompiledDefinition> = new Map();\n    for (const {fid, def} of currentDefinition.localDefs) {\n      oldLocalDefsMap.set(fid, def);\n    }\n    for (const {fid, def} of newDefinition.localDefs) {\n      newLocalDefsMap.set(fid, def);\n    }\n\n    for (const {fid} of currentDefinition.localDefs) {\n      if (!newLocalDefsMap.has(fid)) {\n        activations.forEach(activation => {\n          activation.funcEnv.delete(fid);\n          activation.updateLocalDef.delete(fid);\n        });\n      }\n    }\n\n    for (const {fid, def} of newDefinition.localDefs) {\n      if (oldLocalDefsMap.has(fid)) {\n        activations.forEach(activation => {\n          const update = activation.updateLocalDef.get(fid);\n          if (!update) {\n            throw new Error();\n          }\n          update(def);\n        });\n      } else {\n        activations.forEach(activation => {\n          const [sf, updateDef] = createLiveFunction(def, activation.streamEnv, activation.funcEnv);\n          activation.funcEnv.set(fid, sf);\n          activation.updateLocalDef.set(fid, updateDef);\n        });\n      }\n    }\n\n    //\n    // FINISH UP\n    //\n    currentDefinition = newDefinition;\n\n    activations.forEach(activation => {\n      activation.requestUpdate();\n    });\n  };\n\n  return [streamFunc, updateDefinition];\n}\n","import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport genuid from './uid';\nimport { ProgramInfo } from './State';\nimport { TreeFunctionDefinitionNode } from './Tree';\nimport './StoragePanel.css';\n\ninterface Program {\n  info: ProgramInfo;\n  mainDefinition: TreeFunctionDefinitionNode;\n}\n\nexport const StoragePanel: React.FC<{programInfo: ProgramInfo, mainDefinition: TreeFunctionDefinitionNode, onChangeName: (name: string) => void, onLoadProgram: (info: ProgramInfo, mainDefinition: TreeFunctionDefinitionNode) => void}> = ({ programInfo, mainDefinition, onChangeName, onLoadProgram }) => {\n  const ls = window.localStorage;\n  const KEY_PREFIX = 'rivprog:';\n\n  const [selectedProgramId, setSelectedProgramId] = useState();\n  const [savedPrograms, setSavedPrograms] = useState<ReadonlyArray<Program>>([]);\n\n  const refreshSavedPrograms = useCallback((setProgramId: string | undefined = undefined) => {\n    let newProgramId = setProgramId === undefined ? selectedProgramId : setProgramId;\n\n    const sp: Array<Program> = [];\n    for (let i = 0; i < ls.length; i++) {\n      const k = ls.key(i);\n      if (k === null) {\n        throw new Error();\n      }\n      if (k.startsWith(KEY_PREFIX)) {\n        const json = ls.getItem(k);\n        if (json === null) {\n          throw new Error();\n        }\n        const obj = JSON.parse(json);\n        sp.push(obj);\n      }\n    }\n    setSavedPrograms(sp);\n\n    const savedProgramIds = sp.map(prog => prog.info.id);\n    if (!savedProgramIds.includes(newProgramId)) {\n      newProgramId = undefined;\n    }\n\n    setSelectedProgramId(newProgramId);\n  }, [selectedProgramId, ls]);\n\n  useEffect(() => {\n    refreshSavedPrograms();\n  }, [refreshSavedPrograms]);\n\n  const handleChangeName = (e: React.ChangeEvent<HTMLInputElement>) => {\n    if (onChangeName) {\n      onChangeName(e.target.value);\n    }\n  };\n\n  const handleSave = () => {\n    const k = KEY_PREFIX + programInfo.id;\n    const prog = {\n      info: programInfo,\n      mainDefinition,\n    };\n    const json = JSON.stringify(prog);\n    ls.setItem(k, json);\n    refreshSavedPrograms(prog.info.id);\n  };\n\n  const handleClone = () => {\n    onLoadProgram({...programInfo, id: genuid()}, mainDefinition);\n  };\n\n  const selectRef = useRef<HTMLSelectElement>(null);\n  const handleSetProgramId = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    setSelectedProgramId(e.target.value);\n  };\n\n  const handleLoad = () => {\n    if (selectRef.current && selectRef.current.value) {\n      const progId = selectRef.current.value;\n      const hits = savedPrograms.filter(prog => prog.info.id === progId);\n      if (hits.length !== 1) {\n        throw new Error();\n      }\n      onLoadProgram(hits[0].info, hits[0].mainDefinition);\n    }\n  };\n\n  const handleDelete = () => {\n    if (selectRef.current && selectRef.current.value) {\n      const k = KEY_PREFIX + selectRef.current.value;\n      ls.removeItem(k);\n      refreshSavedPrograms();\n    }\n  };\n\n  return (\n    <div className=\"StoragePanel\">\n      <h2>Storage</h2>\n      <div>\n        <span>Current Program:</span>{' '}\n        <label>UID: <span>{programInfo.id}</span></label>{' '}\n        <label>Name: <input value={programInfo.name} onChange={handleChangeName} /></label>{' '}\n        <button onClick={handleSave}>Save</button>{' '}\n        <button onClick={handleClone}>Clone</button>{' '}\n        <button disabled>Import</button>{' '}\n        <button disabled>Export</button>{' '}\n      </div>\n      <div>\n        <span>Saved Programs:</span>{' '}\n        <select ref={selectRef} value={selectedProgramId} onChange={handleSetProgramId}>{savedPrograms.map((prog) => (\n          <option key={prog.info.id} value={prog.info.id}>{prog.info.name} &lt;{prog.info.id}&gt;</option>\n        ))}\n        </select>{' '}\n        <button onClick={handleLoad} disabled={savedPrograms.length === 0}>Load</button>{' '}\n        <button onClick={handleDelete} disabled={savedPrograms.length === 0}>Delete</button>{' '}\n      </div>\n    </div>\n  )\n}\n","interface Wildcard {\n  kind: 'wildcard';\n  key: string;\n}\n\ninterface LineBreak {\n  kind: 'linebreak';\n}\n\ninterface Text {\n  kind: 'text';\n  text: string;\n}\n\ntype TemplateSegment = Wildcard | LineBreak | Text;\n\ntype Template = ReadonlyArray<TemplateSegment>;\n\nexport function parseTemplateString(s: string): Template {\n  const splits = s.split(/(\\$[a-z0-9]+|\\|)/).map(s => s.trim()).filter(s => s);\n  const result: Array<TemplateSegment> = [];\n\n  for (const split of splits) {\n    if (split.startsWith('$')) {\n      result.push({\n        kind: 'wildcard',\n        key: split.substr(1),\n      });\n    } else if (split.startsWith('|')) {\n      result.push({\n        kind: 'linebreak',\n      });\n    } else {\n      result.push({\n        kind: 'text',\n        text: split,\n      });\n    }\n  }\n\n  return result;\n}\n\nexport function templateToPlainText(template: Template): string {\n  const resultPieces: Array<string> = [];\n\n  for (const piece of template) {\n    if (piece.kind === 'text') {\n      resultPieces.push(piece.text);\n    }\n  }\n\n  return resultPieces.join(' ');\n}\n","import React, { useState, useRef, useLayoutEffect } from 'react';\nimport { Node, FunctionDefinitionNode, TreeFunctionDefinitionNode, StreamExpressionNode, BodyExpressionNode, NodeKind, isStreamExpressionNode, isFunctionExpressionNode, FunctionExpressionNode, isFunctionDefinitionNode, StreamReferenceNode, NameNode, ApplicationNode, ArrayLiteralNode } from './Tree';\nimport './TreeView.css';\nimport { StaticEnvironment, extendStaticEnv } from './EditReducer';\nimport { parseTemplateString } from './SyntaxTemplate';\nimport quotesIcon from './icons/quotes.svg';\nimport booleanIcon from './icons/boolean.svg';\n\nconst BOUND_NAME_BOX_COLOR = '#d1e6ff';\nconst STREAM_REFERENCE_BOX_COLOR = '#a1cdff';\n\ninterface MarkedNodes {\n  selected: Node;\n  referentName: Node | undefined;\n}\n\nexport interface TreeViewContext {\n  markedNodes: MarkedNodes;\n  staticEnv: StaticEnvironment;\n  setSelectedNode: (node: Node) => void;\n  focusSelected: boolean;\n};\n\ninterface UseSelectableResult {\n  classes: ReadonlyArray<string>;\n  handlers: {\n    onClick: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void,\n    onMouseOver: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void,\n    onMouseOut: (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => void,\n    tabIndex: number,\n  };\n}\n\nfunction useSelectable(node: Node, ref: React.RefObject<HTMLDivElement>, ctx: TreeViewContext): UseSelectableResult {\n  const [isHovered, setIsHovered] = useState(false);\n\n  const handleClick = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    if ((e.target as Element).tagName !== 'INPUT') {\n      e.stopPropagation();\n      ctx.setSelectedNode(node);\n    }\n  };\n\n  const handleMouseOver = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    setIsHovered(true);\n    e.stopPropagation();\n  };\n\n  const handleMouseOut = (e: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n    setIsHovered(false);\n  };\n\n  const classes: Array<string> = [];\n\n  const isSelected = (ctx.markedNodes.selected === node);\n  const isReferent = (ctx.markedNodes.referentName === node);\n  if (isSelected) {\n    classes.push('TreeView-selected');\n  }\n  if (isReferent) {\n    classes.push('TreeView-referent');\n  }\n  if (isHovered) {\n    classes.push('TreeView-hovered');\n  }\n  // TODO: handle clipboard-top, clipboard-rest?\n\n  useLayoutEffect(() => {\n    if (ctx.focusSelected && isSelected && ref.current) {\n      ref.current.focus();\n    }\n  });\n\n  return {\n    classes,\n    handlers: {\n      onClick: handleClick,\n      onMouseOver: handleMouseOver,\n      onMouseOut: handleMouseOut,\n      tabIndex: 0,\n    }\n  };\n}\n\n\ninterface SizedReactNode {\n  singleLineWidth: number | undefined; // if undefined, that means it's multi-line. width only matters if single-line\n  reactNode: React.ReactNode;\n}\n\nconst SimpleNodeView: React.FC<{treeNode: Node, content: string, icon?: [string, string], bgColor: string, ctx: TreeViewContext}> = ({treeNode, content, icon, bgColor, ctx}) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const {classes: selectionClasses, handlers: selectionHandlers} = useSelectable(treeNode, ref, ctx);\n  return (\n  <div ref={ref} className={selectionClasses.concat(['TreeView-node', 'TreeView-simple-node']).join(' ')} {...selectionHandlers} style={{background: bgColor}}>{icon && <img className=\"TreeView-simple-node-icon\" src={icon[0]} alt={icon[1]} /> }{content}</div>\n  );\n};\n\nconst sizedSimpleNodeView = ({treeNode, content, icon, bgColor, ctx}: {treeNode: Node, content: string, icon?: [string, string], bgColor: string, ctx: TreeViewContext}): SizedReactNode => {\n  return {\n    singleLineWidth: content.length,\n    reactNode: <SimpleNodeView treeNode={treeNode} content={content} icon={icon} bgColor={bgColor} ctx={ctx} />,\n  };\n};\n\nconst objKeyWeakMap: WeakMap<object, number> = new WeakMap();\nlet nextKey = 0;\nfunction objKey(obj: object): number {\n  const key = objKeyWeakMap.get(obj);\n  if (key) {\n    return key;\n  } else {\n    const newKey = nextKey;\n    nextKey++;\n    objKeyWeakMap.set(obj, newKey);\n    return newKey;\n  }\n}\n\ninterface TreeAndSizedNodes {\n  sizedReactNode: SizedReactNode;\n  treeNode?: Node; // we just use its identity for selection. may be undefined if not selectable\n}\n\ninterface RowLayoutRow {\n  indent: boolean;\n  items: ReadonlyArray<string | TreeAndSizedNodes>;\n}\n\ntype RowLayout = ReadonlyArray<RowLayoutRow>;\n\nconst RowView: React.FC<{node: Node, layout: RowLayout, groupingLines: boolean, ctx: TreeViewContext}> = ({node, layout, groupingLines, ctx}) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const {classes: selectionClasses, handlers: selectionHandlers} = useSelectable(node, ref, ctx);\n\n  interface SelectionRecord {\n    ref: React.RefObject<HTMLElement>,\n    treeNode: Node,\n  }\n\n  const selectionRows: Array<ReadonlyArray<SelectionRecord>> = [];\n\n  const onKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n    if (e.getModifierState('Alt') ||\n      e.getModifierState('Control') ||\n      e.getModifierState('Meta') ||\n      e.getModifierState('Shift')) {\n      return;\n    }\n    if ((e.key === 'ArrowRight') && (ref.current === e.target)) {\n      if (selectionRows.length > 0) {\n        e.stopPropagation();\n        ctx.setSelectedNode(selectionRows[0][0].treeNode);\n      }\n    } else if ((e.key === 'ArrowLeft') || (e.key === 'ArrowRight') || (e.key === 'ArrowUp') || (e.key === 'ArrowDown')) {\n      let located = false;\n      selectionRows.forEach((row, rowIdx) => {\n        row.forEach((item, itemIdx) => {\n          if (item.ref.current && item.ref.current.contains(e.target as HTMLElement)) {\n            // The event came from this item, with itemIdx within rowIdx\n\n            // Sanity check: there should be only one matching child\n            if (located) {\n              throw new Error();\n            }\n            located = true;\n\n            if (e.key === 'ArrowLeft') {\n              e.stopPropagation();\n              if (itemIdx === 0) {\n                ctx.setSelectedNode(node);\n              } else {\n                const newItemIdx = itemIdx - 1;\n                ctx.setSelectedNode(selectionRows[rowIdx][newItemIdx].treeNode);\n              }\n            } else if (e.key === 'ArrowRight') {\n              if (itemIdx < (row.length - 1)) {\n                e.stopPropagation();\n                const newItemIdx = itemIdx + 1;\n                ctx.setSelectedNode(selectionRows[rowIdx][newItemIdx].treeNode);\n              }\n            } else if ((e.key === 'ArrowUp') && (rowIdx === 0)) {\n              e.stopPropagation();\n              ctx.setSelectedNode(node);\n            } else if ((e.key === 'ArrowDown') && (rowIdx === (selectionRows.length - 1))) {\n              // Ignore, maybe ancestor will handle\n            } else if ((e.key === 'ArrowUp') || (e.key === 'ArrowDown')) {\n              const newRowIdx = rowIdx + ((e.key === 'ArrowDown') ? 1 : -1);\n              e.stopPropagation();\n              ctx.setSelectedNode(selectionRows[newRowIdx][0].treeNode);\n            }\n          }\n        });\n      });\n    }\n  };\n\n  return (\n    <div ref={ref} className={selectionClasses.concat(['TreeView-row-view TreeView-node']).join(' ')} {...selectionHandlers} onKeyDown={onKeyDown}>\n      {layout.map((row, rowIdx) => {\n        const selectionRow: Array<SelectionRecord> = [];\n        const itemElems: Array<React.ReactNode> = [];\n\n        row.items.forEach((item, itemIdx) => {\n          if (typeof item === 'string') {\n            const key = itemIdx;\n            itemElems.push(\n              <div className=\"TreeView-row-view-plain-text\" key={key}>{item}</div>\n            );\n          } else {\n            const ref: React.RefObject<HTMLDivElement> = React.createRef();\n\n            if (item.treeNode) {\n              selectionRow.push({\n                ref,\n                treeNode: item.treeNode,\n              });\n            }\n\n            const key = item.treeNode ? objKey(item.treeNode) : itemIdx;\n\n            itemElems.push(\n              <div ref={ref} key={key}>{item.sizedReactNode.reactNode}</div>\n            );\n          }\n        });\n\n        if (selectionRow.length > 0) {\n          selectionRows.push(selectionRow);\n        }\n\n        const classes = ['TreeView-row-view-row'];\n        if (row.indent) {\n          if (groupingLines && (rowIdx < (layout.length-1))) {\n            classes.push('TreeView-row-view-row-indented-with-line');\n          } else {\n            classes.push('TreeView-row-view-row-indented-without-line');\n          }\n        }\n\n        return (\n          <div key={rowIdx} className={classes.join(' ')}>{itemElems}</div>\n        );\n      })}\n    </div>\n  );\n}\n\nconst sizedRowView = ({node, layout, groupingLines, ctx}: {node: Node, layout: RowLayout, groupingLines: boolean, ctx: TreeViewContext}): SizedReactNode => {\n  // Determine size\n  let singleLineWidth: number | undefined = undefined;\n  if (layout.length === 1) {\n    if (layout[0].indent) {\n      throw new Error(); // I don't think this makes sense to be indented with one row?\n    }\n\n    singleLineWidth = 0;\n    for (const item of layout[0].items) {\n      if (typeof item === 'string') {\n        if (singleLineWidth !== undefined) {\n          singleLineWidth += item.length;\n        }\n      } else {\n        if (item.sizedReactNode.singleLineWidth === undefined) {\n          singleLineWidth = undefined;\n        } else {\n          if (singleLineWidth !== undefined) {\n            singleLineWidth += item.sizedReactNode.singleLineWidth;\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    singleLineWidth,\n    reactNode: <RowView node={node} layout={layout} groupingLines={groupingLines} ctx={ctx} />\n  };\n}\n\nconst sizedTemplateView = ({node, template, nodeMap, groupingLines, ctx}: {node: Node, template: string, nodeMap: Map<string, TreeAndSizedNodes>, groupingLines: boolean, ctx: TreeViewContext}): SizedReactNode => {\n  const MAX_WIDTH = 30;\n\n  const createLayout = (trySingleLine: boolean): [RowLayout, number | undefined] => {\n    const layout: Array<RowLayoutRow> = [];\n    let accumItems: Array<string | TreeAndSizedNodes> = [];\n    let accumLength: number = 0;\n    let totalWidth: number | undefined = 0; // this gets set to undefined if we determine that result is not single-line\n\n    const emitAccumItems = () => {\n      if (accumItems.length > 0) {\n        layout.push({\n          indent: false,\n          items: accumItems,\n        });\n      }\n      accumItems = [];\n      accumLength = 0;\n    };\n\n    for (const piece of parseTemplateString(template)) {\n      if (piece.kind === 'wildcard') {\n        const nodes = nodeMap.get(piece.key);\n        if (!nodes) {\n          throw new Error();\n        }\n\n        if ((nodes.sizedReactNode.singleLineWidth !== undefined) && ((accumLength + nodes.sizedReactNode.singleLineWidth) <= MAX_WIDTH)) {\n          accumItems.push(nodes);\n          accumLength += nodes.sizedReactNode.singleLineWidth;\n          if (totalWidth !== undefined) {\n            totalWidth += nodes.sizedReactNode.singleLineWidth;\n          }\n        } else {\n          emitAccumItems();\n          layout.push({\n            indent: true,\n            items: [nodes],\n          });\n          totalWidth = undefined;\n        }\n      } else if (piece.kind === 'linebreak') {\n        if (!trySingleLine) {\n          emitAccumItems();\n          totalWidth = undefined;\n        }\n      } else if (piece.kind === 'text') {\n        const ellipsis = (accumItems.length === 0) && (layout.length > 0);\n        accumItems.push((ellipsis ? '…' : '') + piece.text);\n        accumLength += piece.text.length;\n        if (totalWidth !== undefined) {\n          totalWidth += piece.text.length;\n        }\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const exhaustive: never = piece; // this will cause a type error if we haven't handled all cases\n        throw new Error();\n      }\n    }\n    emitAccumItems();\n\n    return [layout, totalWidth];\n  }\n\n  const [singleLayout, singleLineWidth] = createLayout(true);\n  if ((singleLineWidth !== undefined) && (singleLineWidth <= MAX_WIDTH)) {\n    return {\n      singleLineWidth,\n      reactNode: <RowView node={node} layout={singleLayout} groupingLines={groupingLines} ctx={ctx} />,\n    };\n  } else {\n    const [multiLayout, ] = createLayout(false);\n    return {\n      singleLineWidth: undefined,\n      reactNode: <RowView node={node} layout={multiLayout} groupingLines={groupingLines} ctx={ctx} />,\n    };\n  }\n}\n\nconst sizedNameView = ({node, ctx}: {node: NameNode, ctx: TreeViewContext}): SizedReactNode => {\n  return sizedSimpleNodeView({treeNode: node, content: node.text || '\\xa0\\xa0\\xa0\\xa0', bgColor: BOUND_NAME_BOX_COLOR, ctx});\n};\n\nconst sizedStreamReferenceView = ({node, ctx}: {node: StreamReferenceNode, ctx: TreeViewContext}): SizedReactNode => {\n  const streamDef = ctx.staticEnv.streamEnv.get(node.ref);\n  if (!streamDef) {\n    throw new Error();\n  }\n\n  return sizedSimpleNodeView({treeNode: node, content: streamDef.name.text || '\\xa0\\xa0\\xa0\\xa0', bgColor: STREAM_REFERENCE_BOX_COLOR, ctx});\n};\n\nconst sizedArrayLiteralView = ({node, ctx}: {node: ArrayLiteralNode, ctx: TreeViewContext}): SizedReactNode => {\n  const layout: Array<RowLayoutRow> = [];\n\n  layout.push({\n    indent: false,\n    items: ['['],\n  });\n\n  for (const elem of node.elems) {\n    layout.push({\n      indent: true,\n      items: [\n        {\n          treeNode: elem,\n          sizedReactNode: sizedBodyExpressionView({node: elem, ctx}),\n        },\n      ],\n    });\n  }\n\n  layout.push({\n    indent: false,\n    items: [']'],\n  });\n\n  return sizedRowView({node, layout, groupingLines: true, ctx});\n}\n\nconst sizedApplicationView = ({node, ctx}: {node: ApplicationNode, ctx: TreeViewContext}): SizedReactNode => {\n  if (node.func.kind !== NodeKind.FunctionReference) {\n    throw new Error('unimplemented');\n  }\n\n  const functionNode = ctx.staticEnv.functionEnv.get(node.func.ref);\n  if (!functionNode) {\n    throw new Error();\n  }\n\n  const nodeMap: Map<string, TreeAndSizedNodes> = new Map();\n\n  node.sargs.forEach((sarg, idx) => {\n    nodeMap.set('s' + idx, {\n      treeNode: sarg,\n      sizedReactNode: sizedStreamExpressionView({node: sarg, ctx}),\n    });\n  });\n  node.fargs.forEach((farg, idx) => {\n    nodeMap.set('f' + idx, {\n      treeNode: farg,\n      sizedReactNode: sizedFunctionExpressionView({node: farg, ctx}),\n    });\n  });\n  node.outs.forEach((out, idx) => {\n    if (out.name) {\n      nodeMap.set('o' + idx, {\n        treeNode: out.name,\n        sizedReactNode: sizedNameView({node: out.name, ctx}),\n      });\n    }\n  });\n\n  switch (functionNode.ui.kind) {\n    case 'none':\n      throw new Error();\n\n    case 'tmplstr':\n      return sizedTemplateView({\n        node,\n        template: functionNode.ui.tmplStr || ('empty template string for ' + functionNode.fid),\n        nodeMap,\n        groupingLines: true,\n        ctx,\n      });\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = functionNode.ui; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n};\n\nconst sizedStreamExpressionView = ({node, ctx}: {node: StreamExpressionNode, ctx: TreeViewContext}): SizedReactNode => {\n  switch (node.kind) {\n    case NodeKind.UndefinedLiteral:\n      return sizedSimpleNodeView({treeNode: node, content: '\\xa0\\xa0\\xa0\\xa0', bgColor: '#faa', ctx});\n\n    case NodeKind.NumberLiteral:\n      return sizedSimpleNodeView({treeNode: node, content: node.val.toString(), bgColor: '#cce8cc', ctx});\n\n    case NodeKind.TextLiteral:\n      return sizedSimpleNodeView({treeNode: node, content: node.val, icon: [quotesIcon, 'text'], bgColor: '#fff3b9', ctx});\n\n    case NodeKind.BooleanLiteral:\n      return sizedSimpleNodeView({treeNode: node, content: node.val.toString(), icon: [booleanIcon, 'boolean'], bgColor: '#f0d4ff', ctx});\n\n    case NodeKind.ArrayLiteral:\n      return sizedArrayLiteralView({node, ctx});\n\n    case NodeKind.StreamReference:\n      return sizedStreamReferenceView({node, ctx});\n\n    case NodeKind.Application:\n      return sizedApplicationView({node, ctx});\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n}\n\nexport const StreamExpressionView: React.FC<{node: StreamExpressionNode, ctx: TreeViewContext}> = ({ node, ctx }) => {\n  const {reactNode} = sizedStreamExpressionView({node, ctx});\n  return <>{reactNode}</> // empty angle brackets are to make types work\n}\n\nconst sizedBodyExpressionView = ({node, ctx}: {node: BodyExpressionNode, ctx: TreeViewContext}): SizedReactNode => {\n  if (isStreamExpressionNode(node)) {\n    return sizedStreamExpressionView({node, ctx});\n  } else if (isFunctionExpressionNode(node)) {\n    throw new Error('unimplemented');\n  } else if (node.kind === NodeKind.YieldExpression) {\n    return sizedTemplateView({\n      node,\n      template: '$name ← $expr',\n      nodeMap: new Map([\n        ['name', {\n          treeNode: node.name,\n          sizedReactNode: sizedNameView({node: node.name, ctx}),\n        }],\n        ['expr', {\n          treeNode: node.expr,\n          sizedReactNode: sizedStreamExpressionView({node: node.expr, ctx}),\n        }],\n      ]),\n      groupingLines: true,\n      ctx,\n    });\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n    throw new Error('unreachable');\n  }\n};\n\nconst sizedTreeFunctionDefinitionView = ({node, ctx}: {node: TreeFunctionDefinitionNode, ctx: TreeViewContext}): SizedReactNode => {\n  const layout: Array<RowLayoutRow> = [];\n\n  const newCtx: TreeViewContext = {\n    ...ctx,\n    staticEnv: extendStaticEnv(ctx.staticEnv, node),\n  };\n\n  if ((node.sparams.length > 0) || (node.fparams.length > 0)) {\n    // Some parameters\n    layout.push({indent: false, items: [\n      'given',\n    ]});\n\n    node.sparams.forEach(sparam => {\n      layout.push({\n        indent: true,\n        items: [{\n          treeNode: sparam.name,\n          sizedReactNode: sizedNameView({node: sparam.name, ctx: newCtx}),\n        }],\n      });\n    });\n\n    node.fparams.forEach(fparam => {\n      layout.push({\n        indent: true,\n        items: [{\n          treeNode: fparam.name,\n          sizedReactNode: sizedNameView({node: fparam.name, ctx: newCtx}),\n        }],\n      });\n    });\n  }\n\n  for (const bodyExpr of node.body.exprs) {\n    layout.push({\n      indent: false,\n      items: [\n        {\n          treeNode: bodyExpr,\n          sizedReactNode: sizedBodyExpressionView({node: bodyExpr, ctx: newCtx}),\n        },\n      ],\n    });\n  }\n\n  const {singleLineWidth, reactNode} = sizedRowView({node, layout, groupingLines: false, ctx: newCtx});\n  return {\n    singleLineWidth,\n    reactNode: (\n      <div className=\"TreeView-tree-function-definition-inner\">{reactNode}</div>\n    ),\n  };\n};\n\nconst sizedFunctionDefinitionView = ({node, ctx}: {node: FunctionDefinitionNode, ctx: TreeViewContext}): SizedReactNode => {\n  if (node.kind === NodeKind.TreeFunctionDefinition) {\n    return sizedTreeFunctionDefinitionView({node, ctx});\n  } else if (node.kind === NodeKind.NativeFunctionDefinition) {\n    throw new Error('unimplemented');\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n    throw new Error('unreachable');\n  }\n};\n\nconst sizedFunctionExpressionView = ({node, ctx}: {node: FunctionExpressionNode, ctx: TreeViewContext}): SizedReactNode => {\n  if (node.kind === NodeKind.FunctionReference) {\n    throw new Error('unimplemented');\n  } else if (isFunctionDefinitionNode(node)) {\n    return sizedFunctionDefinitionView({node, ctx});\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const exhaustive: never = node; // this will cause a type error if we haven't handled all cases\n    throw new Error('unreachable');\n  }\n};\n\nexport const TreeFunctionDefinitionView: React.FC<{node: TreeFunctionDefinitionNode, ctx: TreeViewContext}> = ({ node, ctx }) => {\n  const {reactNode} = sizedTreeFunctionDefinitionView({node, ctx});\n  return <>{reactNode}</> // empty angle brackets are to make types work\n}\n","import { templateToPlainText, parseTemplateString } from './SyntaxTemplate';\n\ninterface NoFunctionUI {\n  kind: 'none';\n}\n\ninterface TemplateStringFunctionUI {\n  kind: 'tmplstr';\n  tmplStr: string;\n}\n\nexport type FunctionUI = NoFunctionUI | TemplateStringFunctionUI;\n\nexport function functionUIAsPlainText(ui: FunctionUI): string {\n  switch (ui.kind) {\n    case 'none':\n      return '<no ui>';\n\n    case 'tmplstr':\n      return templateToPlainText(parseTemplateString(ui.tmplStr));\n\n    default: {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const exhaustive: never = ui; // this will cause a type error if we haven't handled all cases\n      throw new Error();\n    }\n  }\n}\n","import React, { useState, useEffect, useRef, useMemo } from 'react';\nimport './Chooser.css';\nimport { generateStreamId, FunctionDefinitionNode, NodeKind, isStreamExpressionNode, ApplicationNode, SignatureFunctionParameterNode, generateFunctionId, StreamExpressionNode, generateApplicationId, ApplicationOut, FunctionExpressionNode, NativeFunctionDefinitionNode, UndefinedLiteralNode, ArrayLiteralNode, NameNode, StreamID } from './Tree';\nimport Fuse from 'fuse.js';\nimport { computeParentLookup } from './EditReducer';\nimport { SelTree } from './State';\nimport { StreamExpressionView, TreeViewContext } from './TreeView';\nimport { functionUIAsPlainText } from './FunctionUI';\n\ninterface Choice {\n  node: StreamExpressionNode;\n}\n\nconst FLOAT_REGEX = /^[-+]?(?:\\d*\\.?\\d+|\\d+\\.?\\d*)(?:[eE][-+]?\\d+)?$/;\n\nconst ChoiceView: React.FC<{choice: Choice, treeViewCtx: TreeViewContext}> = ({ choice, treeViewCtx }) => {\n  return (\n    <StreamExpressionView node={choice.node} ctx={treeViewCtx} />\n  );\n}\n\ninterface DropdownState {\n  choices: ReadonlyArray<Choice>;\n  index: number;\n}\n\nconst ExpressionChooser: React.FC<{initSelTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>, dispatch: (action: any) => void, compileError: string | undefined, infixMode: boolean, treeViewCtx: TreeViewContext}> = ({ initSelTree, nativeFunctions, dispatch, compileError, infixMode, treeViewCtx }) => {\n  const parentLookup = useMemo(() => computeParentLookup(initSelTree.mainDefinition), [initSelTree.mainDefinition]);\n  const parent = parentLookup.get(initSelTree.selectedNode);\n  if (!parent) {\n    throw new Error();\n  }\n  const atRoot = parent.kind === NodeKind.TreeFunctionBody;\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  useEffect(() => {\n    inputRef.current && inputRef.current.select();\n  }, []);\n\n  const selectedListElem = useRef<HTMLLIElement>(null);\n  useEffect(() => {\n    if (selectedListElem.current) {\n      selectedListElem.current.scrollIntoView({block: 'nearest', inline: 'nearest'});\n    }\n  });\n\n  if (!isStreamExpressionNode(initSelTree.selectedNode)) {\n    throw new Error();\n  }\n\n  const initNode = initSelTree.selectedNode;\n\n  const [text, setText] = useState(() => {\n    if (infixMode) {\n      return '';\n    } else {\n      // Initialize text based on node\n      switch (initNode.kind) {\n        case NodeKind.UndefinedLiteral:\n          return '';\n\n        case NodeKind.NumberLiteral:\n          return initNode.val.toString();\n\n        case NodeKind.TextLiteral:\n          return initNode.val;\n\n        case NodeKind.BooleanLiteral:\n          return initNode.val.toString();\n\n        case NodeKind.ArrayLiteral:\n        case NodeKind.StreamReference:\n        case NodeKind.Application:\n          return ''; // Don't prefill with text\n\n        default: {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const exhaustive: never = initNode; // this will cause a type error if we haven't handled all cases\n          throw new Error();\n        }\n      }\n    }\n  });\n\n  const generateChoices = (text: string): ReadonlyArray<Choice> => {\n    const choices: Array<Choice> = [];\n\n    // If there is no text, put this first as a sort of default\n    if (text === '') {\n      choices.push({\n        node: {\n          kind: NodeKind.UndefinedLiteral,\n          sid: generateStreamId(),\n        },\n      });\n    }\n\n    if (FLOAT_REGEX.test(text)) {\n      choices.push({\n        node:  {\n          kind: NodeKind.NumberLiteral,\n          sid: generateStreamId(),\n          val: Number(text),\n        },\n      });\n    }\n\n    // SEARCH OVER STREAMS\n    const streamEnv = treeViewCtx.staticEnv.streamEnv;\n\n    interface EnvStreamSearchItem {\n      name: string;\n      sid: StreamID;\n    }\n    const envStreamSearchItems: Array<EnvStreamSearchItem> = [];\n    streamEnv.forEach((sdef, ) => {\n      const selfRef = (sdef.kind === 'expr') && (sdef.expr === initNode);\n      if (!selfRef) {\n        envStreamSearchItems.push({\n          name: sdef.name.text || ' ',\n          sid: sdef.sid,\n        });\n      }\n    });\n\n    const envStreamSearchOptions: Fuse.FuseOptions<EnvStreamSearchItem> = {\n      keys: ['name'],\n    };\n    const envStreamSearchResults = (new Fuse(envStreamSearchItems, envStreamSearchOptions)).search<EnvStreamSearchItem, false, false>(text);\n\n    for (const result of envStreamSearchResults) {\n      choices.push({\n        node: {\n          kind: NodeKind.StreamReference,\n          ref: result.sid,\n        },\n      });\n    }\n\n    // SEARCH OVER FUNCTIONS\n    const functionEnv = treeViewCtx.staticEnv.functionEnv;\n\n    interface EnvFuncSearchItem {\n      name: string;\n      def: FunctionDefinitionNode;\n    }\n    const envFuncSearchItems: Array<EnvFuncSearchItem> = [];\n\n    functionEnv.forEach(defNode => {\n      if (defNode.ui) {\n        const defAsText = functionUIAsPlainText(defNode.ui);\n        if (atRoot) {\n          envFuncSearchItems.push({\n            name: defAsText,\n            def: defNode,\n          });\n        } else {\n          if (defNode.sig.returnedIdx !== undefined) {\n            envFuncSearchItems.push({\n              name: defAsText,\n              def: defNode,\n            });\n          }\n        }\n      }\n    });\n\n    const envFuncSearchOptions: Fuse.FuseOptions<EnvFuncSearchItem> = {\n      keys: ['name'],\n    };\n    const envFuncSearchResults = (new Fuse(envFuncSearchItems, envFuncSearchOptions)).search<EnvFuncSearchItem, false, false>(text);\n\n    for (const result of envFuncSearchResults) {\n      const funcDefNode = result.def;\n\n      const outs: ReadonlyArray<ApplicationOut> = funcDefNode.sig.yields.map((_, idx) => {\n        const thisYieldReturned = (idx === funcDefNode.sig.returnedIdx);\n        return {\n          sid: generateStreamId(),\n          name: thisYieldReturned ? null : {\n            kind: NodeKind.Name,\n            text: '',\n          },\n        };\n      });\n\n      const sargs: ReadonlyArray<StreamExpressionNode> = funcDefNode.sig.streamParams.map((_, idx) => (\n        (infixMode && (idx === 0))\n        ? initNode\n        : {\n          kind: NodeKind.UndefinedLiteral,\n          sid: generateStreamId(),\n        }\n      ));\n\n      const fargs: ReadonlyArray<FunctionExpressionNode> = funcDefNode.sig.funcParams.map((param: SignatureFunctionParameterNode) => {\n        return {\n          kind: NodeKind.TreeFunctionDefinition,\n          fid: generateFunctionId(),\n          sig: param.sig,\n          ui: {kind: 'none'},\n          sparams: param.templateNames.streamParams.map(name => ({\n            kind: NodeKind.StreamParameter,\n            sid: generateStreamId(),\n            name: { kind: NodeKind.Name, text: name },\n          })),\n          fparams: param.templateNames.funcParams.map(name => ({\n            kind: NodeKind.FunctionParameter,\n            fid: generateFunctionId(),\n            name: { kind: NodeKind.Name, text: name },\n          })),\n          body: {\n            kind: NodeKind.TreeFunctionBody,\n            exprs: param.templateNames.yields.map((name, idx) => ({\n              kind: NodeKind.YieldExpression,\n              idx,\n              name: { kind: NodeKind.Name, text: name },\n              expr: {\n                kind: NodeKind.UndefinedLiteral,\n                sid: generateStreamId(),\n              },\n            })),\n          },\n        }\n      });\n\n      const n: ApplicationNode = {\n        kind: NodeKind.Application,\n        aid: generateApplicationId(),\n        outs,\n        func: {\n          kind: NodeKind.FunctionReference,\n          ref: funcDefNode.fid,\n        },\n        sargs,\n        fargs,\n      };\n\n      choices.push({\n        node: n,\n      });\n    }\n\n    for (const bv of [true, false]) {\n      if ((text.length > 0) && bv.toString().startsWith(text)) {\n        choices.push({\n          node: {\n            kind: NodeKind.BooleanLiteral,\n            sid: generateStreamId(),\n            val: bv,\n          },\n        });\n      }\n    }\n\n    choices.push({\n      node: {\n        kind: NodeKind.TextLiteral,\n        sid: generateStreamId(),\n        val: text,\n      },\n    });\n\n    if (atRoot && text.trim() !== '') {\n      choices.push({\n        node: {\n          kind: NodeKind.Application,\n          aid: generateApplicationId(),\n          outs: [{sid: generateStreamId(), name: {kind: NodeKind.Name, text: text.trim()}}],\n          func: {\n            kind: NodeKind.FunctionReference,\n            ref: 'bind',\n          },\n          sargs: [\n            {\n              kind: NodeKind.UndefinedLiteral,\n              sid: generateStreamId(),\n            },\n          ],\n          fargs: [],\n        },\n      });\n    }\n\n    if (choices.length === 0) {\n      choices.push({\n        node: {\n          kind: NodeKind.UndefinedLiteral,\n          sid: generateStreamId(),\n        },\n      });\n    }\n\n    return choices;\n  }\n\n  // Update the expression node to reflect the current choice\n  const realizeChoice = (state: DropdownState): void => {\n    const choice = state.choices[state.index];\n\n    dispatch({type: 'UPDATE_EDITING_NODE', newNode: choice.node});\n  };\n\n  const recomputeDropdownChoices = (text: string): DropdownState => {\n    const newState: DropdownState = {\n      choices: generateChoices(text),\n      index: 0, // reset index to 0\n    };\n    realizeChoice(newState);\n    return newState;\n  };\n\n  const adjustDropdownIndex = (amount: number): void => {\n    setDropdownState(oldState => {\n      const newState = {\n        ...oldState,\n        index: (oldState.index + amount + oldState.choices.length) % oldState.choices.length,\n      };\n      realizeChoice(newState);\n      return newState;\n    });\n  };\n\n  const [dropdownState, setDropdownState] = useState<DropdownState>(() => recomputeDropdownChoices(text));\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newText = e.target.value;\n\n    if (newText === '[') {\n      // This is a special case, we bypass the normal dropdown/choice stuff\n      const initElemNode: UndefinedLiteralNode = {\n        kind: NodeKind.UndefinedLiteral,\n        sid: generateStreamId(),\n      };\n      const newArrNode: ArrayLiteralNode = {\n        kind: NodeKind.ArrayLiteral,\n        aid: generateApplicationId(),\n        sid: generateStreamId(),\n        elems: [initElemNode],\n      };\n      dispatch({type: 'UPDATE_EDITING_NODE', newNode: newArrNode});\n      dispatch({type: 'TOGGLE_EDIT'});\n      dispatch({type: 'SET_SELECTED_NODE', newNode: initElemNode});\n      dispatch({type: 'TOGGLE_EDIT'});\n    } else {\n      setText(newText);\n      setDropdownState(recomputeDropdownChoices(newText));\n    }\n  };\n\n  const onKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    switch (e.key) {\n      case 'ArrowUp':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        e.stopPropagation();\n        adjustDropdownIndex(-1);\n        break;\n\n      case 'ArrowDown':\n        e.preventDefault(); // we don't want the default behavior of moving the cursor\n        e.stopPropagation();\n        adjustDropdownIndex(1);\n        break;\n\n      case '=': {\n        e.preventDefault();\n        e.stopPropagation();\n\n        if (!inputRef.current) {\n          throw new Error();\n        }\n\n        if (atRoot) {\n          const inputText = inputRef.current.value;\n          const bindNode: ApplicationNode = {\n            kind: NodeKind.Application,\n            aid: generateApplicationId(),\n            outs: [{sid: generateStreamId(), name: {kind: NodeKind.Name, text: inputText}}],\n            func: {\n              kind: NodeKind.FunctionReference,\n              ref: 'bind',\n            },\n            sargs: [\n              {\n                kind: NodeKind.UndefinedLiteral,\n                sid: generateStreamId(),\n              },\n            ],\n            fargs: [],\n          };\n          dispatch({type: 'UPDATE_EDITING_NODE', newNode: bindNode});\n          dispatch({type: 'TOGGLE_EDIT'});\n        }\n        break;\n      }\n\n      default:\n        // do nothing\n        break;\n    }\n  };\n\n  return (\n    <div className=\"Chooser\">\n      <input className=\"Chooser-input\" value={text} onChange={onChange} onKeyDown={onKeyDown} ref={inputRef} autoFocus />\n      <ul className=\"Chooser-dropdown\">\n        {dropdownState.choices.map((choice, idx) => {\n          const classNames = [];\n          if (idx === dropdownState.index) {\n            if (compileError) {\n              classNames.push('Chooser-dropdown-selected-error');\n            } else {\n              classNames.push('Chooser-dropdown-selected');\n            }\n          }\n          return (\n            <li key={idx} className={classNames.join(' ')} ref={(idx === dropdownState.index) ? selectedListElem : undefined}>\n              <ChoiceView choice={choice} treeViewCtx={treeViewCtx} />\n              {(compileError && (idx === dropdownState.index)) ?\n                <div className=\"Chooser-dropdown-compile-error\">{compileError}</div>\n              : null}\n            </li>\n          );\n        })}\n      </ul>\n    </div>\n  );\n}\n\nconst NameChooser: React.FC<{initSelTree: SelTree, dispatch: (action: any) => void}> = ({ initSelTree, dispatch }) => {\n  const initNode = initSelTree.selectedNode;\n  if (initNode.kind !== NodeKind.Name) {\n    throw new Error();\n  }\n\n  const inputRef = useRef<HTMLInputElement>(null);\n  useEffect(() => {\n    inputRef.current && inputRef.current.select();\n  }, []);\n\n  const [text, setText] = useState(() => {\n    return initNode.text;\n  });\n\n  const onChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const newText = e.target.value;\n\n    setText(newText);\n\n    const newNode: NameNode = {\n      ...initNode,\n      text: newText,\n    };\n    dispatch({type: 'UPDATE_EDITING_NODE', newNode: newNode});\n  };\n\n  return (\n    <div className=\"Chooser\">\n      <input className=\"Chooser-input\" value={text} onChange={onChange} ref={inputRef} autoFocus />\n    </div>\n  );\n}\n\nconst Chooser: React.FC<{initSelTree: SelTree, nativeFunctions: ReadonlyArray<NativeFunctionDefinitionNode>, dispatch: (action: any) => void, compileError: string | undefined, infixMode: boolean, treeViewCtx: TreeViewContext}> = ({ initSelTree, nativeFunctions, dispatch, compileError, infixMode, treeViewCtx }) => {\n  if (initSelTree.selectedNode.kind === NodeKind.Name) {\n    return <NameChooser initSelTree={initSelTree} dispatch={dispatch} />\n  } else if (isStreamExpressionNode(initSelTree.selectedNode)) {\n    return <ExpressionChooser initSelTree={initSelTree} nativeFunctions={nativeFunctions} dispatch={dispatch} compileError={compileError} infixMode={infixMode} treeViewCtx={treeViewCtx} />\n  } else {\n    throw new Error();\n  }\n}\n\nexport default Chooser;\n","import React, { useReducer, useRef, useEffect, useLayoutEffect } from 'react';\nimport { HotKeys, ObserveKeys } from \"react-hotkeys\";\nimport { initialState, reducer, getReferentNameNodeOfSelected, initStaticEnv, getStaticEnvForSelected } from './EditReducer';\nimport { StoragePanel } from './StoragePanel';\nimport './Editor.css';\nimport { TreeFunctionDefinitionView, TreeViewContext } from './TreeView';\nimport { Node, TreeFunctionDefinitionNode } from './Tree';\nimport { ProgramInfo } from './State';\nimport Chooser from './Chooser';\n\nconst keyMap = {\n  TOGGLE_EDIT: 'enter',\n  ABORT_EDIT: 'escape',\n  INFIX_EDIT: 'shift+enter',\n\n  INSERT_BEFORE: 'shift+up',\n  INSERT_AFTER: 'shift+down',\n\n  DELETE_SUBTREE: 'backspace',\n\n  EDIT_NEXT_UNDEFINED: 'tab',\n\n  UNDO: 'command+z',\n\n  CUT: 'command+x',\n  PASTE: 'command+v',\n};\n\n// These are \"normal\" character keys that we use as commands. We identify them because we don't want\n// them to begin a \"overwrite edit\".\nconst COMMAND_CHARS = new Set([\n  '=',\n  ',',\n]);\n\n// By default, if an input element is focused, keys will be ignored. But we want some\n// of them to be processed even when an input is focused, and those ones are listed here.\n// Note that react-hotkeys only lets us list the individual keys herfe not \"combinations\"\n// as we would want.\nconst CATCH_IN_INPUTS = [\n  'Enter',\n  'Shift',\n  'Escape',\n  'Tab',\n  '=',\n  ',',\n];\n\nconst Editor: React.FC<{autoFocus: boolean}> = ({ autoFocus }) => {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const editorElem = useRef<HTMLDivElement>(null);\n\n  const firstRender = useRef(true);\n  useEffect(() => {\n    firstRender.current = false;\n  }, []);\n\n  // TODO: memoize generation of this\n  const handlers: {[key: string]: (keyEvent?: KeyboardEvent | undefined) => void} = {};\n  for (const k of Object.keys(keyMap)) {\n    handlers[k] = (() => (e: KeyboardEvent | undefined) => {\n      if (e) {\n        e.preventDefault(); // If we attempted to handle this, prevent default (scrolling window, entering character, etc.)\n      }\n      dispatch({type: k});\n    })(); // IIFE to bind k\n  }\n\n  const onKeyDown = (e: React.KeyboardEvent<HTMLDivElement>) => {\n    // TODO: This is not a robust check, but the spec is complicated\n    // (https://www.w3.org/TR/uievents-key/#keys-whitespace)\n    if (((e.target as Element).tagName.toLowerCase() !== 'input') && ([...e.key].length === 1) && !e.altKey && !e.ctrlKey && !e.metaKey && !COMMAND_CHARS.has(e.key)) {\n      // Interestingly, the key here will still end up going into the input element, which is what we want.\n      dispatch({type: 'BEGIN_EDIT'});\n    }\n  };\n\n  const handleChangeProgramName = (newName: string) => {\n    dispatch({type: 'SET_PROGRAM_NAME', newName});\n  };\n\n  const handleLoadProgram = (info: ProgramInfo, mainDefinition: TreeFunctionDefinitionNode) => {\n    dispatch({type: 'LOAD_PROGRAM', newProgram: {info: info, mainDefinition}});\n  };\n\n  const displayedSelTree = state.editing ? state.editing.initSelTree : state.stableSelTree;\n\n  const referentNameNode = getReferentNameNodeOfSelected(displayedSelTree, state.nativeFunctions);\n\n  const treeViewCtx: TreeViewContext = {\n    markedNodes: {\n      selected: displayedSelTree.selectedNode,\n      referentName: referentNameNode,\n    },\n    // clipboardTopNode: (state.clipboardStack.length > 0) ? state.derivedLookups.streamIdToNode!.get(state.clipboardStack[state.clipboardStack.length-1].streamId) : null,\n    // clipboardRestNodes: state.clipboardStack.slice(0, -1).map(frame => state.derivedLookups.streamIdToNode!.get(frame.streamId)),\n    staticEnv: initStaticEnv(state.nativeFunctions),\n    setSelectedNode: (node: Node) => {\n      dispatch({\n        type: 'SET_SELECTED_NODE',\n        newNode: node,\n      });\n    },\n    focusSelected: !state.editing && (autoFocus || !firstRender.current),\n  };\n\n  const positionedForEditSessionId: React.MutableRefObject<string | undefined> = useRef();\n\n  // Position the chooser\n  useLayoutEffect(() => {\n    const editingSessionId = state.editing ? state.editing.sessionId : undefined;\n\n    if (positionedForEditSessionId.current !== editingSessionId) {\n      // NOTE: Directly referring to these class names is hacky\n      const cpElem = document.querySelector('.Editor-chooser-positioner') as HTMLElement;\n      const selElem = document.querySelector('.TreeView-selected');\n      if (cpElem && selElem) {\n        // const cpRect = cpElem.getBoundingClientRect();\n        const selRect = selElem.getBoundingClientRect();\n        cpElem.style.left = selRect.left + 'px';\n        cpElem.style.top = (selRect.bottom + 2) + 'px';\n      }\n\n      positionedForEditSessionId.current = editingSessionId;\n    }\n  });\n\n  return (\n    <div className=\"Editor\">\n      <div className=\"Editor-storage-panel-container Editor-panel\">\n        <StoragePanel programInfo={state.programInfo} mainDefinition={state.stableSelTree.mainDefinition} onChangeName={handleChangeProgramName} onLoadProgram={handleLoadProgram} />\n      </div>\n      <HotKeys keyMap={keyMap} handlers={handlers}>\n        <ObserveKeys only={CATCH_IN_INPUTS}>\n          <div className=\"Editor-workspace\" onKeyDown={onKeyDown} tabIndex={0} ref={editorElem}>\n            <TreeFunctionDefinitionView node={displayedSelTree.mainDefinition} ctx={treeViewCtx} />\n            {state.editing && (() => {\n              const chooserTreeViewCtx: TreeViewContext = {\n                ...treeViewCtx,\n                setSelectedNode: () => {},\n                staticEnv: getStaticEnvForSelected(state.editing.initSelTree, state.nativeFunctions),\n                focusSelected: false,\n              };\n\n              return (\n                <div className=\"Editor-chooser-positioner\" style={{position: 'absolute'}}>\n                  <Chooser key={state.editing.sessionId} initSelTree={state.editing.initSelTree} nativeFunctions={state.nativeFunctions} dispatch={dispatch} compileError={state.editing.compileError} infixMode={state.editing.infixMode} treeViewCtx={chooserTreeViewCtx} />\n                </div>\n              );\n            })()}\n          </div>\n        </ObserveKeys>\n      </HotKeys>\n    </div>\n  );\n}\nexport default Editor;\n","import React from 'react';\nimport './App.css';\nimport Editor from './Editor';\n\nconst App: React.FC = () => {\n  return (\n    <div className=\"App\">\n      <Editor autoFocus={true} />\n      {/* <div>\n        <h2>Notes</h2>\n        <ul>\n          <li>If you don't see a green selection/cursor box, focus the editor.</li>\n          <li>The mouse can be used to select parts of the tree, but otherwise editing is keyboard-driven.</li>\n          <li>Up/down arrows move selection up and down within lists (expressions, arguments, arrays).</li>\n          <li>Right/left arrows move selection in and out of nested structures.</li>\n          <li>Enter on an expression (or expression sub-tree) will begin editing it. Pressing enter again will stop editing.</li>\n          <li>Instead of pressing enter, you can just start typing letters/numbers and it will begin the edit (overwriting what it there).</li>\n          <li>Escape aborts the current edit.</li>\n          <li>Shift-enter (or comma) adds a new expression (or array item) below the current one.</li>\n          <li>Pressing the = key on on an expression will move to editing its name/label.</li>\n          <li>A red box indicates an undefined expression.</li>\n          <li>Tab edits the next undefined expression.</li>\n          <li>Delete will delete expressions, array items, etc.</li>\n          <li>Typing [ when editing an expression will create an array literal.</li>\n        </ul>\n      </div> */}\n      <div id=\"output\"></div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}