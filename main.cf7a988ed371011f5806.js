!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=2)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNoInOutExecutionContext", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useVar", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRequestUpdate", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useInitialize", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useAsyncEventEmitter", function() { return useAsyncEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventReceiver", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDynamic", function() { return useDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return useReducer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMachine", function() { return useMachine; });\nlet currentUpdateFrame = null;\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push a new update frame onto the update stack for this context\n    const newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn\'t get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error(\'Did not reach all hook records in update\');\n    } // Pop the top frame from the update stack\n\n\n    const poppedFrame = currentUpdateFrame;\n\n    if (!poppedFrame) {\n      throw new Error(\'Cannot pop update frame because current is null\');\n    }\n\n    if (poppedFrame.executionContext !== this) {\n      throw new Error("Popped frame from update stack but context did not match");\n    }\n\n    currentUpdateFrame = poppedFrame.previousFrame;\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // NOTE: Might we want to sanity check that this context isn\'t anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error(\'Expecting to create new hook record in chain, but already present\');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error(\'Expecting to find hook record in chain, but not present\');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It\'s currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error(\'Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?\');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can\'t we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it\'s important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\n/**\n * This is effectively a queue with only a single-item capacity, to support async event emission\n */\n\nfunction useAsyncEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {\n      queuedEvent: undefined\n    };\n\n    data.emit = value => {\n      if (data.queuedEvent) {\n        throw new Error(\'Cannot emit another event since one is already enqueued\');\n      }\n\n      data.queuedEvent = {\n        value\n      };\n    };\n\n    record.data = data;\n  }\n\n  let retval;\n\n  if (record.data.queuedEvent) {\n    // Pop queued event\n    retval = record.data.queuedEvent;\n    record.data.queuedEvent = undefined;\n  }\n\n  ctx._endHook();\n\n  return [retval, record.data.emit];\n}\nfunction useEventReceiver(evt) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      seen: new WeakSet() // event objects we have already seen\n\n    };\n  }\n\n  let retval;\n\n  if (evt) {\n    if (!record.data.seen.has(evt)) {\n      retval = evt;\n      record.data.seen.add(evt);\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new "version" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create "factory" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\nfunction useReducer(actionEvts, reducerFunc, initialState) {\n  const state = useVar(initialState);\n  const action = useEventReceiver(actionEvts);\n  state.current = reducerFunc(action, state.current);\n  return state.current;\n}\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook();\n\n  const takeTransition = trans => {\n    // If there\'s an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    const [newState, newStateArg] = trans; // Create a new context and store it in record (but don\'t update it)\n\n    const newCtx = new ExecutionContext(states[newState], () => {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    const data = {};\n    record.data = data;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = () => {\n      data.activeContext.terminate();\n    };\n  }\n\n  let retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    const [tmpRetval, transitionEvt] = record.data.activeContext.update(record.data.activeArgument);\n    retval = tmpRetval; // Was there a transition event?\n    // NOTE: Because we transition upon first even on this stream, we can sort of special-case this check\n\n    if (transitionEvt) {\n      const transition = transitionEvt.value;\n      takeTransition(transition);\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcml2LmpzPzgxNWEiXSwibmFtZXMiOlsiY3VycmVudFVwZGF0ZUZyYW1lIiwiRXhlY3V0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RyZWFtRnVuYyIsIm9uUmVxdWVzdFVwZGF0ZSIsImFmdGVyVGVybWluYXRlIiwiaG9va1JlY29yZENoYWluIiwibmV4dCIsInJlY29yZEN1cnNvciIsInVwZGF0ZUNvdW50IiwidXBkYXRlIiwibmV3RnJhbWUiLCJleGVjdXRpb25Db250ZXh0IiwicHJldmlvdXNGcmFtZSIsInJldHZhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJwb3BwZWRGcmFtZSIsInRlcm1pbmF0ZSIsImMiLCJjbGVhbnVwIiwiX2JlZ2luSG9vayIsImRhdGEiLCJ1bmRlZmluZWQiLCJfZW5kSG9vayIsIl9yZXF1ZXN0VXBkYXRlIiwiX3NldFN0cmVhbUZ1bmMiLCJuZXdTdHJlYW1GdW5jIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJjdHgiLCJnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQiLCJ1c2VWYXIiLCJpbml0VmFsIiwicmVjb3JkIiwiY3VycmVudCIsInVzZVJlcXVlc3RVcGRhdGUiLCJyZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsImluaXRpYWxpemVyIiwidXNlQXN5bmNFdmVudEVtaXR0ZXIiLCJxdWV1ZWRFdmVudCIsImVtaXQiLCJ2YWx1ZSIsInVzZUV2ZW50UmVjZWl2ZXIiLCJldnQiLCJzZWVuIiwiV2Vha1NldCIsImhhcyIsImFkZCIsInVzZUR5bmFtaWMiLCJvcnUiLCJhY3RpdmVDb250ZXh0cyIsIlNldCIsImNyZWF0ZUNvbnRleHQiLCJkZWxldGUiLCJ1c2VSZWR1Y2VyIiwiYWN0aW9uRXZ0cyIsInJlZHVjZXJGdW5jIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJhY3Rpb24iLCJ1c2VNYWNoaW5lIiwic3RhdGVzIiwiaW5pdGlhbFRyYW5zaXRpb24iLCJ0YWtlVHJhbnNpdGlvbiIsInRyYW5zIiwiYWN0aXZlQ29udGV4dCIsIm5ld1N0YXRlIiwibmV3U3RhdGVBcmciLCJuZXdDdHgiLCJhY3RpdmVTdGF0ZSIsImFjdGl2ZUFyZ3VtZW50IiwidG1wUmV0dmFsIiwidHJhbnNpdGlvbkV2dCIsInRyYW5zaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBSUEsa0JBQWtCLEdBQUcsSUFBekI7O0FBRUEsTUFBTUMsZ0JBQU4sQ0FBdUI7QUFDckJDLGFBQVcsQ0FBQ0MsVUFBRCxFQUFhQyxlQUFiLEVBQThCQyxjQUE5QixFQUE4QztBQUN2RCxTQUFLRixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7QUFFQSxTQUFLQyxlQUFMLEdBQXVCO0FBQUNDLFVBQUksRUFBRTtBQUFQLEtBQXZCLENBTHVELENBS2xCOztBQUNyQyxTQUFLQyxZQUFMLEdBQW9CLElBQXBCLENBTnVELENBTTdCOztBQUMxQixTQUFLQyxXQUFMLEdBQW1CLENBQW5CO0FBQ0Q7O0FBRURDLFFBQU0sR0FBRztBQUNQO0FBQ0EsVUFBTUMsUUFBUSxHQUFHO0FBQ2ZDLHNCQUFnQixFQUFFLElBREg7QUFFZkMsbUJBQWEsRUFBRWI7QUFGQSxLQUFqQjtBQUlBQSxzQkFBa0IsR0FBR1csUUFBckIsQ0FOTyxDQVFQOztBQUNBLFNBQUtILFlBQUwsR0FBb0IsS0FBS0YsZUFBekI7QUFFQSxVQUFNUSxNQUFNLEdBQUcsS0FBS1gsVUFBTCxDQUFnQlksS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJDLFNBQTVCLENBQWYsQ0FYTyxDQWFQOztBQUNBLFFBQUksS0FBS1IsWUFBTCxDQUFrQkQsSUFBdEIsRUFBNEI7QUFDMUIsWUFBTSxJQUFJVSxLQUFKLENBQVUsMENBQVYsQ0FBTjtBQUNELEtBaEJNLENBa0JQOzs7QUFD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dGVGcmFtZSA9IG51bGw7XG5cbmNsYXNzIEV4ZWN1dGlvbkNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihzdHJlYW1GdW5jLCBvblJlcXVlc3RVcGRhdGUsIGFmdGVyVGVybWluYXRlKSB7XG4gICAgdGhpcy5zdHJlYW1GdW5jID0gc3RyZWFtRnVuYztcbiAgICB0aGlzLm9uUmVxdWVzdFVwZGF0ZSA9IG9uUmVxdWVzdFVwZGF0ZTtcbiAgICB0aGlzLmFmdGVyVGVybWluYXRlID0gYWZ0ZXJUZXJtaW5hdGU7XG5cbiAgICB0aGlzLmhvb2tSZWNvcmRDaGFpbiA9IHtuZXh0OiBudWxsfTsgLy8gZHVtbXlcbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IG51bGw7IC8vIG9ubHkgc2V0IHdoZW4gdGhpcyBjb250ZXh0IGlzIHVwZGF0aW5nXG4gICAgdGhpcy51cGRhdGVDb3VudCA9IDA7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gUHVzaCBhIG5ldyB1cGRhdGUgZnJhbWUgb250byB0aGUgdXBkYXRlIHN0YWNrIGZvciB0aGlzIGNvbnRleHRcbiAgICBjb25zdCBuZXdGcmFtZSA9IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQ6IHRoaXMsXG4gICAgICBwcmV2aW91c0ZyYW1lOiBjdXJyZW50VXBkYXRlRnJhbWUsXG4gICAgfTtcbiAgICBjdXJyZW50VXBkYXRlRnJhbWUgPSBuZXdGcmFtZTtcblxuICAgIC8vIE1vdmUgaG9vayByZWNvcmQgY3Vyc29yIHRvIHN0YXJ0IG9mIGNoYWluXG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSB0aGlzLmhvb2tSZWNvcmRDaGFpbjtcblxuICAgIGNvbnN0IHJldHZhbCA9IHRoaXMuc3RyZWFtRnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgbnVsbCwgb3RoZXJ3aXNlIHRoZXJlIGFyZSBob29rIHJlY29yZHMgd2UgZGlkbid0IGdldCB0bywgYW5kIHNvbWV0aGluZyBpcyBhbWlzc1xuICAgIGlmICh0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgcmVhY2ggYWxsIGhvb2sgcmVjb3JkcyBpbiB1cGRhdGUnKTtcbiAgICB9XG5cbiAgICAvLyBQb3AgdGhlIHRvcCBmcmFtZSBmcm9tIHRoZSB1cGRhdGUgc3RhY2tcbiAgICBjb25zdCBwb3BwZWRGcmFtZSA9IGN1cnJlbnRVcGRhdGVGcmFtZTtcbiAgICBpZiAoIXBvcHBlZEZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwb3AgdXBkYXRlIGZyYW1lIGJlY2F1c2UgY3VycmVudCBpcyBudWxsJyk7XG4gICAgfVxuICAgIGlmIChwb3BwZWRGcmFtZS5leGVjdXRpb25Db250ZXh0ICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3BwZWQgZnJhbWUgZnJvbSB1cGRhdGUgc3RhY2sgYnV0IGNvbnRleHQgZGlkIG5vdCBtYXRjaFwiKTtcbiAgICB9XG4gICAgY3VycmVudFVwZGF0ZUZyYW1lID0gcG9wcGVkRnJhbWUucHJldmlvdXNGcmFtZTtcblxuICAgIHRoaXMudXBkYXRlQ291bnQrKztcblxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICB0ZXJtaW5hdGUoKSB7XG4gICAgLy8gTk9URTogTWlnaHQgd2Ugd2FudCB0byBzYW5pdHkgY2hlY2sgdGhhdCB0aGlzIGNvbnRleHQgaXNuJ3QgYW55d2hlcmUgaW4gdGhlIGN1cnJlbnQgdXBkYXRlIHN0YWNrP1xuXG4gICAgLy8gQ2FsbCBhbnkgY2xlYW51cCBmdW5jdGlvbnMgc2V0IGJ5IGhvb2tzXG4gICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byB3b3JyeSBhYm91dCBvcmRlcj9cbiAgICBmb3IgKGxldCBjID0gdGhpcy5ob29rUmVjb3JkQ2hhaW4ubmV4dDsgYzsgYyA9IGMubmV4dCkge1xuICAgICAgaWYgKGMuY2xlYW51cCkge1xuICAgICAgICBjLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZnRlclRlcm1pbmF0ZSkge1xuICAgICAgdGhpcy5hZnRlclRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9iZWdpbkhvb2soKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlQ291bnQgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIHRvIGNyZWF0ZSBuZXcgaG9vayByZWNvcmQgaW4gY2hhaW4sIGJ1dCBhbHJlYWR5IHByZXNlbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBuZXcgcmVjb3JkXG4gICAgICB0aGlzLnJlY29yZEN1cnNvci5uZXh0ID0ge1xuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIGNsZWFudXA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIHRvIGZpbmQgaG9vayByZWNvcmQgaW4gY2hhaW4sIGJ1dCBub3QgcHJlc2VudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlY29yZEN1cnNvci5uZXh0O1xuICB9XG5cbiAgX2VuZEhvb2soKSB7XG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSB0aGlzLnJlY29yZEN1cnNvci5uZXh0OyAvLyBtb3ZlIGN1cnNvciBmb3J3YXJkXG4gIH1cblxuICBfcmVxdWVzdFVwZGF0ZSgpIHtcbiAgICB0aGlzLm9uUmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgb25seSBzYWZlIHRvIGRvIGlmIHRoZSByZXBsYWNlbWVudCBmdW5jdGlvbiBjYWxscyB0aGUgc2FtZSBob29rcywgaGFzIHNhbWUgc2lnbmF0dXJlLCBldGMuXG4gICAqIEl0J3MgY3VycmVudGx5IHVzZWQgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgaXMgbGV4aWNhbGx5IHRoZSBzYW1lIGJ1dCBib3VuZCB0byBkaWZmZXJlbnQgb3V0ZXItc2NvcGVcbiAgICogdmFyaWFibGVzLlxuICAgKi9cbiAgX3NldFN0cmVhbUZ1bmMobmV3U3RyZWFtRnVuYykge1xuICAgIHRoaXMuc3RyZWFtRnVuYyA9IG5ld1N0cmVhbUZ1bmM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0KHN0cmVhbUZ1bmMpIHtcbiAgY29uc3Qgb25SZXF1ZXN0VXBkYXRlID0gKCkgPT4geyBjdHgudXBkYXRlKCkgfTtcbiAgY29uc3QgY3R4ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlKVxuICByZXR1cm4gY3R4O1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCBieSBob29rcyB0byBnZXQgdGhlIGN1cnJlbnRseSB1cGRhdGluZyBjb250ZXh0IChhZnRlciB2ZXJpZnlpbmcgaXQgaXMgc2V0KVxuICovXG5mdW5jdGlvbiBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKSB7XG4gIGlmICghY3VycmVudFVwZGF0ZUZyYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGN1cnJlbnRseSB1cGRhdGluZyBleGVjdXRpb24gY29udGV4dCBiZWNhdXNlIHVwZGF0ZSBzdGFjayBpcyBlbXB0eS4gV2FzIGEgaG9vayBjYWxsZWQgb3V0c2lkZSBvZiBhbiBleGVjdXRpb24gY29udGV4dCB1cGRhdGU/Jyk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVGcmFtZS5leGVjdXRpb25Db250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVmFyKGluaXRWYWwpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gQ3JlYXRlIHZhbHVlIGJveCBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge2N1cnJlbnQ6IGluaXRWYWx9O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhO1xufVxuXG4vKipcbiAqIFdoeSBkbyB3ZSBuZWVkIGEgaG9vaz8gV2h5IGNhbid0IHdlIGp1c3QgY2FsbCBjdHgucmVxdWVzdFVwZGF0ZSgpPyBCZWNhdXNlIHRoZSByZXF1ZXN0VXBkYXRlXG4gKiBmdW5jdGlvbiB0aGF0IHdlIHJldHVybiB3aWxsIG9mdGVuIGJlIGNhbGxlZCB3aXRob3V0IHRoZXJlIGJlaW5nIGFueSB1cGRhdGluZyBleGVjdXRpb24gY29udGV4dFxuICogKGUuZy4gZnJvbSBhbiBldmVudCBoYW5kbGVyKS4gU28gaXQgaGFzIHRvIGJlIGJvdW5kIHRvIHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXF1ZXN0VXBkYXRlKCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBDcmVhdGUgY2FsbGJhY2sgaWYgbmVjZXNzYXJ5LiBXZSBzdG9yZSBpdCBzbyB0aGF0IHdlIGFscmVhZHkgcmV0dXJuIHRoZSBzYW1lIG9uZS5cbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge3JlcXVlc3RVcGRhdGU6ICgpID0+IHtcbiAgICAgIGN0eC5fcmVxdWVzdFVwZGF0ZSgpOyAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHdlIHVzZSBjdHggZnJvbSBjbG9zdXJlLCBub3QgZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCkgaGVyZVxuICAgIH19O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhLnJlcXVlc3RVcGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbml0aWFsaXplKGluaXRpYWxpemVyKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICAvLyBkYXRhIGJlaW5nIHVuZGVmaW5lZCBtZWFucyB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsXG5cbiAgICByZWNvcmQuY2xlYW51cCA9IGluaXRpYWxpemVyKCk7XG5cbiAgICByZWNvcmQuZGF0YSA9IHt9OyAvLyBubyBkYXRhIHRvIHN0b3JlIHlldCwganVzdCBuZWVkcyB0byBiZSB0cnV0aHkgdG8gaW5kaWNhdGUgdGhhdCBpbml0aWFsaXphdGlvbiByYW5cbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgZWZmZWN0aXZlbHkgYSBxdWV1ZSB3aXRoIG9ubHkgYSBzaW5nbGUtaXRlbSBjYXBhY2l0eSwgdG8gc3VwcG9ydCBhc3luYyBldmVudCBlbWlzc2lvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNFdmVudEVtaXR0ZXIoKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgcXVldWVkRXZlbnQ6IHVuZGVmaW5lZCxcbiAgICB9O1xuXG4gICAgZGF0YS5lbWl0ID0gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoZGF0YS5xdWV1ZWRFdmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbWl0IGFub3RoZXIgZXZlbnQgc2luY2Ugb25lIGlzIGFscmVhZHkgZW5xdWV1ZWQnKTtcbiAgICAgIH1cbiAgICAgIGRhdGEucXVldWVkRXZlbnQgPSB7dmFsdWV9O1xuICAgIH07XG5cbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG4gIH1cblxuICBsZXQgcmV0dmFsO1xuICBpZiAocmVjb3JkLmRhdGEucXVldWVkRXZlbnQpIHtcbiAgICAvLyBQb3AgcXVldWVkIGV2ZW50XG4gICAgcmV0dmFsID0gcmVjb3JkLmRhdGEucXVldWVkRXZlbnQ7XG4gICAgcmVjb3JkLmRhdGEucXVldWVkRXZlbnQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gW3JldHZhbCwgcmVjb3JkLmRhdGEuZW1pdF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudFJlY2VpdmVyKGV2dCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7XG4gICAgICBzZWVuOiBuZXcgV2Vha1NldCgpLCAvLyBldmVudCBvYmplY3RzIHdlIGhhdmUgYWxyZWFkeSBzZWVuXG4gICAgfTtcbiAgfVxuXG4gIGxldCByZXR2YWw7XG4gIGlmIChldnQpIHtcbiAgICBpZiAoIXJlY29yZC5kYXRhLnNlZW4uaGFzKGV2dCkpIHtcbiAgICAgIHJldHZhbCA9IGV2dDtcbiAgICAgIHJlY29yZC5kYXRhLnNlZW4uYWRkKGV2dCk7XG4gICAgfVxuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJldHZhbDtcbn1cblxuLyoqXG4gKiBUaGUgc3RyZWFtRnVuYyBhcmd1bWVudCBtYXkgY2hhbmdlLCBidXQgaXQgc2hvdWxkIG9ubHkgY2hhbmdlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgc2FmZWx5XG4gKiBzd2FwcGVkIGluIChpLmUuIG9uZSB0aGF0IGNhbGxzIHRoZSBzYW1lIGhvb2tzLCBldGMuKS4gQSBjb21tb24gY2FzZSBpcyB0aGF0IHN0cmVhbUZ1bmMgaXMgYVxuICogY2xvc3VyZSB0aGF0IHJlZmVyZW5jZXMgc29tZSBvdXRlciBzY29wZSB2YXJpYWJsZXMsIGFuZCB3aGVuIHRob3NlIGNoYW5nZSwgYSBuZXcgXCJ2ZXJzaW9uXCIgb2ZcbiAqIHRoZSBmdW5jdGlvbiBpcyBjcmVhdGVkIChsZXhpY2FsbHkgdGhlIHNhbWUsIGJ1dCBjbG9zaW5nIG92ZXIgYSBkaWZmZXJlbnQgc2NvcGUpLlxuICpcbiAqIG9uUmVxdWVzdFVwZGF0ZSBpcyBjdXJyZW50bHkgb25seSByZWFkIG9uIHRoZSBmaXJzdCBjYWxsLCBzbyBjaGFuZ2VzIHRvIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEeW5hbWljKHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuXG4gICAgLy8gSWYgbm8gb25SZXF1ZXN0VXBkYXRlIGlzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIHJlcXVlc3RpbmcgdXBkYXRlIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICBjb25zdCBvcnUgPSBvblJlcXVlc3RVcGRhdGUgfHwgKCgpID0+IHtcbiAgICAgIGN0eC5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gVHJhY2sgRXhlY3V0aW9uQ29udGV4dHMgY3JlYXRlZCAoYW5kIG5vdCB5ZXQgdGVybWluYXRlZCkgc28gd2UgY2FuIHRlcm1pbmF0ZSB0aGVtIHVwb24gY2xlYW51cFxuICAgIGRhdGEuYWN0aXZlQ29udGV4dHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBDcmVhdGUgXCJmYWN0b3J5XCIgZnVuY3Rpb24gdG8gaW5zdGFudGlhdGUgbmV3IGNvbnRleHRzXG4gICAgZGF0YS5jcmVhdGVDb250ZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoZGF0YS5zdHJlYW1GdW5jLCBvcnUsICgpID0+IHsgZGF0YS5hY3RpdmVDb250ZXh0cy5kZWxldGUoY3R4KTsgfSk7XG4gICAgICBkYXRhLmFjdGl2ZUNvbnRleHRzLmFkZChjdHgpO1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuXG4gICAgcmVjb3JkLmRhdGEgPSBkYXRhO1xuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjdHggb2YgZGF0YS5hY3RpdmVDb250ZXh0cykge1xuICAgICAgICBjdHgudGVybWluYXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgc3RyZWFtIGZ1bmN0aW9uIGluIHJlY29yZCBhbmQgYWxsIGFjdGl2ZSBjb250ZXh0cy5cbiAgcmVjb3JkLmRhdGEuc3RyZWFtRnVuYyA9IHN0cmVhbUZ1bmM7XG4gIGZvciAoY29uc3QgY3R4IG9mIHJlY29yZC5kYXRhLmFjdGl2ZUNvbnRleHRzKSB7XG4gICAgY3R4Ll9zZXRTdHJlYW1GdW5jKHN0cmVhbUZ1bmMpO1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhLmNyZWF0ZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKGFjdGlvbkV2dHMsIHJlZHVjZXJGdW5jLCBpbml0aWFsU3RhdGUpIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VWYXIoaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgYWN0aW9uID0gdXNlRXZlbnRSZWNlaXZlcihhY3Rpb25FdnRzKTtcbiAgc3RhdGUuY3VycmVudCA9IHJlZHVjZXJGdW5jKGFjdGlvbiwgc3RhdGUuY3VycmVudCk7XG4gIHJldHVybiBzdGF0ZS5jdXJyZW50O1xufVxuXG4vKipcbiAqIFRPRE86IENvdWxkL3Nob3VsZCB0aGlzIHRha2UgYW4gb3B0aW9uYWwgb25SZXF1ZXN0VXBkYXRlIHBhcmFtZXRlcj9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hY2hpbmUoc3RhdGVzLCBpbml0aWFsVHJhbnNpdGlvbikge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICBjb25zdCB0YWtlVHJhbnNpdGlvbiA9ICh0cmFucykgPT4ge1xuICAgIC8vIElmIHRoZXJlJ3MgYW4gb2xkIGNvbnRleHQsIHRlcm1pbmF0ZSBpdFxuICAgIGlmIChyZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0KSB7XG4gICAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IFtuZXdTdGF0ZSwgbmV3U3RhdGVBcmddID0gdHJhbnM7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCBhbmQgc3RvcmUgaXQgaW4gcmVjb3JkIChidXQgZG9uJ3QgdXBkYXRlIGl0KVxuICAgIGNvbnN0IG5ld0N0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHN0YXRlc1tuZXdTdGF0ZV0sICgpID0+IHsgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7IH0pO1xuXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0ID0gbmV3Q3R4O1xuICAgIHJlY29yZC5kYXRhLmFjdGl2ZUFyZ3VtZW50ID0gbmV3U3RhdGVBcmc7XG4gIH07XG5cbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG5cbiAgICB0YWtlVHJhbnNpdGlvbihpbml0aWFsVHJhbnNpdGlvbik7IC8vIHRoaXMgd2lsbCBzZXQgc3R1ZmYgaW4gcmVjb3JkLmRhdGFcblxuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH07XG4gIH1cblxuICBsZXQgcmV0dmFsO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFNldCB0aGUgc3RhdGUgZnVuY3Rpb24gaW4gdGhlIGFjdGl2ZSBjb250ZXh0IChpbiBjYXNlIGl0IGNoYW5nZWQpXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlQ29udGV4dC5fc2V0U3RyZWFtRnVuYyhzdGF0ZXNbcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGVdKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGNvbnRleHRcbiAgICBjb25zdCBbdG1wUmV0dmFsLCB0cmFuc2l0aW9uRXZ0XSA9IHJlY29yZC5kYXRhLmFjdGl2ZUNvbnRleHQudXBkYXRlKHJlY29yZC5kYXRhLmFjdGl2ZUFyZ3VtZW50KTtcbiAgICByZXR2YWwgPSB0bXBSZXR2YWw7XG5cbiAgICAvLyBXYXMgdGhlcmUgYSB0cmFuc2l0aW9uIGV2ZW50P1xuICAgIC8vIE5PVEU6IEJlY2F1c2Ugd2UgdHJhbnNpdGlvbiB1cG9uIGZpcnN0IGV2ZW4gb24gdGhpcyBzdHJlYW0sIHdlIGNhbiBzb3J0IG9mIHNwZWNpYWwtY2FzZSB0aGlzIGNoZWNrXG4gICAgaWYgKHRyYW5zaXRpb25FdnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRXZ0LnZhbHVlO1xuICAgICAgdGFrZVRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBubyB0cmFuc2l0aW9uXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "3c7995ba1ebaeb8df6c62360cd2406d1.mp3";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYW1lbl9icmVhay5tcDM/ZTZjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIzYzc5OTViYTFlYmFlYjhkZjZjNjIzNjBjZDI0MDZkMS5tcDNcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/riv.js\nvar riv = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useAsyncEventEmitter,\n  useEventReceiver,\n  useDynamic,\n  useReducer,\n  useMachine\n} = __webpack_require__(0);\n\nconst amen_break_url = __webpack_require__(1);\n\nfunction showString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'border: 1px solid red; color: black; font-size: 24px; padding: 5px; margin-top: 20px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = 'showString: ' + (v === undefined ? '(undefined)' : v.toString());\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvt, emitClick] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvt;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction mousePosition() {\n  const requestUpdate = useRequestUpdate();\n  const position = useVar({\n    x: 0,\n    y: 0\n  }); // we can't poll position, so start it at origin\n\n  useInitialize(() => {\n    const onMouseMove = e => {\n      position.current = {\n        x: e.clientX || e.pageX,\n        y: e.clientY || e.pageY\n      };\n      requestUpdate();\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n  return position.current;\n}\n\nfunction random(repickEvt) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvt);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, {\n          value: undefined\n        }, sampleRate.current);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, undefined, sampleRate.current); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvt, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvt);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvt, emitTick] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvt;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\n\nfunction loadAudioAsArray(url) {\n  const requestUpdate = useRequestUpdate();\n  const pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(() => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    let cleanedUp = false;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = () => {\n      const audioData = request.response;\n      audioCtx.decodeAudioData(audioData, buffer => {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return () => {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nfunction integral(integrandFunc, time, initialValue = 0) {\n  const accum = useVar(initialValue);\n  const prevTime = useVar(time);\n  const integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\n\nfunction expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(currentValue => speedConstant * (targetValue - currentValue), time, initialValue);\n}\n\nfunction redCircle(position, radius = 25) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'position: absolute; border-radius: 50%; background: red; pointer-events: none; user-select: none';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  const p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  const halfRadius = 0.5 * radius;\n  elem.current.style.left = p.x - halfRadius + 'px';\n  elem.current.style.top = p.y - halfRadius + 'px';\n  elem.current.style.width = radius + 'px';\n  elem.current.style.height = radius + 'px';\n}\n\nfunction followAtSpeed2d(target, speed, time, initial) {\n  const pos = useVar(initial);\n  const prevTime = useVar(time);\n  const dt = time - prevTime.current;\n  const delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\n\nfunction eventWhen(condition, valueToEmit) {\n  const prevCondition = useVar(false);\n  const bcond = !!condition;\n  const retval = bcond && !prevCondition.current ? {\n    value: valueToEmit\n  } : undefined;\n  prevCondition.current = bcond;\n  return retval;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nfunction eventAfter(seconds, valueToEmit) {\n  const [evt, emit] = useAsyncEventEmitter();\n  const value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(() => {\n    const timerId = setTimeout(() => {\n      emit(value.current);\n    }, 1000 * seconds);\n    return () => {\n      clearTimeout(timerId);\n    };\n  });\n  return evt;\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    showString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    showString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    showString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    showString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvt) => {\n      const noise = random(advanceFrameEvt) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvt = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvt) => {\n      const noise = random(advanceFrameEvt) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvt, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvt = mouseClickEvts();\n    const click = useEventReceiver(clickEvt);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    showString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvt = mouseClickEvts();\n    const click = useEventReceiver(clickEvt);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    showString(nums.join(' '));\n  }\n}, {\n  name: 'record player spin up/down, hold mouse down and release',\n  main: () => {\n    const pcm = loadAudioAsArray(amen_break_url);\n    showString(pcm.length > 1 ? 'loaded audio' : 'loading audio...');\n    audioDriver((audioTime, advanceFrameEvt, sampleRate) => {\n      const targetSpeed = mouseDown() ? sampleRate : 0;\n      const speed = expFollow(targetSpeed, 3, audioTime, 0);\n      const pos = Math.floor(integral(() => speed, audioTime));\n      return pcm[pos % pcm.length]; // modulo so as to loop\n    });\n  }\n}, {\n  name: 'circle follows mouse',\n  main: () => {\n    redCircle(mousePosition());\n  }\n}, {\n  name: 'circle follows mouse at limited speed',\n  main: () => {\n    const time = animationTime();\n    const mpos = mousePosition();\n    redCircle(followAtSpeed2d(mpos, 300, time, mpos));\n  }\n}, {\n  name: 'circle moves halfway to mouse with each click',\n  main: () => {\n    const midpoint = (a, b) => ({\n      x: 0.5 * (a.x + b.x),\n      y: 0.5 * (a.y + b.y)\n    });\n\n    const mpos = mousePosition();\n    const clickEvt = mouseClickEvts();\n    const cpos = useReducer(clickEvt, (action, prevState) => {\n      return action ? midpoint(prevState, mpos) : prevState;\n    }, {\n      x: 0,\n      y: 0\n    });\n    redCircle(cpos);\n  }\n}, {\n  name: 'roaming circle (state machine)',\n  main: () => {\n    const time = animationTime();\n    const position = useMachine({\n      moving: initialPosition => {\n        const targetPosition = {\n          x: 500 * random(),\n          y: 500 * random()\n        };\n        const position = followAtSpeed2d(targetPosition, 300, time, initialPosition);\n        const arrived = position.x === targetPosition.x && position.y === targetPosition.y;\n        return [position, eventWhen(arrived, ['resting', position])];\n      },\n      resting: initialPosition => {\n        return [initialPosition, eventAfter(random(), ['moving', initialPosition])];\n      }\n    }, ['moving', {\n      x: 0,\n      y: 0\n    }]);\n    redCircle(position);\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(riv[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUFzeW5jRXZlbnRFbWl0dGVyIiwidXNlRXZlbnRSZWNlaXZlciIsInVzZUR5bmFtaWMiLCJ1c2VSZWR1Y2VyIiwidXNlTWFjaGluZSIsInJlcXVpcmUiLCJhbWVuX2JyZWFrX3VybCIsInNob3dTdHJpbmciLCJ2IiwiZWxlbSIsImN1cnJlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJhbmltYXRpb25UaW1lIiwicmVxdWVzdFVwZGF0ZSIsInRpbWUiLCJyZXFJZCIsIm9uRnJhbWUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbkZyYW1lRXZ0cyIsImZyYW1lRXZ0cyIsImVtaXRGcmFtZSIsImNvdW50RXZlbnRzIiwiZXZ0cyIsImNvdW50IiwiZXZlbnQiLCJtb3VzZUNsaWNrRXZ0cyIsImNsaWNrRXZ0IiwiZW1pdENsaWNrIiwib25Nb3VzZURvd24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdXNlRG93biIsImlzRG93biIsIm9uTW91c2VVcCIsIm1vdXNlUG9zaXRpb24iLCJwb3NpdGlvbiIsIngiLCJ5Iiwib25Nb3VzZU1vdmUiLCJlIiwiY2xpZW50WCIsInBhZ2VYIiwiY2xpZW50WSIsInBhZ2VZIiwicmFuZG9tIiwicmVwaWNrRXZ0IiwidmFsIiwiTWF0aCIsInJlcGljayIsImF1ZGlvRHJpdmVyIiwiZ2VuZXJhdG9yIiwiY3JlYXRlR2VuZXJhdG9yIiwiZ2VuZXJhdG9yQ3R4IiwiZnJhbWVDb3VudCIsInNhbXBsZVJhdGUiLCJCVUZGRVJfU0laRSIsImF1ZGlvQ29udGV4dCIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNjcmlwdE5vZGUiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImJ1ZmZlciIsIm91dHB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaSIsImxlbmd0aCIsInVwZGF0ZSIsInZhbHVlIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiZGlzY29ubmVjdCIsImNsb3NlIiwic2FtcGxlVXBvbiIsInRvU2FtcGxlIiwidXBvbkV2dCIsImluaXRpYWxWYWx1ZSIsImhlbGQiLCJ1cG9uIiwiZXZlcnlTZWNvbmQiLCJ0aWNrRXZ0IiwiZW1pdFRpY2siLCJvbkludGVydmFsIiwidGltZXJJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImxvYWRBdWRpb0FzQXJyYXkiLCJ1cmwiLCJwY20iLCJhdWRpb0N0eCIsImNsZWFuZWRVcCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJhdWRpb0RhdGEiLCJyZXNwb25zZSIsImRlY29kZUF1ZGlvRGF0YSIsInNlbmQiLCJhYm9ydCIsImNvbnNvbGVMb2ciLCJjb25zb2xlIiwibG9nIiwiaW50ZWdyYWwiLCJpbnRlZ3JhbmRGdW5jIiwiYWNjdW0iLCJwcmV2VGltZSIsImludGVncmFuZCIsImV4cEZvbGxvdyIsInRhcmdldFZhbHVlIiwic3BlZWRDb25zdGFudCIsImN1cnJlbnRWYWx1ZSIsInJlZENpcmNsZSIsInJhZGl1cyIsInAiLCJoYWxmUmFkaXVzIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZm9sbG93QXRTcGVlZDJkIiwidGFyZ2V0Iiwic3BlZWQiLCJpbml0aWFsIiwicG9zIiwiZHQiLCJkZWx0YSIsImRpc3QiLCJzcXJ0IiwiZXZlbnRXaGVuIiwiY29uZGl0aW9uIiwidmFsdWVUb0VtaXQiLCJwcmV2Q29uZGl0aW9uIiwiYmNvbmQiLCJyZXR2YWwiLCJldmVudEFmdGVyIiwic2Vjb25kcyIsImV2dCIsImVtaXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibmFtZSIsIm1haW4iLCJ0b0ZpeGVkIiwibWQiLCJhdWRpb1RpbWUiLCJhZHZhbmNlRnJhbWVFdnQiLCJub2lzZSIsImxhc3RDbGlja1RpbWUiLCJJbmZpbml0eSIsImRlY2F5aW5nR2FpbiIsImV4cCIsImNsaWNrIiwiY3JlYXRlQ291bnRlciIsImFjdGl2ZUNvdW50ZXIiLCJ0ZXJtaW5hdGUiLCJkaXNwbGF5ZWRDb3VudCIsImNyZWF0ZUNsb2NrIiwiY2xvY2tBcnJheSIsInB1c2giLCJudW1zIiwibWFwIiwiY2xvY2siLCJqb2luIiwidGFyZ2V0U3BlZWQiLCJmbG9vciIsIm1wb3MiLCJtaWRwb2ludCIsImEiLCJiIiwiY3BvcyIsImFjdGlvbiIsInByZXZTdGF0ZSIsIm1vdmluZyIsImluaXRpYWxQb3NpdGlvbiIsInRhcmdldFBvc2l0aW9uIiwiYXJyaXZlZCIsInJlc3RpbmciLCJwcm9ncmFtTGlzdEVsZW0iLCJnZXRFbGVtZW50QnlJZCIsInByb2dyYW1Tb3VyY2VFbGVtIiwiY3VycmVudENvbnRleHQiLCJmaXhJbmRlbnQiLCJjb2RlIiwic3BsaXQiLCJsaW5lIiwiaWR4Iiwic3Vic3RyIiwic3RhcnRQcm9ncmFtIiwicHJvZ3JhbSIsImNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IiwicHJvZyIsInByb2dyYW1zIiwiYW5jaG9yRWxlbSIsInNldEF0dHJpYnV0ZSIsInByZXZlbnREZWZhdWx0IiwiaXRlbUVsZW0iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0EsTUFBTTtBQUFFQSxRQUFGO0FBQVVDLGtCQUFWO0FBQTRCQyxlQUE1QjtBQUEyQ0Msc0JBQTNDO0FBQWlFQyxrQkFBakU7QUFBbUZDLFlBQW5GO0FBQStGQyxZQUEvRjtBQUEyR0M7QUFBM0csSUFBMEhDLG1CQUFPLENBQUMsQ0FBRCxDQUF2STs7QUFDQSxNQUFNQyxjQUFjLEdBQUdELG1CQUFPLENBQUMsQ0FBRCxDQUE5Qjs7QUFFQSxTQUFTRSxVQUFULENBQW9CQyxDQUFwQixFQUF1QjtBQUNyQixRQUFNQyxJQUFJLEdBQUdaLE1BQU0sQ0FBQyxJQUFELENBQW5CO0FBRUFFLGVBQWEsQ0FBQyxNQUFNO0FBQ2xCVSxRQUFJLENBQUNDLE9BQUwsR0FBZUMsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWY7QUFDQUgsUUFBSSxDQUFDQyxPQUFMLENBQWFHLEtBQWIsQ0FBbUJDLE9BQW5CLEdBQTZCLHNGQUE3QjtBQUNBTCxRQUFJLENBQUNDLE9BQUwsQ0FBYUssV0FBYixHQUEyQixhQUEzQjtBQUNBSixZQUFRLENBQUNLLElBQVQsQ0FBY0MsV0FBZCxDQUEwQlIsSUFBSSxDQUFDQyxPQUEvQjtBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2JDLGNBQVEsQ0FBQ0ssSUFBVCxDQUFjRSxXQUFkLENBQTBCVCxJQUFJLENBQUNDLE9BQS9CO0FBQ0QsS0FGRDtBQUdELEdBVFksQ0FBYjtBQVdBRCxNQUFJLENBQUNDLE9BQUwsQ0FBYUssV0FBYixHQUEyQixrQkFBbUJQLENBQUMsS0FBS1csU0FBUCxHQUFvQixhQUFwQixHQUFvQ1gsQ0FBQyxDQUFDWSxRQUFGLEVBQXRELENBQTNCO0FBQ0Q7O0FBRUQsU0FBU0MsYUFBVCxHQUF5QjtBQUN2QixRQUFNQyxhQUFhLEdBQUd4QixnQkFBZ0IsRUFBdEM7QUFDQSxRQUFNeUIsSUFBSSxHQUFHMUIsTUFBTSxFQUFuQjtBQUNBLFFBQU0yQixLQUFLLEdBQUczQixNQUFNLEVBQXBCO0FBRUFFLGVBQWEsQ0FBQyxNQUFNO0FBQ2xCLFVBQU0wQixPQUFPLEdBQUlDLENBQUQsSUFBTztBQUNyQkgsVUFBSSxDQUFDYixPQUFMLEdBQWUsUUFBTWdCLENBQXJCO0FBQ0FGLFdBQUssQ0FBQ2QsT0FBTixHQUFnQmlCLHFCQUFxQixDQUFDRixPQUFELENBQXJDLENBRnFCLENBRTJCOztBQUNoREgsbUJBQWE7QUFDZCxLQUpEOztBQU1BQyxRQUFJLENBQUNiLE9BQUwsR0FBZSxRQUFNa0IsV0FBVyxDQUFDQyxHQUFaLEVBQXJCO0FBQ0FMLFNBQUssQ0FBQ2QsT0FBTixHQUFnQmlCLHFCQUFxQixDQUFDRixPQUFELENBQXJDO0FBRUEsV0FBTyxNQUFNO0FBQUU7QUFDYkssMEJBQW9CLENBQUNOLEtBQUssQ0FBQ2QsT0FBUCxDQUFwQjtBQUNELEtBRkQ7QUFHRCxHQWJZLENBQWI7QUFlQSxTQUFPYSxJQUFJLENBQUNiLE9BQVo7QUFDRDs7QUFFRCxTQUFTcUIsa0JBQVQsR0FBOEI7QUFDNUIsUUFBTVQsYUFBYSxHQUFHeEIsZ0JBQWdCLEVBQXRDO0FBQ0EsUUFBTTBCLEtBQUssR0FBRzNCLE1BQU0sRUFBcEI7QUFDQSxRQUFNLENBQUNtQyxTQUFELEVBQVlDLFNBQVosSUFBeUJqQyxvQkFBb0IsRUFBbkQ7QUFFQUQsZUFBYSxDQUFDLE1BQU07QUFDbEIsVUFBTTBCLE9BQU8sR0FBSUMsQ0FBRCxJQUFPO0FBQ3JCTyxlQUFTO0FBQ1RULFdBQUssQ0FBQ2QsT0FBTixHQUFnQmlCLHFCQUFxQixDQUFDRixPQUFELENBQXJDLENBRnFCLENBRTJCOztBQUNoREgsbUJBQWE7QUFDZCxLQUpEOztBQU1BRSxTQUFLLENBQUNkLE9BQU4sR0FBZ0JpQixxQkFBcUIsQ0FBQ0YsT0FBRCxDQUFyQztBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2JLLDBCQUFvQixDQUFDTixLQUFLLENBQUNkLE9BQVAsQ0FBcEI7QUFDRCxLQUZEO0FBR0QsR0FaWSxDQUFiO0FBY0EsU0FBT3NCLFNBQVA7QUFDRDs7QUFFRCxTQUFTRSxXQUFULENBQXFCQyxJQUFyQixFQUEyQjtBQUN6QixRQUFNQyxLQUFLLEdBQUd2QyxNQUFNLENBQUMsQ0FBRCxDQUFwQjtBQUNBLFFBQU13QyxLQUFLLEdBQUdwQyxnQkFBZ0IsQ0FBQ2tDLElBQUQsQ0FBOUI7O0FBRUEsTUFBSUUsS0FBSixFQUFXO0FBQ1RELFNBQUssQ0FBQzFCLE9BQU47QUFDRDs7QUFFRCxTQUFPMEIsS0FBSyxDQUFDMUIsT0FBYjtBQUNEOztBQUVELFNBQVM0QixjQUFULEdBQTBCO0FBQ3hCLFFBQU1oQixhQUFhLEdBQUd4QixnQkFBZ0IsRUFBdEM7QUFDQSxRQUFNLENBQUN5QyxRQUFELEVBQVdDLFNBQVgsSUFBd0J4QyxvQkFBb0IsRUFBbEQ7QUFFQUQsZUFBYSxDQUFDLE1BQU07QUFDbEIsVUFBTTBDLFdBQVcsR0FBRyxNQUFNO0FBQ3hCRCxlQUFTO0FBQ1RsQixtQkFBYTtBQUNkLEtBSEQ7O0FBSUFYLFlBQVEsQ0FBQytCLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDRCxXQUF2QztBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2I5QixjQUFRLENBQUNnQyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQ0YsV0FBMUM7QUFDRCxLQUZEO0FBR0QsR0FWWSxDQUFiO0FBWUEsU0FBT0YsUUFBUDtBQUNEOztBQUVELFNBQVNLLFNBQVQsR0FBcUI7QUFDbkIsUUFBTXRCLGFBQWEsR0FBR3hCLGdCQUFnQixFQUF0QztBQUNBLFFBQU0rQyxNQUFNLEdBQUdoRCxNQUFNLENBQUMsS0FBRCxDQUFyQixDQUZtQixDQUVXOztBQUU5QkUsZUFBYSxDQUFDLE1BQU07QUFDbEIsVUFBTTBDLFdBQVcsR0FBRyxNQUFNO0FBQ3hCSSxZQUFNLENBQUNuQyxPQUFQLEdBQWlCLElBQWpCO0FBQ0FZLG1CQUFhO0FBQ2QsS0FIRDs7QUFJQSxVQUFNd0IsU0FBUyxHQUFHLE1BQU07QUFDdEJELFlBQU0sQ0FBQ25DLE9BQVAsR0FBaUIsS0FBakI7QUFDQVksbUJBQWE7QUFDZCxLQUhEOztBQUtBWCxZQUFRLENBQUMrQixnQkFBVCxDQUEwQixXQUExQixFQUF1Q0QsV0FBdkM7QUFDQTlCLFlBQVEsQ0FBQytCLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDSSxTQUFyQztBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2JuQyxjQUFRLENBQUNnQyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQ0YsV0FBMUM7QUFDQTlCLGNBQVEsQ0FBQ2dDLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDRyxTQUF4QztBQUNELEtBSEQ7QUFJRCxHQWpCWSxDQUFiO0FBbUJBLFNBQU9ELE1BQU0sQ0FBQ25DLE9BQWQ7QUFDRDs7QUFFRCxTQUFTcUMsYUFBVCxHQUF5QjtBQUN2QixRQUFNekIsYUFBYSxHQUFHeEIsZ0JBQWdCLEVBQXRDO0FBQ0EsUUFBTWtELFFBQVEsR0FBR25ELE1BQU0sQ0FBQztBQUFDb0QsS0FBQyxFQUFFLENBQUo7QUFBT0MsS0FBQyxFQUFFO0FBQVYsR0FBRCxDQUF2QixDQUZ1QixDQUVnQjs7QUFFdkNuRCxlQUFhLENBQUMsTUFBTTtBQUNsQixVQUFNb0QsV0FBVyxHQUFJQyxDQUFELElBQU87QUFDekJKLGNBQVEsQ0FBQ3RDLE9BQVQsR0FBbUI7QUFDakJ1QyxTQUFDLEVBQUVHLENBQUMsQ0FBQ0MsT0FBRixJQUFhRCxDQUFDLENBQUNFLEtBREQ7QUFFakJKLFNBQUMsRUFBRUUsQ0FBQyxDQUFDRyxPQUFGLElBQWFILENBQUMsQ0FBQ0k7QUFGRCxPQUFuQjtBQUlBbEMsbUJBQWE7QUFDZCxLQU5EOztBQVFBWCxZQUFRLENBQUMrQixnQkFBVCxDQUEwQixXQUExQixFQUF1Q1MsV0FBdkM7QUFFQSxXQUFPLE1BQU07QUFBRTtBQUNieEMsY0FBUSxDQUFDZ0MsbUJBQVQsQ0FBNkIsV0FBN0IsRUFBMENRLFdBQTFDO0FBQ0QsS0FGRDtBQUdELEdBZFksQ0FBYjtBQWdCQSxTQUFPSCxRQUFRLENBQUN0QyxPQUFoQjtBQUNEOztBQUVELFNBQVMrQyxNQUFULENBQWdCQyxTQUFoQixFQUEyQjtBQUN6QixRQUFNQyxHQUFHLEdBQUc5RCxNQUFNLENBQUMrRCxJQUFJLENBQUNILE1BQUwsRUFBRCxDQUFsQjtBQUNBLFFBQU1JLE1BQU0sR0FBRzVELGdCQUFnQixDQUFDeUQsU0FBRCxDQUEvQjs7QUFFQSxNQUFJRyxNQUFKLEVBQVk7QUFDVkYsT0FBRyxDQUFDakQsT0FBSixHQUFja0QsSUFBSSxDQUFDSCxNQUFMLEVBQWQ7QUFDRDs7QUFFRCxTQUFPRSxHQUFHLENBQUNqRCxPQUFYO0FBQ0Q7O0FBRUQsU0FBU29ELFdBQVQsQ0FBcUJDLFNBQXJCLEVBQWdDO0FBQzlCLFFBQU1DLGVBQWUsR0FBRzlELFVBQVUsQ0FBQzZELFNBQUQsQ0FBbEM7QUFDQSxRQUFNRSxZQUFZLEdBQUdwRSxNQUFNLEVBQTNCO0FBQ0EsUUFBTXFFLFVBQVUsR0FBR3JFLE1BQU0sQ0FBQyxDQUFELENBQXpCO0FBQ0EsUUFBTXNFLFVBQVUsR0FBR3RFLE1BQU0sRUFBekI7QUFFQUUsZUFBYSxDQUFDLE1BQU07QUFDbEJrRSxnQkFBWSxDQUFDdkQsT0FBYixHQUF1QnNELGVBQWUsRUFBdEM7QUFFQSxVQUFNSSxXQUFXLEdBQUcsSUFBcEI7QUFDQSxVQUFNQyxZQUFZLEdBQUcsS0FBS0MsTUFBTSxDQUFDQyxZQUFQLElBQXVCRCxNQUFNLENBQUNFLGtCQUFuQyxHQUFyQjtBQUNBLFVBQU1DLFVBQVUsR0FBR0osWUFBWSxDQUFDSyxxQkFBYixDQUFtQ04sV0FBbkMsRUFBZ0QsQ0FBaEQsRUFBbUQsQ0FBbkQsQ0FBbkIsQ0FMa0IsQ0FLd0Q7O0FBQzFFSyxjQUFVLENBQUNFLGNBQVgsR0FBNkJ2QixDQUFELElBQU87QUFDakMsWUFBTXdCLE1BQU0sR0FBR3hCLENBQUMsQ0FBQ3lCLFlBQUYsQ0FBZUMsY0FBZixDQUE4QixDQUE5QixDQUFmOztBQUNBLFdBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0gsTUFBTSxDQUFDSSxNQUEzQixFQUFtQ0QsQ0FBQyxFQUFwQyxFQUF3QztBQUN0Q0gsY0FBTSxDQUFDRyxDQUFELENBQU4sR0FBWWQsWUFBWSxDQUFDdkQsT0FBYixDQUFxQnVFLE1BQXJCLENBQTRCZixVQUFVLENBQUN4RCxPQUFYLEdBQW1CeUQsVUFBVSxDQUFDekQsT0FBMUQsRUFBbUU7QUFBQ3dFLGVBQUssRUFBRS9EO0FBQVIsU0FBbkUsRUFBdUZnRCxVQUFVLENBQUN6RCxPQUFsRyxDQUFaO0FBQ0F3RCxrQkFBVSxDQUFDeEQsT0FBWDtBQUNEO0FBQ0YsS0FORDs7QUFPQStELGNBQVUsQ0FBQ1UsT0FBWCxDQUFtQmQsWUFBWSxDQUFDZSxXQUFoQztBQUVBakIsY0FBVSxDQUFDekQsT0FBWCxHQUFxQjJELFlBQVksQ0FBQ0YsVUFBbEM7QUFFQSxXQUFPLE1BQU07QUFDWE0sZ0JBQVUsQ0FBQ1ksVUFBWDtBQUNBaEIsa0JBQVksQ0FBQ2lCLEtBQWI7QUFDRCxLQUhEO0FBSUQsR0FyQlksQ0FBYjtBQXVCQTs7Ozs7OztBQU1BckIsY0FBWSxDQUFDdkQsT0FBYixDQUFxQnVFLE1BQXJCLENBQTRCZixVQUFVLENBQUN4RCxPQUFYLEdBQW1CeUQsVUFBVSxDQUFDekQsT0FBMUQsRUFBbUVTLFNBQW5FLEVBQThFZ0QsVUFBVSxDQUFDekQsT0FBekYsRUFuQzhCLENBbUNxRTtBQUNwRzs7QUFFRCxTQUFTNkUsVUFBVCxDQUFvQkMsUUFBcEIsRUFBOEJDLE9BQTlCLEVBQXVDQyxZQUF2QyxFQUFxRDtBQUNuRCxRQUFNQyxJQUFJLEdBQUc5RixNQUFNLENBQUM2RixZQUFELENBQW5CO0FBQ0EsUUFBTUUsSUFBSSxHQUFHM0YsZ0JBQWdCLENBQUN3RixPQUFELENBQTdCOztBQUVBLE1BQUlHLElBQUosRUFBVTtBQUNSRCxRQUFJLENBQUNqRixPQUFMLEdBQWU4RSxRQUFmO0FBQ0Q7O0FBRUQsU0FBT0csSUFBSSxDQUFDakYsT0FBWjtBQUNEOztBQUVELFNBQVNtRixXQUFULEdBQXVCO0FBQ3JCLFFBQU12RSxhQUFhLEdBQUd4QixnQkFBZ0IsRUFBdEM7QUFDQSxRQUFNLENBQUNnRyxPQUFELEVBQVVDLFFBQVYsSUFBc0IvRixvQkFBb0IsRUFBaEQ7QUFFQUQsZUFBYSxDQUFDLE1BQU07QUFDbEIsVUFBTWlHLFVBQVUsR0FBRyxNQUFNO0FBQ3ZCRCxjQUFRO0FBQ1J6RSxtQkFBYTtBQUNkLEtBSEQ7O0FBSUEsVUFBTTJFLE9BQU8sR0FBR0MsV0FBVyxDQUFDRixVQUFELEVBQWEsSUFBYixDQUEzQjtBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2JHLG1CQUFhLENBQUNGLE9BQUQsQ0FBYjtBQUNELEtBRkQ7QUFHRCxHQVZZLENBQWI7QUFZQSxTQUFPSCxPQUFQO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxTQUFTTSxnQkFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsUUFBTS9FLGFBQWEsR0FBR3hCLGdCQUFnQixFQUF0QztBQUNBLFFBQU13RyxHQUFHLEdBQUd6RyxNQUFNLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBbEIsQ0FGNkIsQ0FFSjs7QUFFekJFLGVBQWEsQ0FBQyxNQUFNO0FBQ2xCLFVBQU13RyxRQUFRLEdBQUcsS0FBS2pDLE1BQU0sQ0FBQ0MsWUFBUCxJQUF1QkQsTUFBTSxDQUFDRSxrQkFBbkMsR0FBakI7QUFDQSxRQUFJZ0MsU0FBUyxHQUFHLEtBQWhCO0FBRUEsVUFBTUMsT0FBTyxHQUFHLElBQUlDLGNBQUosRUFBaEI7QUFDQUQsV0FBTyxDQUFDRSxJQUFSLENBQWEsS0FBYixFQUFvQk4sR0FBcEIsRUFBeUIsSUFBekI7QUFDQUksV0FBTyxDQUFDRyxZQUFSLEdBQXVCLGFBQXZCOztBQUNBSCxXQUFPLENBQUNJLE1BQVIsR0FBaUIsTUFBTTtBQUNyQixZQUFNQyxTQUFTLEdBQUdMLE9BQU8sQ0FBQ00sUUFBMUI7QUFDQVIsY0FBUSxDQUFDUyxlQUFULENBQXlCRixTQUF6QixFQUFvQ2xDLE1BQU0sSUFBSTtBQUM1QyxZQUFJLENBQUM0QixTQUFMLEVBQWdCO0FBQ2RGLGFBQUcsQ0FBQzVGLE9BQUosR0FBY2tFLE1BQU0sQ0FBQ0UsY0FBUCxDQUFzQixDQUF0QixDQUFkO0FBQ0F4RCx1QkFBYTtBQUNkO0FBQ0YsT0FMRDtBQU1ELEtBUkQ7O0FBVUFtRixXQUFPLENBQUNRLElBQVI7QUFFQSxXQUFPLE1BQU07QUFBRTtBQUNiUixhQUFPLENBQUNTLEtBQVIsR0FEVyxDQUNNO0FBRWpCO0FBQ0E7O0FBQ0FWLGVBQVMsR0FBRyxJQUFaO0FBQ0QsS0FORDtBQU9ELEdBMUJZLENBQWI7QUE0QkEsU0FBT0YsR0FBRyxDQUFDNUYsT0FBWDtBQUNEOztBQUVELFNBQVN5RyxVQUFULENBQW9CM0csQ0FBcEIsRUFBdUI7QUFDckI0RyxTQUFPLENBQUNDLEdBQVIsQ0FBWTdHLENBQVo7QUFDRDs7QUFFRCxTQUFTOEcsUUFBVCxDQUFrQkMsYUFBbEIsRUFBaUNoRyxJQUFqQyxFQUF1Q21FLFlBQVksR0FBRyxDQUF0RCxFQUF5RDtBQUN2RCxRQUFNOEIsS0FBSyxHQUFHM0gsTUFBTSxDQUFDNkYsWUFBRCxDQUFwQjtBQUNBLFFBQU0rQixRQUFRLEdBQUc1SCxNQUFNLENBQUMwQixJQUFELENBQXZCO0FBRUEsUUFBTW1HLFNBQVMsR0FBR0gsYUFBYSxDQUFDQyxLQUFLLENBQUM5RyxPQUFQLEVBQWdCK0csUUFBUSxDQUFDL0csT0FBekIsQ0FBL0I7QUFDQThHLE9BQUssQ0FBQzlHLE9BQU4sSUFBaUIsQ0FBQ2EsSUFBSSxHQUFHa0csUUFBUSxDQUFDL0csT0FBakIsSUFBMEJnSCxTQUEzQztBQUVBRCxVQUFRLENBQUMvRyxPQUFULEdBQW1CYSxJQUFuQjtBQUVBLFNBQU9pRyxLQUFLLENBQUM5RyxPQUFiO0FBQ0Q7O0FBRUQsU0FBU2lILFNBQVQsQ0FBbUJDLFdBQW5CLEVBQWdDQyxhQUFoQyxFQUErQ3RHLElBQS9DLEVBQXFEbUUsWUFBckQsRUFBbUU7QUFDakUsU0FBTzRCLFFBQVEsQ0FBQ1EsWUFBWSxJQUFJRCxhQUFhLElBQUVELFdBQVcsR0FBR0UsWUFBaEIsQ0FBOUIsRUFBNkR2RyxJQUE3RCxFQUFtRW1FLFlBQW5FLENBQWY7QUFDRDs7QUFFRCxTQUFTcUMsU0FBVCxDQUFtQi9FLFFBQW5CLEVBQTZCZ0YsTUFBTSxHQUFHLEVBQXRDLEVBQTBDO0FBQ3hDLFFBQU12SCxJQUFJLEdBQUdaLE1BQU0sQ0FBQyxJQUFELENBQW5CO0FBRUFFLGVBQWEsQ0FBQyxNQUFNO0FBQ2xCVSxRQUFJLENBQUNDLE9BQUwsR0FBZUMsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWY7QUFDQUgsUUFBSSxDQUFDQyxPQUFMLENBQWFHLEtBQWIsQ0FBbUJDLE9BQW5CLEdBQTZCLGtHQUE3QjtBQUNBSCxZQUFRLENBQUNLLElBQVQsQ0FBY0MsV0FBZCxDQUEwQlIsSUFBSSxDQUFDQyxPQUEvQjtBQUVBLFdBQU8sTUFBTTtBQUFFO0FBQ2JDLGNBQVEsQ0FBQ0ssSUFBVCxDQUFjRSxXQUFkLENBQTBCVCxJQUFJLENBQUNDLE9BQS9CO0FBQ0QsS0FGRDtBQUdELEdBUlksQ0FBYjtBQVVBLFFBQU11SCxDQUFDLEdBQUdqRixRQUFRLElBQUk7QUFBQ0MsS0FBQyxFQUFFLENBQUo7QUFBT0MsS0FBQyxFQUFFO0FBQVYsR0FBdEI7O0FBQ0EsTUFBSThFLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQ2RBLFVBQU0sR0FBRyxDQUFUO0FBQ0Q7O0FBQ0QsUUFBTUUsVUFBVSxHQUFHLE1BQUlGLE1BQXZCO0FBRUF2SCxNQUFJLENBQUNDLE9BQUwsQ0FBYUcsS0FBYixDQUFtQnNILElBQW5CLEdBQTJCRixDQUFDLENBQUNoRixDQUFGLEdBQU1pRixVQUFQLEdBQXFCLElBQS9DO0FBQ0F6SCxNQUFJLENBQUNDLE9BQUwsQ0FBYUcsS0FBYixDQUFtQnVILEdBQW5CLEdBQTBCSCxDQUFDLENBQUMvRSxDQUFGLEdBQU1nRixVQUFQLEdBQXFCLElBQTlDO0FBQ0F6SCxNQUFJLENBQUNDLE9BQUwsQ0FBYUcsS0FBYixDQUFtQndILEtBQW5CLEdBQTJCTCxNQUFNLEdBQUcsSUFBcEM7QUFDQXZILE1BQUksQ0FBQ0MsT0FBTCxDQUFhRyxLQUFiLENBQW1CeUgsTUFBbkIsR0FBNEJOLE1BQU0sR0FBRyxJQUFyQztBQUNEOztBQUVELFNBQVNPLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQWlDQyxLQUFqQyxFQUF3Q2xILElBQXhDLEVBQThDbUgsT0FBOUMsRUFBdUQ7QUFDckQsUUFBTUMsR0FBRyxHQUFHOUksTUFBTSxDQUFDNkksT0FBRCxDQUFsQjtBQUNBLFFBQU1qQixRQUFRLEdBQUc1SCxNQUFNLENBQUMwQixJQUFELENBQXZCO0FBRUEsUUFBTXFILEVBQUUsR0FBR3JILElBQUksR0FBR2tHLFFBQVEsQ0FBQy9HLE9BQTNCO0FBQ0EsUUFBTW1JLEtBQUssR0FBRztBQUFDNUYsS0FBQyxFQUFFdUYsTUFBTSxDQUFDdkYsQ0FBUCxHQUFTMEYsR0FBRyxDQUFDakksT0FBSixDQUFZdUMsQ0FBekI7QUFBNEJDLEtBQUMsRUFBRXNGLE1BQU0sQ0FBQ3RGLENBQVAsR0FBU3lGLEdBQUcsQ0FBQ2pJLE9BQUosQ0FBWXdDO0FBQXBELEdBQWQ7QUFDQSxRQUFNNEYsSUFBSSxHQUFHbEYsSUFBSSxDQUFDbUYsSUFBTCxDQUFVRixLQUFLLENBQUM1RixDQUFOLEdBQVE0RixLQUFLLENBQUM1RixDQUFkLEdBQWtCNEYsS0FBSyxDQUFDM0YsQ0FBTixHQUFRMkYsS0FBSyxDQUFDM0YsQ0FBMUMsQ0FBYjs7QUFDQSxNQUFJdUYsS0FBSyxHQUFDRyxFQUFOLElBQVlFLElBQWhCLEVBQXNCO0FBQ3BCO0FBQ0FILE9BQUcsQ0FBQ2pJLE9BQUosR0FBYzhILE1BQWQ7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBRyxPQUFHLENBQUNqSSxPQUFKLEdBQWM7QUFDWnVDLE9BQUMsRUFBRTBGLEdBQUcsQ0FBQ2pJLE9BQUosQ0FBWXVDLENBQVosR0FBZ0IyRixFQUFFLEdBQUNILEtBQUgsR0FBU0ksS0FBSyxDQUFDNUYsQ0FBZixHQUFpQjZGLElBRHhCO0FBRVo1RixPQUFDLEVBQUV5RixHQUFHLENBQUNqSSxPQUFKLENBQVl3QyxDQUFaLEdBQWdCMEYsRUFBRSxHQUFDSCxLQUFILEdBQVNJLEtBQUssQ0FBQzNGLENBQWYsR0FBaUI0RjtBQUZ4QixLQUFkO0FBSUQ7O0FBRURyQixVQUFRLENBQUMvRyxPQUFULEdBQW1CYSxJQUFuQjtBQUVBLFNBQU9vSCxHQUFHLENBQUNqSSxPQUFYO0FBQ0Q7QUFFRDs7Ozs7QUFHQSxTQUFTc0ksU0FBVCxDQUFtQkMsU0FBbkIsRUFBOEJDLFdBQTlCLEVBQTJDO0FBQ3pDLFFBQU1DLGFBQWEsR0FBR3RKLE1BQU0sQ0FBQyxLQUFELENBQTVCO0FBRUEsUUFBTXVKLEtBQUssR0FBRyxDQUFDLENBQUNILFNBQWhCO0FBRUEsUUFBTUksTUFBTSxHQUFJRCxLQUFLLElBQUksQ0FBQ0QsYUFBYSxDQUFDekksT0FBekIsR0FBb0M7QUFBQ3dFLFNBQUssRUFBRWdFO0FBQVIsR0FBcEMsR0FBMkQvSCxTQUExRTtBQUNBZ0ksZUFBYSxDQUFDekksT0FBZCxHQUF3QjBJLEtBQXhCO0FBRUEsU0FBT0MsTUFBUDtBQUNEO0FBRUQ7Ozs7O0FBR0EsU0FBU0MsVUFBVCxDQUFvQkMsT0FBcEIsRUFBNkJMLFdBQTdCLEVBQTBDO0FBQ3hDLFFBQU0sQ0FBQ00sR0FBRCxFQUFNQyxJQUFOLElBQWN6SixvQkFBb0IsRUFBeEM7QUFDQSxRQUFNa0YsS0FBSyxHQUFHckYsTUFBTSxDQUFDcUosV0FBRCxDQUFwQjtBQUVBaEUsT0FBSyxDQUFDeEUsT0FBTixHQUFnQndJLFdBQWhCO0FBRUFuSixlQUFhLENBQUMsTUFBTTtBQUNsQixVQUFNa0csT0FBTyxHQUFHeUQsVUFBVSxDQUFDLE1BQU07QUFDL0JELFVBQUksQ0FBQ3ZFLEtBQUssQ0FBQ3hFLE9BQVAsQ0FBSjtBQUNELEtBRnlCLEVBRXZCLE9BQUs2SSxPQUZrQixDQUExQjtBQUdBLFdBQU8sTUFBTTtBQUNYSSxrQkFBWSxDQUFDMUQsT0FBRCxDQUFaO0FBQ0QsS0FGRDtBQUdELEdBUFksQ0FBYjtBQVNBLFNBQU91RCxHQUFQO0FBQ0Q7O0FBRWMsOENBQ2I7QUFDRUksTUFBSSxFQUFFLFlBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU0sQ0FDWDtBQUhILENBRGEsRUFPYjtBQUNFRCxNQUFJLEVBQUUsZ0JBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVnRKLGNBQVUsQ0FBQ2MsYUFBYSxHQUFHeUksT0FBaEIsQ0FBd0IsQ0FBeEIsQ0FBRCxDQUFWO0FBQ0Q7QUFKSCxDQVBhLEVBY2I7QUFDRUYsTUFBSSxFQUFFLGNBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVnRKLGNBQVUsQ0FBQzJCLFdBQVcsQ0FBQ0ksY0FBYyxFQUFmLENBQVosQ0FBVjtBQUNEO0FBSkgsQ0FkYSxFQXFCYjtBQUNFc0gsTUFBSSxFQUFFLHNCQURSO0FBRUVDLE1BQUksRUFBRSxNQUFNO0FBQ1Z0SixjQUFVLENBQUNxQyxTQUFTLEVBQVYsQ0FBVjtBQUNEO0FBSkgsQ0FyQmEsRUE0QmI7QUFDRWdILE1BQUksRUFBRSxnQ0FEUjtBQUVFQyxNQUFJLEVBQUUsTUFBTTtBQUNWdEosY0FBVSxDQUFDa0QsTUFBTSxDQUFDbkIsY0FBYyxFQUFmLENBQVAsQ0FBVjtBQUNEO0FBSkgsQ0E1QmEsRUFtQ2I7QUFDRXNILE1BQUksRUFBRSxnQ0FEUjtBQUVFQyxNQUFJLEVBQUUsTUFBTTtBQUNWLFVBQU1FLEVBQUUsR0FBR25ILFNBQVMsRUFBcEI7QUFDQWtCLGVBQVcsQ0FBQyxDQUFDa0csU0FBRCxFQUFZQyxlQUFaLEtBQWdDO0FBQzFDLFlBQU1DLEtBQUssR0FBR3pHLE1BQU0sQ0FBQ3dHLGVBQUQsQ0FBTixHQUEwQixHQUF4QztBQUNBLGFBQU9GLEVBQUUsR0FBR0csS0FBSCxHQUFXLENBQXBCO0FBQ0QsS0FIVSxDQUFYO0FBSUQ7QUFSSCxDQW5DYSxFQThDYjtBQUNFTixNQUFJLEVBQUUsMkJBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVixVQUFNdEgsUUFBUSxHQUFHRCxjQUFjLEVBQS9CO0FBQ0F3QixlQUFXLENBQUMsQ0FBQ2tHLFNBQUQsRUFBWUMsZUFBWixLQUFnQztBQUMxQyxZQUFNQyxLQUFLLEdBQUd6RyxNQUFNLENBQUN3RyxlQUFELENBQU4sR0FBMEIsR0FBeEM7QUFDQSxZQUFNRSxhQUFhLEdBQUc1RSxVQUFVLENBQUN5RSxTQUFELEVBQVl6SCxRQUFaLEVBQXNCLENBQUM2SCxRQUF2QixDQUFoQztBQUNBLFlBQU1DLFlBQVksR0FBR3pHLElBQUksQ0FBQzBHLEdBQUwsQ0FBUyxLQUFHSCxhQUFhLEdBQUdILFNBQW5CLENBQVQsQ0FBckI7QUFDQSxhQUFPSyxZQUFZLEdBQUNILEtBQXBCO0FBQ0QsS0FMVSxDQUFYO0FBTUQ7QUFWSCxDQTlDYSxFQTJEYjtBQUNFTixNQUFJLEVBQUUseUNBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVixVQUFNN0gsU0FBUyxHQUFHRCxrQkFBa0IsRUFBcEM7QUFDQSxVQUFNUSxRQUFRLEdBQUdELGNBQWMsRUFBL0I7QUFDQSxVQUFNaUksS0FBSyxHQUFHdEssZ0JBQWdCLENBQUNzQyxRQUFELENBQTlCO0FBQ0EsVUFBTWlJLGFBQWEsR0FBR3RLLFVBQVUsQ0FBQ2dDLFdBQUQsQ0FBaEM7QUFDQSxVQUFNdUksYUFBYSxHQUFHNUssTUFBTSxFQUE1Qjs7QUFFQSxRQUFJMEssS0FBSixFQUFXO0FBQ1QsVUFBSUUsYUFBYSxDQUFDL0osT0FBbEIsRUFBMkI7QUFDekIrSixxQkFBYSxDQUFDL0osT0FBZCxDQUFzQmdLLFNBQXRCO0FBQ0Q7O0FBQ0RELG1CQUFhLENBQUMvSixPQUFkLEdBQXdCOEosYUFBYSxFQUFyQztBQUNEOztBQUNELFFBQUksQ0FBQ0MsYUFBYSxDQUFDL0osT0FBbkIsRUFBNEI7QUFDMUIrSixtQkFBYSxDQUFDL0osT0FBZCxHQUF3QjhKLGFBQWEsRUFBckM7QUFDRDs7QUFFRCxVQUFNRyxjQUFjLEdBQUdGLGFBQWEsQ0FBQy9KLE9BQWQsQ0FBc0J1RSxNQUF0QixDQUE2QmpELFNBQTdCLENBQXZCO0FBQ0F6QixjQUFVLENBQUNvSyxjQUFELENBQVY7QUFDRDtBQXJCSCxDQTNEYSxFQW1GYjtBQUNFZixNQUFJLEVBQUUsNkNBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVixVQUFNdEgsUUFBUSxHQUFHRCxjQUFjLEVBQS9CO0FBQ0EsVUFBTWlJLEtBQUssR0FBR3RLLGdCQUFnQixDQUFDc0MsUUFBRCxDQUE5QjtBQUNBLFVBQU1xSSxXQUFXLEdBQUcxSyxVQUFVLENBQUMsTUFBTWdDLFdBQVcsQ0FBQzJELFdBQVcsRUFBWixDQUFsQixDQUE5QjtBQUNBLFVBQU1nRixVQUFVLEdBQUdoTCxNQUFNLENBQUMsRUFBRCxDQUF6Qjs7QUFFQSxRQUFJMEssS0FBSixFQUFXO0FBQ1RNLGdCQUFVLENBQUNuSyxPQUFYLENBQW1Cb0ssSUFBbkIsQ0FBd0JGLFdBQVcsRUFBbkM7QUFDRDs7QUFFRCxVQUFNRyxJQUFJLEdBQUdGLFVBQVUsQ0FBQ25LLE9BQVgsQ0FBbUJzSyxHQUFuQixDQUF1QkMsS0FBSyxJQUFJQSxLQUFLLENBQUNoRyxNQUFOLEVBQWhDLENBQWI7QUFDQTFFLGNBQVUsQ0FBQ3dLLElBQUksQ0FBQ0csSUFBTCxDQUFVLEdBQVYsQ0FBRCxDQUFWO0FBQ0Q7QUFkSCxDQW5GYSxFQW9HYjtBQUNFdEIsTUFBSSxFQUFFLHlEQURSO0FBRUVDLE1BQUksRUFBRSxNQUFNO0FBQ1YsVUFBTXZELEdBQUcsR0FBR0YsZ0JBQWdCLENBQUM5RixjQUFELENBQTVCO0FBQ0FDLGNBQVUsQ0FBQytGLEdBQUcsQ0FBQ3RCLE1BQUosR0FBYSxDQUFiLEdBQWlCLGNBQWpCLEdBQWtDLGtCQUFuQyxDQUFWO0FBQ0FsQixlQUFXLENBQUMsQ0FBQ2tHLFNBQUQsRUFBWUMsZUFBWixFQUE2QjlGLFVBQTdCLEtBQTRDO0FBQ3RELFlBQU1nSCxXQUFXLEdBQUd2SSxTQUFTLEtBQUt1QixVQUFMLEdBQWtCLENBQS9DO0FBQ0EsWUFBTXNFLEtBQUssR0FBR2QsU0FBUyxDQUFDd0QsV0FBRCxFQUFjLENBQWQsRUFBaUJuQixTQUFqQixFQUE0QixDQUE1QixDQUF2QjtBQUNBLFlBQU1yQixHQUFHLEdBQUcvRSxJQUFJLENBQUN3SCxLQUFMLENBQVc5RCxRQUFRLENBQUMsTUFBTW1CLEtBQVAsRUFBY3VCLFNBQWQsQ0FBbkIsQ0FBWjtBQUNBLGFBQU8xRCxHQUFHLENBQUNxQyxHQUFHLEdBQUdyQyxHQUFHLENBQUN0QixNQUFYLENBQVYsQ0FKc0QsQ0FJeEI7QUFDL0IsS0FMVSxDQUFYO0FBTUQ7QUFYSCxDQXBHYSxFQWtIYjtBQUNFNEUsTUFBSSxFQUFFLHNCQURSO0FBRUVDLE1BQUksRUFBRSxNQUFNO0FBQ1Y5QixhQUFTLENBQUNoRixhQUFhLEVBQWQsQ0FBVDtBQUNEO0FBSkgsQ0FsSGEsRUF5SGI7QUFDRTZHLE1BQUksRUFBRSx1Q0FEUjtBQUVFQyxNQUFJLEVBQUUsTUFBTTtBQUNWLFVBQU10SSxJQUFJLEdBQUdGLGFBQWEsRUFBMUI7QUFDQSxVQUFNZ0ssSUFBSSxHQUFHdEksYUFBYSxFQUExQjtBQUNBZ0YsYUFBUyxDQUFDUSxlQUFlLENBQUM4QyxJQUFELEVBQU8sR0FBUCxFQUFZOUosSUFBWixFQUFrQjhKLElBQWxCLENBQWhCLENBQVQ7QUFDRDtBQU5ILENBekhhLEVBa0liO0FBQ0V6QixNQUFJLEVBQUUsK0NBRFI7QUFFRUMsTUFBSSxFQUFFLE1BQU07QUFDVixVQUFNeUIsUUFBUSxHQUFHLENBQUNDLENBQUQsRUFBSUMsQ0FBSixNQUFXO0FBQUN2SSxPQUFDLEVBQUUsT0FBS3NJLENBQUMsQ0FBQ3RJLENBQUYsR0FBSXVJLENBQUMsQ0FBQ3ZJLENBQVgsQ0FBSjtBQUFtQkMsT0FBQyxFQUFFLE9BQUtxSSxDQUFDLENBQUNySSxDQUFGLEdBQUlzSSxDQUFDLENBQUN0SSxDQUFYO0FBQXRCLEtBQVgsQ0FBakI7O0FBQ0EsVUFBTW1JLElBQUksR0FBR3RJLGFBQWEsRUFBMUI7QUFDQSxVQUFNUixRQUFRLEdBQUdELGNBQWMsRUFBL0I7QUFDQSxVQUFNbUosSUFBSSxHQUFHdEwsVUFBVSxDQUFDb0MsUUFBRCxFQUFXLENBQUNtSixNQUFELEVBQVNDLFNBQVQsS0FBdUI7QUFDdkQsYUFBT0QsTUFBTSxHQUFHSixRQUFRLENBQUNLLFNBQUQsRUFBWU4sSUFBWixDQUFYLEdBQStCTSxTQUE1QztBQUNELEtBRnNCLEVBRXBCO0FBQUMxSSxPQUFDLEVBQUUsQ0FBSjtBQUFPQyxPQUFDLEVBQUU7QUFBVixLQUZvQixDQUF2QjtBQUdBNkUsYUFBUyxDQUFDMEQsSUFBRCxDQUFUO0FBQ0Q7QUFWSCxDQWxJYSxFQStJYjtBQUNFN0IsTUFBSSxFQUFFLGdDQURSO0FBRUVDLE1BQUksRUFBRSxNQUFNO0FBQ1YsVUFBTXRJLElBQUksR0FBR0YsYUFBYSxFQUExQjtBQUNBLFVBQU0yQixRQUFRLEdBQUc1QyxVQUFVLENBQUM7QUFDMUJ3TCxZQUFNLEVBQUdDLGVBQUQsSUFBcUI7QUFDM0IsY0FBTUMsY0FBYyxHQUFHO0FBQUM3SSxXQUFDLEVBQUUsTUFBSVEsTUFBTSxFQUFkO0FBQWtCUCxXQUFDLEVBQUUsTUFBSU8sTUFBTTtBQUEvQixTQUF2QjtBQUNBLGNBQU1ULFFBQVEsR0FBR3VGLGVBQWUsQ0FBQ3VELGNBQUQsRUFBaUIsR0FBakIsRUFBc0J2SyxJQUF0QixFQUE0QnNLLGVBQTVCLENBQWhDO0FBQ0EsY0FBTUUsT0FBTyxHQUFJL0ksUUFBUSxDQUFDQyxDQUFULEtBQWU2SSxjQUFjLENBQUM3SSxDQUEvQixJQUFzQ0QsUUFBUSxDQUFDRSxDQUFULEtBQWU0SSxjQUFjLENBQUM1SSxDQUFwRjtBQUNBLGVBQU8sQ0FDTEYsUUFESyxFQUVMZ0csU0FBUyxDQUFDK0MsT0FBRCxFQUFVLENBQUMsU0FBRCxFQUFZL0ksUUFBWixDQUFWLENBRkosQ0FBUDtBQUlELE9BVHlCO0FBVTFCZ0osYUFBTyxFQUFHSCxlQUFELElBQXFCO0FBQzVCLGVBQU8sQ0FDTEEsZUFESyxFQUVMdkMsVUFBVSxDQUFDN0YsTUFBTSxFQUFQLEVBQVcsQ0FBQyxRQUFELEVBQVdvSSxlQUFYLENBQVgsQ0FGTCxDQUFQO0FBSUQ7QUFmeUIsS0FBRCxFQWdCeEIsQ0FBQyxRQUFELEVBQVc7QUFBQzVJLE9BQUMsRUFBRSxDQUFKO0FBQU9DLE9BQUMsRUFBRTtBQUFWLEtBQVgsQ0FoQndCLENBQTNCO0FBaUJBNkUsYUFBUyxDQUFDL0UsUUFBRCxDQUFUO0FBQ0Q7QUF0QkgsQ0EvSWEsQ0FBZixFOztBQzdXQTtBQUNBO0FBRUEsTUFBTWlKLGVBQWUsR0FBR3RMLFFBQVEsQ0FBQ3VMLGNBQVQsQ0FBd0IsY0FBeEIsQ0FBeEI7QUFDQSxNQUFNQyxpQkFBaUIsR0FBR3hMLFFBQVEsQ0FBQ3VMLGNBQVQsQ0FBd0IsZ0JBQXhCLENBQTFCO0FBRUEsSUFBSUUsY0FBSixDLENBRUE7O0FBQ0EsTUFBTUMsU0FBUyxHQUFJQyxJQUFELElBQVU7QUFDMUIsU0FBT0EsSUFBSSxDQUFDQyxLQUFMLENBQVcsSUFBWCxFQUFpQnZCLEdBQWpCLENBQXFCLENBQUN3QixJQUFELEVBQU9DLEdBQVAsS0FBZ0JBLEdBQUcsS0FBSyxDQUFULEdBQWNELElBQWQsR0FBcUJBLElBQUksQ0FBQ0UsTUFBTCxDQUFZLENBQVosQ0FBekQsRUFBeUV4QixJQUF6RSxDQUE4RSxJQUE5RSxDQUFQO0FBQ0QsQ0FGRDs7QUFJQSxNQUFNeUIsWUFBWSxHQUFJQyxPQUFELElBQWE7QUFDaEMsTUFBSVIsY0FBSixFQUFvQjtBQUNsQkEsa0JBQWMsQ0FBQzFCLFNBQWY7QUFDQTBCLGtCQUFjLEdBQUdqTCxTQUFqQjtBQUNEOztBQUVEZ0wsbUJBQWlCLENBQUNwTCxXQUFsQixHQUFnQ3NMLFNBQVMsQ0FBQ08sT0FBTyxDQUFDL0MsSUFBUixDQUFhekksUUFBYixFQUFELENBQXpDLENBTmdDLENBTW9DOztBQUNwRWdMLGdCQUFjLEdBQUdTLDRDQUE2QixDQUFDRCxPQUFPLENBQUMvQyxJQUFULENBQTlDO0FBQ0F1QyxnQkFBYyxDQUFDbkgsTUFBZixHQVJnQyxDQVFQO0FBQzFCLENBVEQ7O0FBV0EsS0FBSyxNQUFNNkgsSUFBWCxJQUFtQkMsUUFBbkIsRUFBNkI7QUFDM0IsUUFBTUMsVUFBVSxHQUFHck0sUUFBUSxDQUFDQyxhQUFULENBQXVCLEdBQXZCLENBQW5CO0FBQ0FvTSxZQUFVLENBQUNqTSxXQUFYLEdBQXlCK0wsSUFBSSxDQUFDbEQsSUFBOUI7QUFDQW9ELFlBQVUsQ0FBQ0MsWUFBWCxDQUF3QixNQUF4QixFQUFnQyxHQUFoQzs7QUFDQSxHQUFDLE1BQU07QUFDTEQsY0FBVSxDQUFDdEssZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBc0NVLENBQUQsSUFBTztBQUMxQ0EsT0FBQyxDQUFDOEosY0FBRjtBQUNBeEQsZ0JBQVUsQ0FBQyxNQUFNO0FBQUU7QUFDakJpRCxvQkFBWSxDQUFDRyxJQUFELENBQVo7QUFDRCxPQUZTLEVBRVAsQ0FGTyxDQUFWO0FBR0QsS0FMRDtBQU1ELEdBUEQ7O0FBU0EsUUFBTUssUUFBUSxHQUFHeE0sUUFBUSxDQUFDQyxhQUFULENBQXVCLElBQXZCLENBQWpCO0FBQ0F1TSxVQUFRLENBQUNsTSxXQUFULENBQXFCK0wsVUFBckI7QUFFQWYsaUJBQWUsQ0FBQ2hMLFdBQWhCLENBQTRCa00sUUFBNUI7QUFDRDs7QUFFRFIsWUFBWSxDQUFDSSxRQUFRLENBQUMsQ0FBRCxDQUFULENBQVoiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIE5PVEU6IFVzaW5nIHJlcXVpcmUgaW5zdGVhZCBvZiBpbXBvcnQgaGVyZSBtYWtlcyB0aGUgdGhpbmcgd2hlcmUgd2UgcHJpbnQgcHJvZ3JhbSB0ZXh0IHdvcmsgYmV0dGVyLlxuY29uc3QgeyB1c2VWYXIsIHVzZVJlcXVlc3RVcGRhdGUsIHVzZUluaXRpYWxpemUsIHVzZUFzeW5jRXZlbnRFbWl0dGVyLCB1c2VFdmVudFJlY2VpdmVyLCB1c2VEeW5hbWljLCB1c2VSZWR1Y2VyLCB1c2VNYWNoaW5lIH0gPSByZXF1aXJlKCcuL3JpdicpO1xuY29uc3QgYW1lbl9icmVha191cmwgPSByZXF1aXJlKCcuL2FtZW5fYnJlYWsubXAzJyk7XG5cbmZ1bmN0aW9uIHNob3dTdHJpbmcodikge1xuICBjb25zdCBlbGVtID0gdXNlVmFyKG51bGwpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGVsZW0uY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW0uY3VycmVudC5zdHlsZS5jc3NUZXh0ID0gJ2JvcmRlcjogMXB4IHNvbGlkIHJlZDsgY29sb3I6IGJsYWNrOyBmb250LXNpemU6IDI0cHg7IHBhZGRpbmc6IDVweDsgbWFyZ2luLXRvcDogMjBweCc7XG4gICAgZWxlbS5jdXJyZW50LnRleHRDb250ZW50ID0gJyh1bmRlZmluZWQpJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0uY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW0uY3VycmVudCk7XG4gICAgfVxuICB9KVxuXG4gIGVsZW0uY3VycmVudC50ZXh0Q29udGVudCA9ICdzaG93U3RyaW5nOiAnICsgKCh2ID09PSB1bmRlZmluZWQpID8gJyh1bmRlZmluZWQpJyA6IHYudG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvblRpbWUoKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IHRpbWUgPSB1c2VWYXIoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkZyYW1lID0gKHQpID0+IHtcbiAgICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnQ7XG4gICAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpOyAvLyByZXF1ZXN0IGFub3RoZXJcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgdGltZS5jdXJyZW50ID0gMC4wMDEqcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcUlkLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWUuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWVFdnRzKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCByZXFJZCA9IHVzZVZhcigpO1xuICBjb25zdCBbZnJhbWVFdnRzLCBlbWl0RnJhbWVdID0gdXNlQXN5bmNFdmVudEVtaXR0ZXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkZyYW1lID0gKHQpID0+IHtcbiAgICAgIGVtaXRGcmFtZSgpO1xuICAgICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTsgLy8gcmVxdWVzdCBhbm90aGVyXG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXFJZC5jdXJyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBmcmFtZUV2dHM7XG59XG5cbmZ1bmN0aW9uIGNvdW50RXZlbnRzKGV2dHMpIHtcbiAgY29uc3QgY291bnQgPSB1c2VWYXIoMCk7XG4gIGNvbnN0IGV2ZW50ID0gdXNlRXZlbnRSZWNlaXZlcihldnRzKTtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBjb3VudC5jdXJyZW50Kys7XG4gIH1cblxuICByZXR1cm4gY291bnQuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gbW91c2VDbGlja0V2dHMoKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IFtjbGlja0V2dCwgZW1pdENsaWNrXSA9IHVzZUFzeW5jRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSAoKSA9PiB7XG4gICAgICBlbWl0Q2xpY2soKTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNsaWNrRXZ0O1xufVxuXG5mdW5jdGlvbiBtb3VzZURvd24oKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IGlzRG93biA9IHVzZVZhcihmYWxzZSk7IC8vIHdlIGNhbid0IHBvbGwgZG93bi1uZXNzLCBzbyB3ZSBhc3N1bWUgaXQncyBpbml0aWFsbHkgbm90IGRvd25cblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbk1vdXNlRG93biA9ICgpID0+IHtcbiAgICAgIGlzRG93bi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgY29uc3Qgb25Nb3VzZVVwID0gKCkgPT4ge1xuICAgICAgaXNEb3duLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRG93bik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpc0Rvd24uY3VycmVudDtcbn1cblxuZnVuY3Rpb24gbW91c2VQb3NpdGlvbigpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcG9zaXRpb24gPSB1c2VWYXIoe3g6IDAsIHk6IDB9KTsgLy8gd2UgY2FuJ3QgcG9sbCBwb3NpdGlvbiwgc28gc3RhcnQgaXQgYXQgb3JpZ2luXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgICAgcG9zaXRpb24uY3VycmVudCA9IHtcbiAgICAgICAgeDogZS5jbGllbnRYIHx8IGUucGFnZVgsXG4gICAgICAgIHk6IGUuY2xpZW50WSB8fCBlLnBhZ2VZLFxuICAgICAgfTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcG9zaXRpb24uY3VycmVudDtcbn1cblxuZnVuY3Rpb24gcmFuZG9tKHJlcGlja0V2dCkge1xuICBjb25zdCB2YWwgPSB1c2VWYXIoTWF0aC5yYW5kb20oKSk7XG4gIGNvbnN0IHJlcGljayA9IHVzZUV2ZW50UmVjZWl2ZXIocmVwaWNrRXZ0KTtcblxuICBpZiAocmVwaWNrKSB7XG4gICAgdmFsLmN1cnJlbnQgPSBNYXRoLnJhbmRvbSgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBhdWRpb0RyaXZlcihnZW5lcmF0b3IpIHtcbiAgY29uc3QgY3JlYXRlR2VuZXJhdG9yID0gdXNlRHluYW1pYyhnZW5lcmF0b3IpO1xuICBjb25zdCBnZW5lcmF0b3JDdHggPSB1c2VWYXIoKTtcbiAgY29uc3QgZnJhbWVDb3VudCA9IHVzZVZhcigwKTtcbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHVzZVZhcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGdlbmVyYXRvckN0eC5jdXJyZW50ID0gY3JlYXRlR2VuZXJhdG9yKCk7XG5cbiAgICBjb25zdCBCVUZGRVJfU0laRSA9IDEwMjQ7XG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG4gICAgY29uc3Qgc2NyaXB0Tm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVTY3JpcHRQcm9jZXNzb3IoQlVGRkVSX1NJWkUsIDAsIDEpOyAvLyAwIGlucHV0IGNoYW5uZWxzLCAxIG91dHB1dCBjaGFubmVsXG4gICAgc2NyaXB0Tm9kZS5vbmF1ZGlvcHJvY2VzcyA9IChlKSA9PiB7XG4gICAgICBjb25zdCBidWZmZXIgPSBlLm91dHB1dEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCB7dmFsdWU6IHVuZGVmaW5lZH0sIHNhbXBsZVJhdGUuY3VycmVudCk7XG4gICAgICAgIGZyYW1lQ291bnQuY3VycmVudCsrO1xuICAgICAgfVxuICAgIH07XG4gICAgc2NyaXB0Tm9kZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgICBzYW1wbGVSYXRlLmN1cnJlbnQgPSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzY3JpcHROb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBNb3N0IG9mIG91ciBnZW5lcmF0b3IgdXBkYXRpbmcgd2lsbCBoYXBwZW4gaW4gdGhlIGF1ZGlvIHByb2Nlc3NpbmcgY2FsbGJhY2sgYWJvdmUuXG4gICAqIFRoaXMgdXBkYXRlIGhlcmUgaXMgZm9yIHdoZW4gdGhlIGF1ZGlvRHJpdmVyIHVwZGF0ZSBpcyBjYWxsZWQsIGUuZy4gd2hlbiBhbiBvdXRlciBzY29wZVxuICAgKiByZWZlcmVuY2UgdGhhdCB0aGUgZ2VuZXJhdG9yIGRlcGVuZHMgb24gaGFzIGNoYW5nZWQuIFNvIHdlIG11c3QgdXBkYXRlIHRoZSBnZW5lcmF0b3IsXG4gICAqIGJ1dCBkb24ndCBuZWVkIGl0cyBvdXRwdXQgYW1wbGl0dWRlLlxuICAgKi9cbiAgZ2VuZXJhdG9yQ3R4LmN1cnJlbnQudXBkYXRlKGZyYW1lQ291bnQuY3VycmVudC9zYW1wbGVSYXRlLmN1cnJlbnQsIHVuZGVmaW5lZCwgc2FtcGxlUmF0ZS5jdXJyZW50KTsgLy8gTk9URTogd2UgZGlzY2FyZCByZXR2YWxcbn1cblxuZnVuY3Rpb24gc2FtcGxlVXBvbih0b1NhbXBsZSwgdXBvbkV2dCwgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGhlbGQgPSB1c2VWYXIoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdXBvbiA9IHVzZUV2ZW50UmVjZWl2ZXIodXBvbkV2dCk7XG5cbiAgaWYgKHVwb24pIHtcbiAgICBoZWxkLmN1cnJlbnQgPSB0b1NhbXBsZTtcbiAgfVxuXG4gIHJldHVybiBoZWxkLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGV2ZXJ5U2Vjb25kKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBbdGlja0V2dCwgZW1pdFRpY2tdID0gdXNlQXN5bmNFdmVudEVtaXR0ZXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkludGVydmFsID0gKCkgPT4ge1xuICAgICAgZW1pdFRpY2soKTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXJJZCA9IHNldEludGVydmFsKG9uSW50ZXJ2YWwsIDEwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aWNrRXZ0O1xufVxuXG4vKipcbiAqIFVudGlsIGF1ZGlvIGlzIGxvYWRlZCBhbmQgZGVjb2RlZCwgYSBzaW5nbGUtc2FtcGxlIGJ1ZmZlciBvZiBzaWxlbmNlIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBsb2FkQXVkaW9Bc0FycmF5KHVybCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBwY20gPSB1c2VWYXIoWzBdKTsgLy8gdW50aWwgbG9hZGVkLCBqdXN0IHJldHVybiBzaW5nbGUgc2FtcGxlIG9mIHNpbGVuY2VcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBhdWRpb0N0eCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgIGxldCBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3QgYXVkaW9EYXRhID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGF1ZGlvQ3R4LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIGJ1ZmZlciA9PiB7XG4gICAgICAgIGlmICghY2xlYW5lZFVwKSB7XG4gICAgICAgICAgcGNtLmN1cnJlbnQgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICByZXF1ZXN0LmFib3J0KCk7IC8vIGl0J3Mgc2FmZSB0byBhbHdheXMgYWJvcnQgaGVyZS4gaWYgYWxyZWFkeSBjb21wbGV0ZWQsIGl0IHdpbGwgYmUgaWdub3JlZFxuXG4gICAgICAvLyBkZWNvZGVBdWRpb0RhdGEgY2Fubm90IGJlIGNhbmNlbGVkLiBTbyB0byBiZSBjb3JyZWN0LCB3ZSBtdXN0IHNldCBhIGZsYWcgaGVyZSB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgZGVjb2RpbmcgaXMgaWdub3JlZFxuICAgICAgY2xlYW5lZFVwID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwY20uY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY29uc29sZUxvZyh2KSB7XG4gIGNvbnNvbGUubG9nKHYpO1xufVxuXG5mdW5jdGlvbiBpbnRlZ3JhbChpbnRlZ3JhbmRGdW5jLCB0aW1lLCBpbml0aWFsVmFsdWUgPSAwKSB7XG4gIGNvbnN0IGFjY3VtID0gdXNlVmFyKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHByZXZUaW1lID0gdXNlVmFyKHRpbWUpO1xuXG4gIGNvbnN0IGludGVncmFuZCA9IGludGVncmFuZEZ1bmMoYWNjdW0uY3VycmVudCwgcHJldlRpbWUuY3VycmVudCk7XG4gIGFjY3VtLmN1cnJlbnQgKz0gKHRpbWUgLSBwcmV2VGltZS5jdXJyZW50KSppbnRlZ3JhbmQ7XG5cbiAgcHJldlRpbWUuY3VycmVudCA9IHRpbWU7XG5cbiAgcmV0dXJuIGFjY3VtLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGV4cEZvbGxvdyh0YXJnZXRWYWx1ZSwgc3BlZWRDb25zdGFudCwgdGltZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBpbnRlZ3JhbChjdXJyZW50VmFsdWUgPT4gc3BlZWRDb25zdGFudCoodGFyZ2V0VmFsdWUgLSBjdXJyZW50VmFsdWUpLCB0aW1lLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZWRDaXJjbGUocG9zaXRpb24sIHJhZGl1cyA9IDI1KSB7XG4gIGNvbnN0IGVsZW0gPSB1c2VWYXIobnVsbCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgZWxlbS5jdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbS5jdXJyZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyBib3JkZXItcmFkaXVzOiA1MCU7IGJhY2tncm91bmQ6IHJlZDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0uY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW0uY3VycmVudCk7XG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHAgPSBwb3NpdGlvbiB8fCB7eDogMCwgeTogMH07XG4gIGlmIChyYWRpdXMgPCAwKSB7XG4gICAgcmFkaXVzID0gMDtcbiAgfVxuICBjb25zdCBoYWxmUmFkaXVzID0gMC41KnJhZGl1cztcblxuICBlbGVtLmN1cnJlbnQuc3R5bGUubGVmdCA9IChwLnggLSBoYWxmUmFkaXVzKSArICdweCc7XG4gIGVsZW0uY3VycmVudC5zdHlsZS50b3AgPSAocC55IC0gaGFsZlJhZGl1cykgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUud2lkdGggPSByYWRpdXMgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gcmFkaXVzICsgJ3B4Jztcbn1cblxuZnVuY3Rpb24gZm9sbG93QXRTcGVlZDJkKHRhcmdldCwgc3BlZWQsIHRpbWUsIGluaXRpYWwpIHtcbiAgY29uc3QgcG9zID0gdXNlVmFyKGluaXRpYWwpO1xuICBjb25zdCBwcmV2VGltZSA9IHVzZVZhcih0aW1lKTtcblxuICBjb25zdCBkdCA9IHRpbWUgLSBwcmV2VGltZS5jdXJyZW50O1xuICBjb25zdCBkZWx0YSA9IHt4OiB0YXJnZXQueC1wb3MuY3VycmVudC54LCB5OiB0YXJnZXQueS1wb3MuY3VycmVudC55fTtcbiAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkZWx0YS54KmRlbHRhLnggKyBkZWx0YS55KmRlbHRhLnkpO1xuICBpZiAoc3BlZWQqZHQgPj0gZGlzdCkge1xuICAgIC8vIEp1bXAgdG8gdGFyZ2V0IHBvc2l0aW9uXG4gICAgcG9zLmN1cnJlbnQgPSB0YXJnZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gTk9URTogV2UgbXVzdCBub3QgbXV0YXRlIHBvcy5jdXJyZW50LCBzaW5jZSB3ZSByZXR1cm4gdGhhdFxuICAgIHBvcy5jdXJyZW50ID0ge1xuICAgICAgeDogcG9zLmN1cnJlbnQueCArIGR0KnNwZWVkKmRlbHRhLngvZGlzdCxcbiAgICAgIHk6IHBvcy5jdXJyZW50LnkgKyBkdCpzcGVlZCpkZWx0YS55L2Rpc3QsXG4gICAgfTtcbiAgfVxuXG4gIHByZXZUaW1lLmN1cnJlbnQgPSB0aW1lO1xuXG4gIHJldHVybiBwb3MuY3VycmVudDtcbn1cblxuLyoqXG4gKiBOb3RlIHRoYXQgdGhpcyBfd2lsbF8gZmlyZSBpbiBmaXJzdCBjYWxsIGlmIGNvbmRpdGlvbiBzdGFydHMgdHJ1dGh5XG4gKi9cbmZ1bmN0aW9uIGV2ZW50V2hlbihjb25kaXRpb24sIHZhbHVlVG9FbWl0KSB7XG4gIGNvbnN0IHByZXZDb25kaXRpb24gPSB1c2VWYXIoZmFsc2UpO1xuXG4gIGNvbnN0IGJjb25kID0gISFjb25kaXRpb247XG5cbiAgY29uc3QgcmV0dmFsID0gKGJjb25kICYmICFwcmV2Q29uZGl0aW9uLmN1cnJlbnQpID8ge3ZhbHVlOiB2YWx1ZVRvRW1pdH0gOiB1bmRlZmluZWQ7XG4gIHByZXZDb25kaXRpb24uY3VycmVudCA9IGJjb25kO1xuXG4gIHJldHVybiByZXR2YWw7XG59XG5cbi8qKlxuICogTm90ZSB0aGF0IHNlY29uZHMgYXJndW1lbnQgaXMgb25seSByZWFkIGluaXRpYWxseS4gQnV0IHZhbHVlVG9FbWl0IGlzIHJlLXJlYWQgb24gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBldmVudEFmdGVyKHNlY29uZHMsIHZhbHVlVG9FbWl0KSB7XG4gIGNvbnN0IFtldnQsIGVtaXRdID0gdXNlQXN5bmNFdmVudEVtaXR0ZXIoKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VWYXIodmFsdWVUb0VtaXQpO1xuXG4gIHZhbHVlLmN1cnJlbnQgPSB2YWx1ZVRvRW1pdDtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCB0aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlbWl0KHZhbHVlLmN1cnJlbnQpO1xuICAgIH0sIDEwMDAqc2Vjb25kcyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9O1xuICB9KTtcblxuICByZXR1cm4gZXZ0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBbXG4gIHtcbiAgICBuYW1lOiAnZG8gbm90aGluZycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdhbmltYXRpb24gdGltZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhhbmltYXRpb25UaW1lKCkudG9GaXhlZCgzKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NvdW50IGNsaWNrcycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhjb3VudEV2ZW50cyhtb3VzZUNsaWNrRXZ0cygpKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2lzIG1vdXNlIGJ1dHRvbiBkb3duJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKG1vdXNlRG93bigpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmFuZG9tIG51bWJlciwgY2xpY2sgdG8gcmVwaWNrJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKHJhbmRvbShtb3VzZUNsaWNrRXZ0cygpKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2F1ZGlvIG5vaXNlIHdoZW4gbW91c2UgaXMgZG93bicsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgbWQgPSBtb3VzZURvd24oKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dCkgPT4ge1xuICAgICAgICBjb25zdCBub2lzZSA9IHJhbmRvbShhZHZhbmNlRnJhbWVFdnQpIC0gMC41O1xuICAgICAgICByZXR1cm4gbWQgPyBub2lzZSA6IDA7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnZGVjYXlpbmcgbm9pc2UgdXBvbiBjbGljaycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgY2xpY2tFdnQgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vaXNlID0gcmFuZG9tKGFkdmFuY2VGcmFtZUV2dCkgLSAwLjU7XG4gICAgICAgIGNvbnN0IGxhc3RDbGlja1RpbWUgPSBzYW1wbGVVcG9uKGF1ZGlvVGltZSwgY2xpY2tFdnQsIC1JbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IGRlY2F5aW5nR2FpbiA9IE1hdGguZXhwKDUqKGxhc3RDbGlja1RpbWUgLSBhdWRpb1RpbWUpKTtcbiAgICAgICAgcmV0dXJuIGRlY2F5aW5nR2Fpbipub2lzZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyZXNldHRpbmcgZnJhbWUgY291bnRlciwgY2xpY2sgdG8gcmVzZXQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lRXZ0cyA9IGFuaW1hdGlvbkZyYW1lRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2tFdnQgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2sgPSB1c2VFdmVudFJlY2VpdmVyKGNsaWNrRXZ0KTtcbiAgICAgIGNvbnN0IGNyZWF0ZUNvdW50ZXIgPSB1c2VEeW5hbWljKGNvdW50RXZlbnRzKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUNvdW50ZXIgPSB1c2VWYXIoKTtcblxuICAgICAgaWYgKGNsaWNrKSB7XG4gICAgICAgIGlmIChhY3RpdmVDb3VudGVyLmN1cnJlbnQpIHtcbiAgICAgICAgICBhY3RpdmVDb3VudGVyLmN1cnJlbnQudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50ID0gY3JlYXRlQ291bnRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKCFhY3RpdmVDb3VudGVyLmN1cnJlbnQpIHtcbiAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50ID0gY3JlYXRlQ291bnRlcigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXNwbGF5ZWRDb3VudCA9IGFjdGl2ZUNvdW50ZXIuY3VycmVudC51cGRhdGUoZnJhbWVFdnRzKTtcbiAgICAgIHNob3dTdHJpbmcoZGlzcGxheWVkQ291bnQpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2R5bmFtaWMgYXJyYXkgb2YgYXN5bmMgY2xvY2tzLCBjbGljayB0byBhZGQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0ID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrID0gdXNlRXZlbnRSZWNlaXZlcihjbGlja0V2dCk7XG4gICAgICBjb25zdCBjcmVhdGVDbG9jayA9IHVzZUR5bmFtaWMoKCkgPT4gY291bnRFdmVudHMoZXZlcnlTZWNvbmQoKSkpO1xuICAgICAgY29uc3QgY2xvY2tBcnJheSA9IHVzZVZhcihbXSk7XG5cbiAgICAgIGlmIChjbGljaykge1xuICAgICAgICBjbG9ja0FycmF5LmN1cnJlbnQucHVzaChjcmVhdGVDbG9jaygpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnVtcyA9IGNsb2NrQXJyYXkuY3VycmVudC5tYXAoY2xvY2sgPT4gY2xvY2sudXBkYXRlKCkpO1xuICAgICAgc2hvd1N0cmluZyhudW1zLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmVjb3JkIHBsYXllciBzcGluIHVwL2Rvd24sIGhvbGQgbW91c2UgZG93biBhbmQgcmVsZWFzZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgcGNtID0gbG9hZEF1ZGlvQXNBcnJheShhbWVuX2JyZWFrX3VybCk7XG4gICAgICBzaG93U3RyaW5nKHBjbS5sZW5ndGggPiAxID8gJ2xvYWRlZCBhdWRpbycgOiAnbG9hZGluZyBhdWRpby4uLicpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0LCBzYW1wbGVSYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldFNwZWVkID0gbW91c2VEb3duKCkgPyBzYW1wbGVSYXRlIDogMDtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBleHBGb2xsb3codGFyZ2V0U3BlZWQsIDMsIGF1ZGlvVGltZSwgMCk7XG4gICAgICAgIGNvbnN0IHBvcyA9IE1hdGguZmxvb3IoaW50ZWdyYWwoKCkgPT4gc3BlZWQsIGF1ZGlvVGltZSkpO1xuICAgICAgICByZXR1cm4gcGNtW3BvcyAlIHBjbS5sZW5ndGhdOyAvLyBtb2R1bG8gc28gYXMgdG8gbG9vcFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY2lyY2xlIGZvbGxvd3MgbW91c2UnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHJlZENpcmNsZShtb3VzZVBvc2l0aW9uKCkpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NpcmNsZSBmb2xsb3dzIG1vdXNlIGF0IGxpbWl0ZWQgc3BlZWQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBhbmltYXRpb25UaW1lKCk7XG4gICAgICBjb25zdCBtcG9zID0gbW91c2VQb3NpdGlvbigpO1xuICAgICAgcmVkQ2lyY2xlKGZvbGxvd0F0U3BlZWQyZChtcG9zLCAzMDAsIHRpbWUsIG1wb3MpKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjaXJjbGUgbW92ZXMgaGFsZndheSB0byBtb3VzZSB3aXRoIGVhY2ggY2xpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IG1pZHBvaW50ID0gKGEsIGIpID0+ICh7eDogMC41KihhLngrYi54KSwgeTogMC41KihhLnkrYi55KX0pO1xuICAgICAgY29uc3QgbXBvcyA9IG1vdXNlUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0ID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNwb3MgPSB1c2VSZWR1Y2VyKGNsaWNrRXZ0LCAoYWN0aW9uLCBwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGFjdGlvbiA/IG1pZHBvaW50KHByZXZTdGF0ZSwgbXBvcykgOiBwcmV2U3RhdGU7XG4gICAgICB9LCB7eDogMCwgeTogMH0pO1xuICAgICAgcmVkQ2lyY2xlKGNwb3MpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3JvYW1pbmcgY2lyY2xlIChzdGF0ZSBtYWNoaW5lKScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgdGltZSA9IGFuaW1hdGlvblRpbWUoKTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gdXNlTWFjaGluZSh7XG4gICAgICAgIG1vdmluZzogKGluaXRpYWxQb3NpdGlvbikgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0ge3g6IDUwMCpyYW5kb20oKSwgeTogNTAwKnJhbmRvbSgpfTtcbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGZvbGxvd0F0U3BlZWQyZCh0YXJnZXRQb3NpdGlvbiwgMzAwLCB0aW1lLCBpbml0aWFsUG9zaXRpb24pO1xuICAgICAgICAgIGNvbnN0IGFycml2ZWQgPSAocG9zaXRpb24ueCA9PT0gdGFyZ2V0UG9zaXRpb24ueCkgJiYgKHBvc2l0aW9uLnkgPT09IHRhcmdldFBvc2l0aW9uLnkpO1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGV2ZW50V2hlbihhcnJpdmVkLCBbJ3Jlc3RpbmcnLCBwb3NpdGlvbl0pXG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdGluZzogKGluaXRpYWxQb3NpdGlvbikgPT4ge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBpbml0aWFsUG9zaXRpb24sXG4gICAgICAgICAgICBldmVudEFmdGVyKHJhbmRvbSgpLCBbJ21vdmluZycsIGluaXRpYWxQb3NpdGlvbl0pXG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgIH0sIFsnbW92aW5nJywge3g6IDAsIHk6IDB9XSk7XG4gICAgICByZWRDaXJjbGUocG9zaXRpb24pO1xuICAgIH1cbiAgfSxcblxuXVxuIiwiaW1wb3J0IHsgY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tICcuL3Jpdic7XG5pbXBvcnQgcHJvZ3JhbXMgZnJvbSAnLi9wcm9ncmFtcyc7XG5cbmNvbnN0IHByb2dyYW1MaXN0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmFtLWxpc3QnKTtcbmNvbnN0IHByb2dyYW1Tb3VyY2VFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyYW0tc291cmNlJyk7XG5cbmxldCBjdXJyZW50Q29udGV4dDtcblxuLy8gTk9URTogVGhpcyBpcyBhIGhhY2sgYnV0IHdvcmtzIGZvciBub3dcbmNvbnN0IGZpeEluZGVudCA9IChjb2RlKSA9PiB7XG4gIHJldHVybiBjb2RlLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGlkeCkgPT4gKGlkeCA9PT0gMCkgPyBsaW5lIDogbGluZS5zdWJzdHIoMikpLmpvaW4oJ1xcbicpO1xufVxuXG5jb25zdCBzdGFydFByb2dyYW0gPSAocHJvZ3JhbSkgPT4ge1xuICBpZiAoY3VycmVudENvbnRleHQpIHtcbiAgICBjdXJyZW50Q29udGV4dC50ZXJtaW5hdGUoKTtcbiAgICBjdXJyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb2dyYW1Tb3VyY2VFbGVtLnRleHRDb250ZW50ID0gZml4SW5kZW50KHByb2dyYW0ubWFpbi50b1N0cmluZygpKTsgLy8gaGFja3kgYnV0IHdvcmtzIGZvciBub3dcbiAgY3VycmVudENvbnRleHQgPSBjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dChwcm9ncmFtLm1haW4pO1xuICBjdXJyZW50Q29udGV4dC51cGRhdGUoKTsgLy8gZG8gaW5pdGlhbCB1cGRhdGUuIGFueSBmdXJ0aGVyIHVwZGF0ZXMgd2lsbCBiZSBhc3luY1xufVxuXG5mb3IgKGNvbnN0IHByb2cgb2YgcHJvZ3JhbXMpIHtcbiAgY29uc3QgYW5jaG9yRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgYW5jaG9yRWxlbS50ZXh0Q29udGVudCA9IHByb2cubmFtZTtcbiAgYW5jaG9yRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAoKCkgPT4ge1xuICAgIGFuY2hvckVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIHN0YXJ0IHByb2dyYW0gd2l0aCBkZWxheSBzbyBpdCBkb2Vzbid0IGdldCB0aGlzIGNsaWNrIGV2ZW50XG4gICAgICAgIHN0YXJ0UHJvZ3JhbShwcm9nKTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICB9KSgpO1xuXG4gIGNvbnN0IGl0ZW1FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaXRlbUVsZW0uYXBwZW5kQ2hpbGQoYW5jaG9yRWxlbSk7XG5cbiAgcHJvZ3JhbUxpc3RFbGVtLmFwcGVuZENoaWxkKGl0ZW1FbGVtKTtcbn1cblxuc3RhcnRQcm9ncmFtKHByb2dyYW1zWzBdKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n")}]);