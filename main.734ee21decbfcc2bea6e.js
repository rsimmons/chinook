!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=2)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNoInOutExecutionContext", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useVar", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRequestUpdate", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useInitialize", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useAsyncEventEmitter", function() { return useAsyncEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventReceiver", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDynamic", function() { return useDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return useReducer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMachine", function() { return useMachine; });\nlet currentUpdateFrame = null;\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push a new update frame onto the update stack for this context\n    const newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn\'t get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error(\'Did not reach all hook records in update\');\n    } // Pop the top frame from the update stack\n\n\n    const poppedFrame = currentUpdateFrame;\n\n    if (!poppedFrame) {\n      throw new Error(\'Cannot pop update frame because current is null\');\n    }\n\n    if (poppedFrame.executionContext !== this) {\n      throw new Error("Popped frame from update stack but context did not match");\n    }\n\n    currentUpdateFrame = poppedFrame.previousFrame;\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // NOTE: Might we want to sanity check that this context isn\'t anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error(\'Expecting to create new hook record in chain, but already present\');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error(\'Expecting to find hook record in chain, but not present\');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It\'s currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error(\'Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?\');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can\'t we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it\'s important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\n/**\n * This is effectively a queue with only a single-item capacity, to support async event emission\n */\n\nfunction useAsyncEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {\n      queuedEvent: undefined\n    };\n\n    data.emit = value => {\n      if (data.queuedEvent) {\n        throw new Error(\'Cannot emit another event since one is already enqueued\');\n      }\n\n      data.queuedEvent = {\n        value\n      };\n    };\n\n    record.data = data;\n  }\n\n  let retval;\n\n  if (record.data.queuedEvent) {\n    // Pop queued event\n    retval = record.data.queuedEvent;\n    record.data.queuedEvent = undefined;\n  }\n\n  ctx._endHook();\n\n  return [retval, record.data.emit];\n}\nfunction useEventReceiver(evt) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      seen: new WeakSet() // event objects we have already seen\n\n    };\n  }\n\n  let retval;\n\n  if (evt) {\n    if (!record.data.seen.has(evt)) {\n      retval = evt;\n      record.data.seen.add(evt);\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new "version" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create "factory" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\n/**\n * NOTE: reducerFunc should be pure-pointwise, NOT a stream func\n */\n\nfunction useReducer(actionEvts, reducerFunc, initialState) {\n  const state = useVar(initialState);\n  const action = useEventReceiver(actionEvts);\n\n  if (action) {\n    state.current = reducerFunc(action.value, state.current);\n  }\n\n  return state.current;\n}\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook();\n\n  const takeTransition = trans => {\n    // If there\'s an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    const [newState, newStateArg] = trans; // Create a new context and store it in record (but don\'t update it)\n\n    const newCtx = new ExecutionContext(states[newState], () => {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    const data = {};\n    record.data = data;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = () => {\n      data.activeContext.terminate();\n    };\n  }\n\n  let retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    const [tmpRetval, transitionEvt] = record.data.activeContext.update(record.data.activeArgument);\n    retval = tmpRetval; // Was there a transition event?\n    // NOTE: Because we transition upon first even on this stream, we can sort of special-case this check\n\n    if (transitionEvt) {\n      const transition = transitionEvt.value;\n      takeTransition(transition);\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcml2LmpzPzgxNWEiXSwibmFtZXMiOlsiY3VycmVudFVwZGF0ZUZyYW1lIiwiRXhlY3V0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RyZWFtRnVuYyIsIm9uUmVxdWVzdFVwZGF0ZSIsImFmdGVyVGVybWluYXRlIiwiaG9va1JlY29yZENoYWluIiwibmV4dCIsInJlY29yZEN1cnNvciIsInVwZGF0ZUNvdW50IiwidXBkYXRlIiwibmV3RnJhbWUiLCJleGVjdXRpb25Db250ZXh0IiwicHJldmlvdXNGcmFtZSIsInJldHZhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJwb3BwZWRGcmFtZSIsInRlcm1pbmF0ZSIsImMiLCJjbGVhbnVwIiwiX2JlZ2luSG9vayIsImRhdGEiLCJ1bmRlZmluZWQiLCJfZW5kSG9vayIsIl9yZXF1ZXN0VXBkYXRlIiwiX3NldFN0cmVhbUZ1bmMiLCJuZXdTdHJlYW1GdW5jIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJjdHgiLCJnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQiLCJ1c2VWYXIiLCJpbml0VmFsIiwicmVjb3JkIiwiY3VycmVudCIsInVzZVJlcXVlc3RVcGRhdGUiLCJyZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsImluaXRpYWxpemVyIiwidXNlQXN5bmNFdmVudEVtaXR0ZXIiLCJxdWV1ZWRFdmVudCIsImVtaXQiLCJ2YWx1ZSIsInVzZUV2ZW50UmVjZWl2ZXIiLCJldnQiLCJzZWVuIiwiV2Vha1NldCIsImhhcyIsImFkZCIsInVzZUR5bmFtaWMiLCJvcnUiLCJhY3RpdmVDb250ZXh0cyIsIlNldCIsImNyZWF0ZUNvbnRleHQiLCJkZWxldGUiLCJ1c2VSZWR1Y2VyIiwiYWN0aW9uRXZ0cyIsInJlZHVjZXJGdW5jIiwiaW5pdGlhbFN0YXRlIiwic3RhdGUiLCJhY3Rpb24iLCJ1c2VNYWNoaW5lIiwic3RhdGVzIiwiaW5pdGlhbFRyYW5zaXRpb24iLCJ0YWtlVHJhbnNpdGlvbiIsInRyYW5zIiwiYWN0aXZlQ29udGV4dCIsIm5ld1N0YXRlIiwibmV3U3RhdGVBcmciLCJuZXdDdHgiLCJhY3RpdmVTdGF0ZSIsImFjdGl2ZUFyZ3VtZW50IiwidG1wUmV0dmFsIiwidHJhbnNpdGlvbkV2dCIsInRyYW5zaXRpb24iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBSUEsa0JBQWtCLEdBQUcsSUFBekI7O0FBRUEsTUFBTUMsZ0JBQU4sQ0FBdUI7QUFDckJDLGFBQVcsQ0FBQ0MsVUFBRCxFQUFhQyxlQUFiLEVBQThCQyxjQUE5QixFQUE4QztBQUN2RCxTQUFLRixVQUFMLEdBQWtCQSxVQUFsQjtBQUNBLFNBQUtDLGVBQUwsR0FBdUJBLGVBQXZCO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQkEsY0FBdEI7QUFFQSxTQUFLQyxlQUFMLEdBQXVCO0FBQUNDLFVBQUksRUFBRTtBQUFQLEtBQXZCLENBTHVELENBS2xCOztBQUNyQyxTQUFLQyxZQUFMLEdBQW9CLElBQXBCLENBTnVELENBTTdCOztBQUMxQixTQUFLQyxXQUFMLEdBQW1CLENBQW5CO0FBQ0Q7O0FBRURDLFFBQU0sR0FBRztBQUNQO0FBQ0EsVUFBTUMsUUFBUSxHQUFHO0FBQ2ZDLHNCQUFnQixFQUFFLElBREg7QUFFZkMsbUJBQWEsRUFBRWI7QUFGQSxLQUFqQjtBQUlBQSxzQkFBa0IsR0FBR1csUUFBckIsQ0FOTyxDQVFQOztBQUNBLFNBQUtILFlBQUwsR0FBb0IsS0FBS0YsZUFBekI7QUFFQSxVQUFNUSxNQUFNLEdBQUcsS0FBS1gsVUFBTCxDQUFnQlksS0FBaEIsQ0FBc0IsSUFBdEIsRUFBNEJDLFNBQTVCLENBQWYsQ0FYTyxDQWFQOztBQUNBLFFBQUksS0FBS1IsWUFBTCxDQUFrQkQsSUFBdEIsRUFBNEI7QUFDMUIsWUFBTSxJQUFJVSxLQUFKLENBQVUsMENBQVYsQ0FBTjtBQUNELEtBaEJNLENBa0JQOzs7QUFD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IiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgY3VycmVudFVwZGF0ZUZyYW1lID0gbnVsbDtcblxuY2xhc3MgRXhlY3V0aW9uQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSwgYWZ0ZXJUZXJtaW5hdGUpIHtcbiAgICB0aGlzLnN0cmVhbUZ1bmMgPSBzdHJlYW1GdW5jO1xuICAgIHRoaXMub25SZXF1ZXN0VXBkYXRlID0gb25SZXF1ZXN0VXBkYXRlO1xuICAgIHRoaXMuYWZ0ZXJUZXJtaW5hdGUgPSBhZnRlclRlcm1pbmF0ZTtcblxuICAgIHRoaXMuaG9va1JlY29yZENoYWluID0ge25leHQ6IG51bGx9OyAvLyBkdW1teVxuICAgIHRoaXMucmVjb3JkQ3Vyc29yID0gbnVsbDsgLy8gb25seSBzZXQgd2hlbiB0aGlzIGNvbnRleHQgaXMgdXBkYXRpbmdcbiAgICB0aGlzLnVwZGF0ZUNvdW50ID0gMDtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICAvLyBQdXNoIGEgbmV3IHVwZGF0ZSBmcmFtZSBvbnRvIHRoZSB1cGRhdGUgc3RhY2sgZm9yIHRoaXMgY29udGV4dFxuICAgIGNvbnN0IG5ld0ZyYW1lID0ge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dDogdGhpcyxcbiAgICAgIHByZXZpb3VzRnJhbWU6IGN1cnJlbnRVcGRhdGVGcmFtZSxcbiAgICB9O1xuICAgIGN1cnJlbnRVcGRhdGVGcmFtZSA9IG5ld0ZyYW1lO1xuXG4gICAgLy8gTW92ZSBob29rIHJlY29yZCBjdXJzb3IgdG8gc3RhcnQgb2YgY2hhaW5cbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IHRoaXMuaG9va1JlY29yZENoYWluO1xuXG4gICAgY29uc3QgcmV0dmFsID0gdGhpcy5zdHJlYW1GdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBudWxsLCBvdGhlcndpc2UgdGhlcmUgYXJlIGhvb2sgcmVjb3JkcyB3ZSBkaWRuJ3QgZ2V0IHRvLCBhbmQgc29tZXRoaW5nIGlzIGFtaXNzXG4gICAgaWYgKHRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCByZWFjaCBhbGwgaG9vayByZWNvcmRzIGluIHVwZGF0ZScpO1xuICAgIH1cblxuICAgIC8vIFBvcCB0aGUgdG9wIGZyYW1lIGZyb20gdGhlIHVwZGF0ZSBzdGFja1xuICAgIGNvbnN0IHBvcHBlZEZyYW1lID0gY3VycmVudFVwZGF0ZUZyYW1lO1xuICAgIGlmICghcG9wcGVkRnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBvcCB1cGRhdGUgZnJhbWUgYmVjYXVzZSBjdXJyZW50IGlzIG51bGwnKTtcbiAgICB9XG4gICAgaWYgKHBvcHBlZEZyYW1lLmV4ZWN1dGlvbkNvbnRleHQgIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvcHBlZCBmcmFtZSBmcm9tIHVwZGF0ZSBzdGFjayBidXQgY29udGV4dCBkaWQgbm90IG1hdGNoXCIpO1xuICAgIH1cbiAgICBjdXJyZW50VXBkYXRlRnJhbWUgPSBwb3BwZWRGcmFtZS5wcmV2aW91c0ZyYW1lO1xuXG4gICAgdGhpcy51cGRhdGVDb3VudCsrO1xuXG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICAvLyBOT1RFOiBNaWdodCB3ZSB3YW50IHRvIHNhbml0eSBjaGVjayB0aGF0IHRoaXMgY29udGV4dCBpc24ndCBhbnl3aGVyZSBpbiB0aGUgY3VycmVudCB1cGRhdGUgc3RhY2s/XG5cbiAgICAvLyBDYWxsIGFueSBjbGVhbnVwIGZ1bmN0aW9ucyBzZXQgYnkgaG9va3NcbiAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHdvcnJ5IGFib3V0IG9yZGVyP1xuICAgIGZvciAobGV0IGMgPSB0aGlzLmhvb2tSZWNvcmRDaGFpbi5uZXh0OyBjOyBjID0gYy5uZXh0KSB7XG4gICAgICBpZiAoYy5jbGVhbnVwKSB7XG4gICAgICAgIGMuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFmdGVyVGVybWluYXRlKSB7XG4gICAgICB0aGlzLmFmdGVyVGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2JlZ2luSG9vaygpIHtcbiAgICBpZiAodGhpcy51cGRhdGVDb3VudCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgdG8gY3JlYXRlIG5ldyBob29rIHJlY29yZCBpbiBjaGFpbiwgYnV0IGFscmVhZHkgcHJlc2VudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIG5ldyByZWNvcmRcbiAgICAgIHRoaXMucmVjb3JkQ3Vyc29yLm5leHQgPSB7XG4gICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgY2xlYW51cDogdW5kZWZpbmVkLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5yZWNvcmRDdXJzb3IubmV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgdG8gZmluZCBob29rIHJlY29yZCBpbiBjaGFpbiwgYnV0IG5vdCBwcmVzZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVjb3JkQ3Vyc29yLm5leHQ7XG4gIH1cblxuICBfZW5kSG9vaygpIHtcbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IHRoaXMucmVjb3JkQ3Vyc29yLm5leHQ7IC8vIG1vdmUgY3Vyc29yIGZvcndhcmRcbiAgfVxuXG4gIF9yZXF1ZXN0VXBkYXRlKCkge1xuICAgIHRoaXMub25SZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBvbmx5IHNhZmUgdG8gZG8gaWYgdGhlIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGNhbGxzIHRoZSBzYW1lIGhvb2tzLCBoYXMgc2FtZSBzaWduYXR1cmUsIGV0Yy5cbiAgICogSXQncyBjdXJyZW50bHkgdXNlZCB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBsZXhpY2FsbHkgdGhlIHNhbWUgYnV0IGJvdW5kIHRvIGRpZmZlcmVudCBvdXRlci1zY29wZVxuICAgKiB2YXJpYWJsZXMuXG4gICAqL1xuICBfc2V0U3RyZWFtRnVuYyhuZXdTdHJlYW1GdW5jKSB7XG4gICAgdGhpcy5zdHJlYW1GdW5jID0gbmV3U3RyZWFtRnVuYztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQoc3RyZWFtRnVuYykge1xuICBjb25zdCBvblJlcXVlc3RVcGRhdGUgPSAoKSA9PiB7IGN0eC51cGRhdGUoKSB9O1xuICBjb25zdCBjdHggPSBuZXcgRXhlY3V0aW9uQ29udGV4dChzdHJlYW1GdW5jLCBvblJlcXVlc3RVcGRhdGUpXG4gIHJldHVybiBjdHg7XG59XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIGJ5IGhvb2tzIHRvIGdldCB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGNvbnRleHQgKGFmdGVyIHZlcmlmeWluZyBpdCBpcyBzZXQpXG4gKi9cbmZ1bmN0aW9uIGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpIHtcbiAgaWYgKCFjdXJyZW50VXBkYXRlRnJhbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgY3VycmVudGx5IHVwZGF0aW5nIGV4ZWN1dGlvbiBjb250ZXh0IGJlY2F1c2UgdXBkYXRlIHN0YWNrIGlzIGVtcHR5LiBXYXMgYSBob29rIGNhbGxlZCBvdXRzaWRlIG9mIGFuIGV4ZWN1dGlvbiBjb250ZXh0IHVwZGF0ZT8nKTtcbiAgfVxuICByZXR1cm4gY3VycmVudFVwZGF0ZUZyYW1lLmV4ZWN1dGlvbkNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VWYXIoaW5pdFZhbCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBDcmVhdGUgdmFsdWUgYm94IGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7Y3VycmVudDogaW5pdFZhbH07XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGE7XG59XG5cbi8qKlxuICogV2h5IGRvIHdlIG5lZWQgYSBob29rPyBXaHkgY2FuJ3Qgd2UganVzdCBjYWxsIGN0eC5yZXF1ZXN0VXBkYXRlKCk/IEJlY2F1c2UgdGhlIHJlcXVlc3RVcGRhdGVcbiAqIGZ1bmN0aW9uIHRoYXQgd2UgcmV0dXJuIHdpbGwgb2Z0ZW4gYmUgY2FsbGVkIHdpdGhvdXQgdGhlcmUgYmVpbmcgYW55IHVwZGF0aW5nIGV4ZWN1dGlvbiBjb250ZXh0XG4gKiAoZS5nLiBmcm9tIGFuIGV2ZW50IGhhbmRsZXIpLiBTbyBpdCBoYXMgdG8gYmUgYm91bmQgdG8gdGhlIGNvcnJlY3QgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlcXVlc3RVcGRhdGUoKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIENyZWF0ZSBjYWxsYmFjayBpZiBuZWNlc3NhcnkuIFdlIHN0b3JlIGl0IHNvIHRoYXQgd2UgYWxyZWFkeSByZXR1cm4gdGhlIHNhbWUgb25lLlxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7cmVxdWVzdFVwZGF0ZTogKCkgPT4ge1xuICAgICAgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7IC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgdXNlIGN0eCBmcm9tIGNsb3N1cmUsIG5vdCBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKSBoZXJlXG4gICAgfX07XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGEucmVxdWVzdFVwZGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluaXRpYWxpemUoaW5pdGlhbGl6ZXIpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIC8vIGRhdGEgYmVpbmcgdW5kZWZpbmVkIG1lYW5zIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGxcblxuICAgIHJlY29yZC5jbGVhbnVwID0gaW5pdGlhbGl6ZXIoKTtcblxuICAgIHJlY29yZC5kYXRhID0ge307IC8vIG5vIGRhdGEgdG8gc3RvcmUgeWV0LCBqdXN0IG5lZWRzIHRvIGJlIHRydXRoeSB0byBpbmRpY2F0ZSB0aGF0IGluaXRpYWxpemF0aW9uIHJhblxuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBlZmZlY3RpdmVseSBhIHF1ZXVlIHdpdGggb25seSBhIHNpbmdsZS1pdGVtIGNhcGFjaXR5LCB0byBzdXBwb3J0IGFzeW5jIGV2ZW50IGVtaXNzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY0V2ZW50RW1pdHRlcigpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBxdWV1ZWRFdmVudDogdW5kZWZpbmVkLFxuICAgIH07XG5cbiAgICBkYXRhLmVtaXQgPSAodmFsdWUpID0+IHtcbiAgICAgIGlmIChkYXRhLnF1ZXVlZEV2ZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVtaXQgYW5vdGhlciBldmVudCBzaW5jZSBvbmUgaXMgYWxyZWFkeSBlbnF1ZXVlZCcpO1xuICAgICAgfVxuICAgICAgZGF0YS5xdWV1ZWRFdmVudCA9IHt2YWx1ZX07XG4gICAgfTtcblxuICAgIHJlY29yZC5kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGxldCByZXR2YWw7XG4gIGlmIChyZWNvcmQuZGF0YS5xdWV1ZWRFdmVudCkge1xuICAgIC8vIFBvcCBxdWV1ZWQgZXZlbnRcbiAgICByZXR2YWwgPSByZWNvcmQuZGF0YS5xdWV1ZWRFdmVudDtcbiAgICByZWNvcmQuZGF0YS5xdWV1ZWRFdmVudCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiBbcmV0dmFsLCByZWNvcmQuZGF0YS5lbWl0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV2ZW50UmVjZWl2ZXIoZXZ0KSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtcbiAgICAgIHNlZW46IG5ldyBXZWFrU2V0KCksIC8vIGV2ZW50IG9iamVjdHMgd2UgaGF2ZSBhbHJlYWR5IHNlZW5cbiAgICB9O1xuICB9XG5cbiAgbGV0IHJldHZhbDtcbiAgaWYgKGV2dCkge1xuICAgIGlmICghcmVjb3JkLmRhdGEuc2Vlbi5oYXMoZXZ0KSkge1xuICAgICAgcmV0dmFsID0gZXZ0O1xuICAgICAgcmVjb3JkLmRhdGEuc2Vlbi5hZGQoZXZ0KTtcbiAgICB9XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuXG4vKipcbiAqIFRoZSBzdHJlYW1GdW5jIGFyZ3VtZW50IG1heSBjaGFuZ2UsIGJ1dCBpdCBzaG91bGQgb25seSBjaGFuZ2UgdG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBzYWZlbHlcbiAqIHN3YXBwZWQgaW4gKGkuZS4gb25lIHRoYXQgY2FsbHMgdGhlIHNhbWUgaG9va3MsIGV0Yy4pLiBBIGNvbW1vbiBjYXNlIGlzIHRoYXQgc3RyZWFtRnVuYyBpcyBhXG4gKiBjbG9zdXJlIHRoYXQgcmVmZXJlbmNlcyBzb21lIG91dGVyIHNjb3BlIHZhcmlhYmxlcywgYW5kIHdoZW4gdGhvc2UgY2hhbmdlLCBhIG5ldyBcInZlcnNpb25cIiBvZlxuICogdGhlIGZ1bmN0aW9uIGlzIGNyZWF0ZWQgKGxleGljYWxseSB0aGUgc2FtZSwgYnV0IGNsb3Npbmcgb3ZlciBhIGRpZmZlcmVudCBzY29wZSkuXG4gKlxuICogb25SZXF1ZXN0VXBkYXRlIGlzIGN1cnJlbnRseSBvbmx5IHJlYWQgb24gdGhlIGZpcnN0IGNhbGwsIHNvIGNoYW5nZXMgdG8gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUR5bmFtaWMoc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICAvLyBJZiBubyBvblJlcXVlc3RVcGRhdGUgaXMgcHJvdmlkZWQsIGRlZmF1bHQgdG8gcmVxdWVzdGluZyB1cGRhdGUgb24gdGhlIGN1cnJlbnQgY29udGV4dFxuICAgIGNvbnN0IG9ydSA9IG9uUmVxdWVzdFVwZGF0ZSB8fCAoKCkgPT4ge1xuICAgICAgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayBFeGVjdXRpb25Db250ZXh0cyBjcmVhdGVkIChhbmQgbm90IHlldCB0ZXJtaW5hdGVkKSBzbyB3ZSBjYW4gdGVybWluYXRlIHRoZW0gdXBvbiBjbGVhbnVwXG4gICAgZGF0YS5hY3RpdmVDb250ZXh0cyA9IG5ldyBTZXQoKTtcblxuICAgIC8vIENyZWF0ZSBcImZhY3RvcnlcIiBmdW5jdGlvbiB0byBpbnN0YW50aWF0ZSBuZXcgY29udGV4dHNcbiAgICBkYXRhLmNyZWF0ZUNvbnRleHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjdHggPSBuZXcgRXhlY3V0aW9uQ29udGV4dChkYXRhLnN0cmVhbUZ1bmMsIG9ydSwgKCkgPT4geyBkYXRhLmFjdGl2ZUNvbnRleHRzLmRlbGV0ZShjdHgpOyB9KTtcbiAgICAgIGRhdGEuYWN0aXZlQ29udGV4dHMuYWRkKGN0eCk7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH07XG5cbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG4gICAgcmVjb3JkLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGN0eCBvZiBkYXRhLmFjdGl2ZUNvbnRleHRzKSB7XG4gICAgICAgIGN0eC50ZXJtaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBzdHJlYW0gZnVuY3Rpb24gaW4gcmVjb3JkIGFuZCBhbGwgYWN0aXZlIGNvbnRleHRzLlxuICByZWNvcmQuZGF0YS5zdHJlYW1GdW5jID0gc3RyZWFtRnVuYztcbiAgZm9yIChjb25zdCBjdHggb2YgcmVjb3JkLmRhdGEuYWN0aXZlQ29udGV4dHMpIHtcbiAgICBjdHguX3NldFN0cmVhbUZ1bmMoc3RyZWFtRnVuYyk7XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGEuY3JlYXRlQ29udGV4dDtcbn1cblxuLyoqXG4gKiBOT1RFOiByZWR1Y2VyRnVuYyBzaG91bGQgYmUgcHVyZS1wb2ludHdpc2UsIE5PVCBhIHN0cmVhbSBmdW5jXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKGFjdGlvbkV2dHMsIHJlZHVjZXJGdW5jLCBpbml0aWFsU3RhdGUpIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VWYXIoaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgYWN0aW9uID0gdXNlRXZlbnRSZWNlaXZlcihhY3Rpb25FdnRzKTtcbiAgaWYgKGFjdGlvbikge1xuICAgIHN0YXRlLmN1cnJlbnQgPSByZWR1Y2VyRnVuYyhhY3Rpb24udmFsdWUsIHN0YXRlLmN1cnJlbnQpO1xuICB9XG4gIHJldHVybiBzdGF0ZS5jdXJyZW50O1xufVxuXG4vKipcbiAqIFRPRE86IENvdWxkL3Nob3VsZCB0aGlzIHRha2UgYW4gb3B0aW9uYWwgb25SZXF1ZXN0VXBkYXRlIHBhcmFtZXRlcj9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hY2hpbmUoc3RhdGVzLCBpbml0aWFsVHJhbnNpdGlvbikge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICBjb25zdCB0YWtlVHJhbnNpdGlvbiA9ICh0cmFucykgPT4ge1xuICAgIC8vIElmIHRoZXJlJ3MgYW4gb2xkIGNvbnRleHQsIHRlcm1pbmF0ZSBpdFxuICAgIGlmIChyZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0KSB7XG4gICAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IFtuZXdTdGF0ZSwgbmV3U3RhdGVBcmddID0gdHJhbnM7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCBhbmQgc3RvcmUgaXQgaW4gcmVjb3JkIChidXQgZG9uJ3QgdXBkYXRlIGl0KVxuICAgIGNvbnN0IG5ld0N0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHN0YXRlc1tuZXdTdGF0ZV0sICgpID0+IHsgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7IH0pO1xuXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0ID0gbmV3Q3R4O1xuICAgIHJlY29yZC5kYXRhLmFjdGl2ZUFyZ3VtZW50ID0gbmV3U3RhdGVBcmc7XG4gIH07XG5cbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG5cbiAgICB0YWtlVHJhbnNpdGlvbihpbml0aWFsVHJhbnNpdGlvbik7IC8vIHRoaXMgd2lsbCBzZXQgc3R1ZmYgaW4gcmVjb3JkLmRhdGFcblxuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH07XG4gIH1cblxuICBsZXQgcmV0dmFsO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFNldCB0aGUgc3RhdGUgZnVuY3Rpb24gaW4gdGhlIGFjdGl2ZSBjb250ZXh0IChpbiBjYXNlIGl0IGNoYW5nZWQpXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlQ29udGV4dC5fc2V0U3RyZWFtRnVuYyhzdGF0ZXNbcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGVdKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGNvbnRleHRcbiAgICBjb25zdCBbdG1wUmV0dmFsLCB0cmFuc2l0aW9uRXZ0XSA9IHJlY29yZC5kYXRhLmFjdGl2ZUNvbnRleHQudXBkYXRlKHJlY29yZC5kYXRhLmFjdGl2ZUFyZ3VtZW50KTtcbiAgICByZXR2YWwgPSB0bXBSZXR2YWw7XG5cbiAgICAvLyBXYXMgdGhlcmUgYSB0cmFuc2l0aW9uIGV2ZW50P1xuICAgIC8vIE5PVEU6IEJlY2F1c2Ugd2UgdHJhbnNpdGlvbiB1cG9uIGZpcnN0IGV2ZW4gb24gdGhpcyBzdHJlYW0sIHdlIGNhbiBzb3J0IG9mIHNwZWNpYWwtY2FzZSB0aGlzIGNoZWNrXG4gICAgaWYgKHRyYW5zaXRpb25FdnQpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRXZ0LnZhbHVlO1xuICAgICAgdGFrZVRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBubyB0cmFuc2l0aW9uXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "3c7995ba1ebaeb8df6c62360cd2406d1.mp3";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYW1lbl9icmVhay5tcDM/ZTZjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIscUJBQXVCIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIzYzc5OTViYTFlYmFlYjhkZjZjNjIzNjBjZDI0MDZkMS5tcDNcIjsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/riv.js\nvar riv = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useAsyncEventEmitter,\n  useEventReceiver,\n  useDynamic,\n  useReducer,\n  useMachine\n} = __webpack_require__(0);\n\nconst amen_break_url = __webpack_require__(1);\n\nfunction showString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'border: 1px solid red; color: black; font-size: 24px; padding: 5px; margin-top: 20px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = 'showString: ' + (v === undefined ? '(undefined)' : v.toString());\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvt, emitClick] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvt;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction mousePosition() {\n  const requestUpdate = useRequestUpdate();\n  const position = useVar({\n    x: 0,\n    y: 0\n  }); // we can't poll position, so start it at origin\n\n  useInitialize(() => {\n    const onMouseMove = e => {\n      position.current = {\n        x: e.clientX || e.pageX,\n        y: e.clientY || e.pageY\n      };\n      requestUpdate();\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n  return position.current;\n}\n\nfunction random(repickEvt) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvt);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, {\n          value: undefined\n        }, sampleRate.current);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, undefined, sampleRate.current); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvt, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvt);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvt, emitTick] = useAsyncEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvt;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\n\nfunction loadAudioAsArray(url) {\n  const requestUpdate = useRequestUpdate();\n  const pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(() => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    let cleanedUp = false;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = () => {\n      const audioData = request.response;\n      audioCtx.decodeAudioData(audioData, buffer => {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return () => {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nfunction integral(integrandFunc, time, initialValue = 0) {\n  const accum = useVar(initialValue);\n  const prevTime = useVar(time);\n  const integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\n\nfunction expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(currentValue => speedConstant * (targetValue - currentValue), time, initialValue);\n}\n\nfunction redCircle(position, radius = 25) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'position: absolute; border-radius: 50%; background: red; pointer-events: none; user-select: none';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  const p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  const halfRadius = 0.5 * radius;\n  elem.current.style.left = p.x - halfRadius + 'px';\n  elem.current.style.top = p.y - halfRadius + 'px';\n  elem.current.style.width = radius + 'px';\n  elem.current.style.height = radius + 'px';\n}\n\nfunction followAtSpeed2d(target, speed, time, initial) {\n  const pos = useVar(initial);\n  const prevTime = useVar(time);\n  const dt = time - prevTime.current;\n  const delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\n\nfunction eventWhen(condition, valueToEmit) {\n  const prevCondition = useVar(false);\n  const bcond = !!condition;\n  const retval = bcond && !prevCondition.current ? {\n    value: valueToEmit\n  } : undefined;\n  prevCondition.current = bcond;\n  return retval;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nfunction eventAfter(seconds, valueToEmit) {\n  const [evt, emit] = useAsyncEventEmitter();\n  const value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(() => {\n    const timerId = setTimeout(() => {\n      emit(value.current);\n    }, 1000 * seconds);\n    return () => {\n      clearTimeout(timerId);\n    };\n  });\n  return evt;\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    showString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    showString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    showString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    showString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvt) => {\n      const noise = random(advanceFrameEvt) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvt = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvt) => {\n      const noise = random(advanceFrameEvt) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvt, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvt = mouseClickEvts();\n    const click = useEventReceiver(clickEvt);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    showString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvt = mouseClickEvts();\n    const click = useEventReceiver(clickEvt);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    showString(nums.join(' '));\n  }\n}, {\n  name: 'record player spin up/down, hold mouse down and release',\n  main: () => {\n    const pcm = loadAudioAsArray(amen_break_url);\n    showString(pcm.length > 1 ? 'loaded audio' : 'loading audio...');\n    audioDriver((audioTime, advanceFrameEvt, sampleRate) => {\n      const targetSpeed = mouseDown() ? sampleRate : 0;\n      const speed = expFollow(targetSpeed, 3, audioTime, 0);\n      const pos = Math.floor(integral(() => speed, audioTime));\n      return pcm[pos % pcm.length]; // modulo so as to loop\n    });\n  }\n}, {\n  name: 'circle follows mouse',\n  main: () => {\n    redCircle(mousePosition());\n  }\n}, {\n  name: 'circle follows mouse at limited speed',\n  main: () => {\n    const time = animationTime();\n    const mpos = mousePosition();\n    redCircle(followAtSpeed2d(mpos, 300, time, mpos));\n  }\n}, {\n  name: 'circle moves halfway to mouse with each click',\n  main: () => {\n    const midpoint = (a, b) => ({\n      x: 0.5 * (a.x + b.x),\n      y: 0.5 * (a.y + b.y)\n    });\n\n    const mpos = mousePosition();\n    const clickEvt = mouseClickEvts();\n    const cpos = useReducer(clickEvt, (_, prevState) => midpoint(prevState, mpos), {\n      x: 0,\n      y: 0\n    });\n    redCircle(cpos);\n  }\n}, {\n  name: 'roaming circle (state machine)',\n  main: () => {\n    const time = animationTime();\n    const position = useMachine({\n      moving: initialPosition => {\n        const targetPosition = {\n          x: 500 * random(),\n          y: 500 * random()\n        };\n        const position = followAtSpeed2d(targetPosition, 300, time, initialPosition);\n        const arrived = position.x === targetPosition.x && position.y === targetPosition.y;\n        return [position, eventWhen(arrived, ['resting', position])];\n      },\n      resting: initialPosition => {\n        return [initialPosition, eventAfter(random(), ['moving', initialPosition])];\n      }\n    }, ['moving', {\n      x: 0,\n      y: 0\n    }]);\n    redCircle(position);\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(riv[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUFzeW5jRXZlbnRFbWl0dGVyIiwidXNlRXZlbnRSZWNlaXZlciIsInVzZUR5bmFtaWMiLCJ1c2VSZWR1Y2VyIiwidXNlTWFjaGluZSIsInJlcXVpcmUiLCJhbWVuX2JyZWFrX3VybCIsInNob3dTdHJpbmciLCJ2IiwiZWxlbSIsImN1cnJlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJhbmltYXRpb25UaW1lIiwicmVxdWVzdFVwZGF0ZSIsInRpbWUiLCJyZXFJZCIsIm9uRnJhbWUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbkZyYW1lRXZ0cyIsImZyYW1lRXZ0cyIsImVtaXRGcmFtZSIsImNvdW50RXZlbnRzIiwiZXZ0cyIsImNvdW50IiwiZXZlbnQiLCJtb3VzZUNsaWNrRXZ0cyIsImNsaWNrRXZ0IiwiZW1pdENsaWNrIiwib25Nb3VzZURvd24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdXNlRG93biIsImlzRG93biIsIm9uTW91c2VVcCIsIm1vdXNlUG9zaXRpb24iLCJwb3NpdGlvbiIsIngiLCJ5Iiwib25Nb3VzZU1vdmUiLCJlIiwiY2xpZW50WCIsInBhZ2VYIiwiY2xpZW50WSIsInBhZ2VZIiwicmFuZG9tIiwicmVwaWNrRXZ0IiwidmFsIiwiTWF0aCIsInJlcGljayIsImF1ZGlvRHJpdmVyIiwiZ2VuZXJhdG9yIiwiY3JlYXRlR2VuZXJhdG9yIiwiZ2VuZXJhdG9yQ3R4IiwiZnJhbWVDb3VudCIsInNhbXBsZVJhdGUiLCJCVUZGRVJfU0laRSIsImF1ZGlvQ29udGV4dCIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNjcmlwdE5vZGUiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImJ1ZmZlciIsIm91dHB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaSIsImxlbmd0aCIsInVwZGF0ZSIsInZhbHVlIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiZGlzY29ubmVjdCIsImNsb3NlIiwic2FtcGxlVXBvbiIsInRvU2FtcGxlIiwidXBvbkV2dCIsImluaXRpYWxWYWx1ZSIsImhlbGQiLCJ1cG9uIiwiZXZlcnlTZWNvbmQiLCJ0aWNrRXZ0IiwiZW1pdFRpY2siLCJvbkludGVydmFsIiwidGltZXJJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImxvYWRBdWRpb0FzQXJyYXkiLCJ1cmwiLCJwY20iLCJhdWRpb0N0eCIsImNsZWFuZWRVcCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJhdWRpb0RhdGEiLCJyZXNwb25zZSIsImRlY29kZUF1ZGlvRGF0YSIsInNlbmQiLCJhYm9ydCIsImNvbnNvbGVMb2ciLCJjb25zb2xlIiwibG9nIiwiaW50ZWdyYWwiLCJpbnRlZ3JhbmRGdW5jIiwiYWNjdW0iLCJwcmV2VGltZSIsImludGVncmFuZCIsImV4cEZvbGxvdyIsInRhcmdldFZhbHVlIiwic3BlZWRDb25zdGFudCIsImN1cnJlbnRWYWx1ZSIsInJlZENpcmNsZSIsInJhZGl1cyIsInAiLCJoYWxmUmFkaXVzIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZm9sbG93QXRTcGVlZDJkIiwidGFyZ2V0Iiwic3BlZWQiLCJpbml0aWFsIiwicG9zIiwiZHQiLCJkZWx0YSIsImRpc3QiLCJzcXJ0IiwiZXZlbnRXaGVuIiwiY29uZGl0aW9uIiwidmFsdWVUb0VtaXQiLCJwcmV2Q29uZGl0aW9uIiwiYmNvbmQiLCJyZXR2YWwiLCJldmVudEFmdGVyIiwic2Vjb25kcyIsImV2dCIsImVtaXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwibmFtZSIsIm1haW4iLCJ0b0ZpeGVkIiwibWQiLCJhdWRpb1RpbWUiLCJhZHZhbmNlRnJhbWVFdnQiLCJub2lzZSIsImxhc3RDbGlja1RpbWUiLCJJbmZpbml0eSIsImRlY2F5aW5nR2FpbiIsImV4cCIsImNsaWNrIiwiY3JlYXRlQ291bnRlciIsImFjdGl2ZUNvdW50ZXIiLCJ0ZXJtaW5hdGUiLCJkaXNwbGF5ZWRDb3VudCIsImNyZWF0ZUNsb2NrIiwiY2xvY2tBcnJheSIsInB1c2giLCJudW1zIiwibWFwIiwiY2xvY2siLCJqb2luIiwidGFyZ2V0U3BlZWQiLCJmbG9vciIsIm1wb3MiLCJtaWRwb2ludCIsImEiLCJiIiwiY3BvcyIsIl8iLCJwcmV2U3RhdGUiLCJtb3ZpbmciLCJpbml0aWFsUG9zaXRpb24iLCJ0YXJnZXRQb3NpdGlvbiIsImFycml2ZWQiLCJyZXN0aW5nIiwicHJvZ3JhbUxpc3RFbGVtIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9ncmFtU291cmNlRWxlbSIsImN1cnJlbnRDb250ZXh0IiwiZml4SW5kZW50IiwiY29kZSIsInNwbGl0IiwibGluZSIsImlkeCIsInN1YnN0ciIsInN0YXJ0UHJvZ3JhbSIsInByb2dyYW0iLCJjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dCIsInByb2ciLCJwcm9ncmFtcyIsImFuY2hvckVsZW0iLCJzZXRBdHRyaWJ1dGUiLCJwcmV2ZW50RGVmYXVsdCIsIml0ZW1FbGVtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBLE1BQU07QUFBRUEsUUFBRjtBQUFVQyxrQkFBVjtBQUE0QkMsZUFBNUI7QUFBMkNDLHNCQUEzQztBQUFpRUMsa0JBQWpFO0FBQW1GQyxZQUFuRjtBQUErRkMs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dU0sVUFBUSxDQUFDbE0sV0FBVCxDQUFxQitMLFVBQXJCO0FBRUFmLGlCQUFlLENBQUNoTCxXQUFoQixDQUE0QmtNLFFBQTVCO0FBQ0Q7O0FBRURSLFlBQVksQ0FBQ0ksUUFBUSxDQUFDLENBQUQsQ0FBVCxDQUFaIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOT1RFOiBVc2luZyByZXF1aXJlIGluc3RlYWQgb2YgaW1wb3J0IGhlcmUgbWFrZXMgdGhlIHRoaW5nIHdoZXJlIHdlIHByaW50IHByb2dyYW0gdGV4dCB3b3JrIGJldHRlci5cbmNvbnN0IHsgdXNlVmFyLCB1c2VSZXF1ZXN0VXBkYXRlLCB1c2VJbml0aWFsaXplLCB1c2VBc3luY0V2ZW50RW1pdHRlciwgdXNlRXZlbnRSZWNlaXZlciwgdXNlRHluYW1pYywgdXNlUmVkdWNlciwgdXNlTWFjaGluZSB9ID0gcmVxdWlyZSgnLi9yaXYnKTtcbmNvbnN0IGFtZW5fYnJlYWtfdXJsID0gcmVxdWlyZSgnLi9hbWVuX2JyZWFrLm1wMycpO1xuXG5mdW5jdGlvbiBzaG93U3RyaW5nKHYpIHtcbiAgY29uc3QgZWxlbSA9IHVzZVZhcihudWxsKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBlbGVtLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtLmN1cnJlbnQuc3R5bGUuY3NzVGV4dCA9ICdib3JkZXI6IDFweCBzb2xpZCByZWQ7IGNvbG9yOiBibGFjazsgZm9udC1zaXplOiAyNHB4OyBwYWRkaW5nOiA1cHg7IG1hcmdpbi10b3A6IDIwcHgnO1xuICAgIGVsZW0uY3VycmVudC50ZXh0Q29udGVudCA9ICcodW5kZWZpbmVkKSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtLmN1cnJlbnQpO1xuICAgIH1cbiAgfSlcblxuICBlbGVtLmN1cnJlbnQudGV4dENvbnRlbnQgPSAnc2hvd1N0cmluZzogJyArICgodiA9PT0gdW5kZWZpbmVkKSA/ICcodW5kZWZpbmVkKScgOiB2LnRvU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRpb25UaW1lKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCB0aW1lID0gdXNlVmFyKCk7XG4gIGNvbnN0IHJlcUlkID0gdXNlVmFyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICB0aW1lLmN1cnJlbnQgPSAwLjAwMSp0O1xuICAgICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTsgLy8gcmVxdWVzdCBhbm90aGVyXG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXFJZC5jdXJyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvbkZyYW1lRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2ZyYW1lRXZ0cywgZW1pdEZyYW1lXSA9IHVzZUFzeW5jRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICBlbWl0RnJhbWUoKTtcbiAgICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7IC8vIHJlcXVlc3QgYW5vdGhlclxuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxSWQuY3VycmVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZnJhbWVFdnRzO1xufVxuXG5mdW5jdGlvbiBjb3VudEV2ZW50cyhldnRzKSB7XG4gIGNvbnN0IGNvdW50ID0gdXNlVmFyKDApO1xuICBjb25zdCBldmVudCA9IHVzZUV2ZW50UmVjZWl2ZXIoZXZ0cyk7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgY291bnQuY3VycmVudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50LmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdXNlQ2xpY2tFdnRzKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBbY2xpY2tFdnQsIGVtaXRDbGlja10gPSB1c2VBc3luY0V2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgZW1pdENsaWNrKCk7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbGlja0V2dDtcbn1cblxuZnVuY3Rpb24gbW91c2VEb3duKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBpc0Rvd24gPSB1c2VWYXIoZmFsc2UpOyAvLyB3ZSBjYW4ndCBwb2xsIGRvd24tbmVzcywgc28gd2UgYXNzdW1lIGl0J3MgaW5pdGlhbGx5IG5vdCBkb3duXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSAoKSA9PiB7XG4gICAgICBpc0Rvd24uY3VycmVudCA9IHRydWU7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIGlzRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNEb3duLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdXNlUG9zaXRpb24oKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlVmFyKHt4OiAwLCB5OiAwfSk7IC8vIHdlIGNhbid0IHBvbGwgcG9zaXRpb24sIHNvIHN0YXJ0IGl0IGF0IG9yaWdpblxuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGUpID0+IHtcbiAgICAgIHBvc2l0aW9uLmN1cnJlbnQgPSB7XG4gICAgICAgIHg6IGUuY2xpZW50WCB8fCBlLnBhZ2VYLFxuICAgICAgICB5OiBlLmNsaWVudFkgfHwgZS5wYWdlWSxcbiAgICAgIH07XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbShyZXBpY2tFdnQpIHtcbiAgY29uc3QgdmFsID0gdXNlVmFyKE1hdGgucmFuZG9tKCkpO1xuICBjb25zdCByZXBpY2sgPSB1c2VFdmVudFJlY2VpdmVyKHJlcGlja0V2dCk7XG5cbiAgaWYgKHJlcGljaykge1xuICAgIHZhbC5jdXJyZW50ID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuXG4gIHJldHVybiB2YWwuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYXVkaW9Ecml2ZXIoZ2VuZXJhdG9yKSB7XG4gIGNvbnN0IGNyZWF0ZUdlbmVyYXRvciA9IHVzZUR5bmFtaWMoZ2VuZXJhdG9yKTtcbiAgY29uc3QgZ2VuZXJhdG9yQ3R4ID0gdXNlVmFyKCk7XG4gIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VWYXIoMCk7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSB1c2VWYXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBnZW5lcmF0b3JDdHguY3VycmVudCA9IGNyZWF0ZUdlbmVyYXRvcigpO1xuXG4gICAgY29uc3QgQlVGRkVSX1NJWkUgPSAxMDI0O1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgIGNvbnN0IHNjcmlwdE5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKEJVRkZFUl9TSVpFLCAwLCAxKTsgLy8gMCBpbnB1dCBjaGFubmVscywgMSBvdXRwdXQgY2hhbm5lbFxuICAgIHNjcmlwdE5vZGUub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyID0gZS5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBnZW5lcmF0b3JDdHguY3VycmVudC51cGRhdGUoZnJhbWVDb3VudC5jdXJyZW50L3NhbXBsZVJhdGUuY3VycmVudCwge3ZhbHVlOiB1bmRlZmluZWR9LCBzYW1wbGVSYXRlLmN1cnJlbnQpO1xuICAgICAgICBmcmFtZUNvdW50LmN1cnJlbnQrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdE5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gICAgc2FtcGxlUmF0ZS5jdXJyZW50ID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICB9O1xuICB9KTtcblxuICAvKipcbiAgICogTW9zdCBvZiBvdXIgZ2VuZXJhdG9yIHVwZGF0aW5nIHdpbGwgaGFwcGVuIGluIHRoZSBhdWRpbyBwcm9jZXNzaW5nIGNhbGxiYWNrIGFib3ZlLlxuICAgKiBUaGlzIHVwZGF0ZSBoZXJlIGlzIGZvciB3aGVuIHRoZSBhdWRpb0RyaXZlciB1cGRhdGUgaXMgY2FsbGVkLCBlLmcuIHdoZW4gYW4gb3V0ZXIgc2NvcGVcbiAgICogcmVmZXJlbmNlIHRoYXQgdGhlIGdlbmVyYXRvciBkZXBlbmRzIG9uIGhhcyBjaGFuZ2VkLiBTbyB3ZSBtdXN0IHVwZGF0ZSB0aGUgZ2VuZXJhdG9yLFxuICAgKiBidXQgZG9uJ3QgbmVlZCBpdHMgb3V0cHV0IGFtcGxpdHVkZS5cbiAgICovXG4gIGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCB1bmRlZmluZWQsIHNhbXBsZVJhdGUuY3VycmVudCk7IC8vIE5PVEU6IHdlIGRpc2NhcmQgcmV0dmFsXG59XG5cbmZ1bmN0aW9uIHNhbXBsZVVwb24odG9TYW1wbGUsIHVwb25FdnQsIGluaXRpYWxWYWx1ZSkge1xuICBjb25zdCBoZWxkID0gdXNlVmFyKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHVwb24gPSB1c2VFdmVudFJlY2VpdmVyKHVwb25FdnQpO1xuXG4gIGlmICh1cG9uKSB7XG4gICAgaGVsZC5jdXJyZW50ID0gdG9TYW1wbGU7XG4gIH1cblxuICByZXR1cm4gaGVsZC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBldmVyeVNlY29uZCgpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW3RpY2tFdnQsIGVtaXRUaWNrXSA9IHVzZUFzeW5jRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25JbnRlcnZhbCA9ICgpID0+IHtcbiAgICAgIGVtaXRUaWNrKCk7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRJbnRlcnZhbChvbkludGVydmFsLCAxMDAwKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNsZWFySW50ZXJ2YWwodGltZXJJZCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGlja0V2dDtcbn1cblxuLyoqXG4gKiBVbnRpbCBhdWRpbyBpcyBsb2FkZWQgYW5kIGRlY29kZWQsIGEgc2luZ2xlLXNhbXBsZSBidWZmZXIgb2Ygc2lsZW5jZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gbG9hZEF1ZGlvQXNBcnJheSh1cmwpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcGNtID0gdXNlVmFyKFswXSk7IC8vIHVudGlsIGxvYWRlZCwganVzdCByZXR1cm4gc2luZ2xlIHNhbXBsZSBvZiBzaWxlbmNlXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3QgYXVkaW9DdHggPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBsZXQgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBidWZmZXIgPT4ge1xuICAgICAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgICAgIHBjbS5jdXJyZW50ID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgcmVxdWVzdC5hYm9ydCgpOyAvLyBpdCdzIHNhZmUgdG8gYWx3YXlzIGFib3J0IGhlcmUuIGlmIGFscmVhZHkgY29tcGxldGVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcblxuICAgICAgLy8gZGVjb2RlQXVkaW9EYXRhIGNhbm5vdCBiZSBjYW5jZWxlZC4gU28gdG8gYmUgY29ycmVjdCwgd2UgbXVzdCBzZXQgYSBmbGFnIGhlcmUgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IGRlY29kaW5nIGlzIGlnbm9yZWRcbiAgICAgIGNsZWFuZWRVcCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGNtLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2codikge1xuICBjb25zb2xlLmxvZyh2KTtcbn1cblxuZnVuY3Rpb24gaW50ZWdyYWwoaW50ZWdyYW5kRnVuYywgdGltZSwgaW5pdGlhbFZhbHVlID0gMCkge1xuICBjb25zdCBhY2N1bSA9IHVzZVZhcihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBwcmV2VGltZSA9IHVzZVZhcih0aW1lKTtcblxuICBjb25zdCBpbnRlZ3JhbmQgPSBpbnRlZ3JhbmRGdW5jKGFjY3VtLmN1cnJlbnQsIHByZXZUaW1lLmN1cnJlbnQpO1xuICBhY2N1bS5jdXJyZW50ICs9ICh0aW1lIC0gcHJldlRpbWUuY3VycmVudCkqaW50ZWdyYW5kO1xuXG4gIHByZXZUaW1lLmN1cnJlbnQgPSB0aW1lO1xuXG4gIHJldHVybiBhY2N1bS5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBleHBGb2xsb3codGFyZ2V0VmFsdWUsIHNwZWVkQ29uc3RhbnQsIHRpbWUsIGluaXRpYWxWYWx1ZSkge1xuICByZXR1cm4gaW50ZWdyYWwoY3VycmVudFZhbHVlID0+IHNwZWVkQ29uc3RhbnQqKHRhcmdldFZhbHVlIC0gY3VycmVudFZhbHVlKSwgdGltZSwgaW5pdGlhbFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcmVkQ2lyY2xlKHBvc2l0aW9uLCByYWRpdXMgPSAyNSkge1xuICBjb25zdCBlbGVtID0gdXNlVmFyKG51bGwpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGVsZW0uY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW0uY3VycmVudC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgYm9yZGVyLXJhZGl1czogNTAlOyBiYWNrZ3JvdW5kOiByZWQ7IHBvaW50ZXItZXZlbnRzOiBub25lOyB1c2VyLXNlbGVjdDogbm9uZSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtLmN1cnJlbnQpO1xuICAgIH1cbiAgfSlcblxuICBjb25zdCBwID0gcG9zaXRpb24gfHwge3g6IDAsIHk6IDB9O1xuICBpZiAocmFkaXVzIDwgMCkge1xuICAgIHJhZGl1cyA9IDA7XG4gIH1cbiAgY29uc3QgaGFsZlJhZGl1cyA9IDAuNSpyYWRpdXM7XG5cbiAgZWxlbS5jdXJyZW50LnN0eWxlLmxlZnQgPSAocC54IC0gaGFsZlJhZGl1cykgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUudG9wID0gKHAueSAtIGhhbGZSYWRpdXMpICsgJ3B4JztcbiAgZWxlbS5jdXJyZW50LnN0eWxlLndpZHRoID0gcmFkaXVzICsgJ3B4JztcbiAgZWxlbS5jdXJyZW50LnN0eWxlLmhlaWdodCA9IHJhZGl1cyArICdweCc7XG59XG5cbmZ1bmN0aW9uIGZvbGxvd0F0U3BlZWQyZCh0YXJnZXQsIHNwZWVkLCB0aW1lLCBpbml0aWFsKSB7XG4gIGNvbnN0IHBvcyA9IHVzZVZhcihpbml0aWFsKTtcbiAgY29uc3QgcHJldlRpbWUgPSB1c2VWYXIodGltZSk7XG5cbiAgY29uc3QgZHQgPSB0aW1lIC0gcHJldlRpbWUuY3VycmVudDtcbiAgY29uc3QgZGVsdGEgPSB7eDogdGFyZ2V0LngtcG9zLmN1cnJlbnQueCwgeTogdGFyZ2V0LnktcG9zLmN1cnJlbnQueX07XG4gIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZGVsdGEueCpkZWx0YS54ICsgZGVsdGEueSpkZWx0YS55KTtcbiAgaWYgKHNwZWVkKmR0ID49IGRpc3QpIHtcbiAgICAvLyBKdW1wIHRvIHRhcmdldCBwb3NpdGlvblxuICAgIHBvcy5jdXJyZW50ID0gdGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIE5PVEU6IFdlIG11c3Qgbm90IG11dGF0ZSBwb3MuY3VycmVudCwgc2luY2Ugd2UgcmV0dXJuIHRoYXRcbiAgICBwb3MuY3VycmVudCA9IHtcbiAgICAgIHg6IHBvcy5jdXJyZW50LnggKyBkdCpzcGVlZCpkZWx0YS54L2Rpc3QsXG4gICAgICB5OiBwb3MuY3VycmVudC55ICsgZHQqc3BlZWQqZGVsdGEueS9kaXN0LFxuICAgIH07XG4gIH1cblxuICBwcmV2VGltZS5jdXJyZW50ID0gdGltZTtcblxuICByZXR1cm4gcG9zLmN1cnJlbnQ7XG59XG5cbi8qKlxuICogTm90ZSB0aGF0IHRoaXMgX3dpbGxfIGZpcmUgaW4gZmlyc3QgY2FsbCBpZiBjb25kaXRpb24gc3RhcnRzIHRydXRoeVxuICovXG5mdW5jdGlvbiBldmVudFdoZW4oY29uZGl0aW9uLCB2YWx1ZVRvRW1pdCkge1xuICBjb25zdCBwcmV2Q29uZGl0aW9uID0gdXNlVmFyKGZhbHNlKTtcblxuICBjb25zdCBiY29uZCA9ICEhY29uZGl0aW9uO1xuXG4gIGNvbnN0IHJldHZhbCA9IChiY29uZCAmJiAhcHJldkNvbmRpdGlvbi5jdXJyZW50KSA/IHt2YWx1ZTogdmFsdWVUb0VtaXR9IDogdW5kZWZpbmVkO1xuICBwcmV2Q29uZGl0aW9uLmN1cnJlbnQgPSBiY29uZDtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuXG4vKipcbiAqIE5vdGUgdGhhdCBzZWNvbmRzIGFyZ3VtZW50IGlzIG9ubHkgcmVhZCBpbml0aWFsbHkuIEJ1dCB2YWx1ZVRvRW1pdCBpcyByZS1yZWFkIG9uIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gZXZlbnRBZnRlcihzZWNvbmRzLCB2YWx1ZVRvRW1pdCkge1xuICBjb25zdCBbZXZ0LCBlbWl0XSA9IHVzZUFzeW5jRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IHZhbHVlID0gdXNlVmFyKHZhbHVlVG9FbWl0KTtcblxuICB2YWx1ZS5jdXJyZW50ID0gdmFsdWVUb0VtaXQ7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3QgdGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZW1pdCh2YWx1ZS5jdXJyZW50KTtcbiAgICB9LCAxMDAwKnNlY29uZHMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGV2dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgW1xuICB7XG4gICAgbmFtZTogJ2RvIG5vdGhpbmcnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnYW5pbWF0aW9uIHRpbWUnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcoYW5pbWF0aW9uVGltZSgpLnRvRml4ZWQoMykpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjb3VudCBjbGlja3MnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcoY291bnRFdmVudHMobW91c2VDbGlja0V2dHMoKSkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdpcyBtb3VzZSBidXR0b24gZG93bicsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhtb3VzZURvd24oKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3JhbmRvbSBudW1iZXIsIGNsaWNrIHRvIHJlcGljaycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhyYW5kb20obW91c2VDbGlja0V2dHMoKSkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdhdWRpbyBub2lzZSB3aGVuIG1vdXNlIGlzIGRvd24nLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IG1kID0gbW91c2VEb3duKCk7XG4gICAgICBhdWRpb0RyaXZlcigoYXVkaW9UaW1lLCBhZHZhbmNlRnJhbWVFdnQpID0+IHtcbiAgICAgICAgY29uc3Qgbm9pc2UgPSByYW5kb20oYWR2YW5jZUZyYW1lRXZ0KSAtIDAuNTtcbiAgICAgICAgcmV0dXJuIG1kID8gbm9pc2UgOiAwO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2RlY2F5aW5nIG5vaXNlIHVwb24gY2xpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0ID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dCkgPT4ge1xuICAgICAgICBjb25zdCBub2lzZSA9IHJhbmRvbShhZHZhbmNlRnJhbWVFdnQpIC0gMC41O1xuICAgICAgICBjb25zdCBsYXN0Q2xpY2tUaW1lID0gc2FtcGxlVXBvbihhdWRpb1RpbWUsIGNsaWNrRXZ0LCAtSW5maW5pdHkpO1xuICAgICAgICBjb25zdCBkZWNheWluZ0dhaW4gPSBNYXRoLmV4cCg1KihsYXN0Q2xpY2tUaW1lIC0gYXVkaW9UaW1lKSk7XG4gICAgICAgIHJldHVybiBkZWNheWluZ0dhaW4qbm9pc2U7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmVzZXR0aW5nIGZyYW1lIGNvdW50ZXIsIGNsaWNrIHRvIHJlc2V0JyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZUV2dHMgPSBhbmltYXRpb25GcmFtZUV2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0ID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrID0gdXNlRXZlbnRSZWNlaXZlcihjbGlja0V2dCk7XG4gICAgICBjb25zdCBjcmVhdGVDb3VudGVyID0gdXNlRHluYW1pYyhjb3VudEV2ZW50cyk7XG4gICAgICBjb25zdCBhY3RpdmVDb3VudGVyID0gdXNlVmFyKCk7XG5cbiAgICAgIGlmIChjbGljaykge1xuICAgICAgICBpZiAoYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheWVkQ291bnQgPSBhY3RpdmVDb3VudGVyLmN1cnJlbnQudXBkYXRlKGZyYW1lRXZ0cyk7XG4gICAgICBzaG93U3RyaW5nKGRpc3BsYXllZENvdW50KTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdkeW5hbWljIGFycmF5IG9mIGFzeW5jIGNsb2NrcywgY2xpY2sgdG8gYWRkJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBjbGlja0V2dCA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjbGljayA9IHVzZUV2ZW50UmVjZWl2ZXIoY2xpY2tFdnQpO1xuICAgICAgY29uc3QgY3JlYXRlQ2xvY2sgPSB1c2VEeW5hbWljKCgpID0+IGNvdW50RXZlbnRzKGV2ZXJ5U2Vjb25kKCkpKTtcbiAgICAgIGNvbnN0IGNsb2NrQXJyYXkgPSB1c2VWYXIoW10pO1xuXG4gICAgICBpZiAoY2xpY2spIHtcbiAgICAgICAgY2xvY2tBcnJheS5jdXJyZW50LnB1c2goY3JlYXRlQ2xvY2soKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG51bXMgPSBjbG9ja0FycmF5LmN1cnJlbnQubWFwKGNsb2NrID0+IGNsb2NrLnVwZGF0ZSgpKTtcbiAgICAgIHNob3dTdHJpbmcobnVtcy5qb2luKCcgJykpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3JlY29yZCBwbGF5ZXIgc3BpbiB1cC9kb3duLCBob2xkIG1vdXNlIGRvd24gYW5kIHJlbGVhc2UnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjbSA9IGxvYWRBdWRpb0FzQXJyYXkoYW1lbl9icmVha191cmwpO1xuICAgICAgc2hvd1N0cmluZyhwY20ubGVuZ3RoID4gMSA/ICdsb2FkZWQgYXVkaW8nIDogJ2xvYWRpbmcgYXVkaW8uLi4nKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dCwgc2FtcGxlUmF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRTcGVlZCA9IG1vdXNlRG93bigpID8gc2FtcGxlUmF0ZSA6IDA7XG4gICAgICAgIGNvbnN0IHNwZWVkID0gZXhwRm9sbG93KHRhcmdldFNwZWVkLCAzLCBhdWRpb1RpbWUsIDApO1xuICAgICAgICBjb25zdCBwb3MgPSBNYXRoLmZsb29yKGludGVncmFsKCgpID0+IHNwZWVkLCBhdWRpb1RpbWUpKTtcbiAgICAgICAgcmV0dXJuIHBjbVtwb3MgJSBwY20ubGVuZ3RoXTsgLy8gbW9kdWxvIHNvIGFzIHRvIGxvb3BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NpcmNsZSBmb2xsb3dzIG1vdXNlJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICByZWRDaXJjbGUobW91c2VQb3NpdGlvbigpKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjaXJjbGUgZm9sbG93cyBtb3VzZSBhdCBsaW1pdGVkIHNwZWVkJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gYW5pbWF0aW9uVGltZSgpO1xuICAgICAgY29uc3QgbXBvcyA9IG1vdXNlUG9zaXRpb24oKTtcbiAgICAgIHJlZENpcmNsZShmb2xsb3dBdFNwZWVkMmQobXBvcywgMzAwLCB0aW1lLCBtcG9zKSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY2lyY2xlIG1vdmVzIGhhbGZ3YXkgdG8gbW91c2Ugd2l0aCBlYWNoIGNsaWNrJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBtaWRwb2ludCA9IChhLCBiKSA9PiAoe3g6IDAuNSooYS54K2IueCksIHk6IDAuNSooYS55K2IueSl9KTtcbiAgICAgIGNvbnN0IG1wb3MgPSBtb3VzZVBvc2l0aW9uKCk7XG4gICAgICBjb25zdCBjbGlja0V2dCA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjcG9zID0gdXNlUmVkdWNlcihjbGlja0V2dCwgKF8sIHByZXZTdGF0ZSkgPT4gbWlkcG9pbnQocHJldlN0YXRlLCBtcG9zKSwge3g6IDAsIHk6IDB9KTtcbiAgICAgIHJlZENpcmNsZShjcG9zKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyb2FtaW5nIGNpcmNsZSAoc3RhdGUgbWFjaGluZSknLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBhbmltYXRpb25UaW1lKCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHVzZU1hY2hpbmUoe1xuICAgICAgICBtb3Zpbmc6IChpbml0aWFsUG9zaXRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHt4OiA1MDAqcmFuZG9tKCksIHk6IDUwMCpyYW5kb20oKX07XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBmb2xsb3dBdFNwZWVkMmQodGFyZ2V0UG9zaXRpb24sIDMwMCwgdGltZSwgaW5pdGlhbFBvc2l0aW9uKTtcbiAgICAgICAgICBjb25zdCBhcnJpdmVkID0gKHBvc2l0aW9uLnggPT09IHRhcmdldFBvc2l0aW9uLngpICYmIChwb3NpdGlvbi55ID09PSB0YXJnZXRQb3NpdGlvbi55KTtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBldmVudFdoZW4oYXJyaXZlZCwgWydyZXN0aW5nJywgcG9zaXRpb25dKVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc3Rpbmc6IChpbml0aWFsUG9zaXRpb24pID0+IHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaW5pdGlhbFBvc2l0aW9uLFxuICAgICAgICAgICAgZXZlbnRBZnRlcihyYW5kb20oKSwgWydtb3ZpbmcnLCBpbml0aWFsUG9zaXRpb25dKVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICB9LCBbJ21vdmluZycsIHt4OiAwLCB5OiAwfV0pO1xuICAgICAgcmVkQ2lyY2xlKHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sXG5cbl1cbiIsImltcG9ydCB7IGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IH0gZnJvbSAnLi9yaXYnO1xuaW1wb3J0IHByb2dyYW1zIGZyb20gJy4vcHJvZ3JhbXMnO1xuXG5jb25zdCBwcm9ncmFtTGlzdEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3JhbS1saXN0Jyk7XG5jb25zdCBwcm9ncmFtU291cmNlRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmFtLXNvdXJjZScpO1xuXG5sZXQgY3VycmVudENvbnRleHQ7XG5cbi8vIE5PVEU6IFRoaXMgaXMgYSBoYWNrIGJ1dCB3b3JrcyBmb3Igbm93XG5jb25zdCBmaXhJbmRlbnQgPSAoY29kZSkgPT4ge1xuICByZXR1cm4gY29kZS5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBpZHgpID0+IChpZHggPT09IDApID8gbGluZSA6IGxpbmUuc3Vic3RyKDIpKS5qb2luKCdcXG4nKTtcbn1cblxuY29uc3Qgc3RhcnRQcm9ncmFtID0gKHByb2dyYW0pID0+IHtcbiAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQudGVybWluYXRlKCk7XG4gICAgY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9ncmFtU291cmNlRWxlbS50ZXh0Q29udGVudCA9IGZpeEluZGVudChwcm9ncmFtLm1haW4udG9TdHJpbmcoKSk7IC8vIGhhY2t5IGJ1dCB3b3JrcyBmb3Igbm93XG4gIGN1cnJlbnRDb250ZXh0ID0gY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQocHJvZ3JhbS5tYWluKTtcbiAgY3VycmVudENvbnRleHQudXBkYXRlKCk7IC8vIGRvIGluaXRpYWwgdXBkYXRlLiBhbnkgZnVydGhlciB1cGRhdGVzIHdpbGwgYmUgYXN5bmNcbn1cblxuZm9yIChjb25zdCBwcm9nIG9mIHByb2dyYW1zKSB7XG4gIGNvbnN0IGFuY2hvckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGFuY2hvckVsZW0udGV4dENvbnRlbnQgPSBwcm9nLm5hbWU7XG4gIGFuY2hvckVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgJyMnKTtcbiAgKCgpID0+IHtcbiAgICBhbmNob3JFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBzdGFydCBwcm9ncmFtIHdpdGggZGVsYXkgc28gaXQgZG9lc24ndCBnZXQgdGhpcyBjbGljayBldmVudFxuICAgICAgICBzdGFydFByb2dyYW0ocHJvZyk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfSkoKTtcblxuICBjb25zdCBpdGVtRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGl0ZW1FbGVtLmFwcGVuZENoaWxkKGFuY2hvckVsZW0pO1xuXG4gIHByb2dyYW1MaXN0RWxlbS5hcHBlbmRDaGlsZChpdGVtRWxlbSk7XG59XG5cbnN0YXJ0UHJvZ3JhbShwcm9ncmFtc1swXSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")}]);