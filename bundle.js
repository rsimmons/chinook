!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=1)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createNoInOutExecutionContext\", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useVar\", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useRequestUpdate\", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useInitialize\", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventEmitter\", function() { return useEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventReceiver\", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDynamic\", function() { return useDynamic; });\nlet updatingExecutionContextStack = [];\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push this context onto the stack\n    updatingExecutionContextStack.push(this); // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn't get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error('Did not reach all hook records in update');\n    } // Pop this context from the stack, making sure it is the top entry.\n\n\n    if (!updatingExecutionContextStack.length || updatingExecutionContextStack[updatingExecutionContextStack.length - 1] !== this) {\n      throw new Error('Cannot pop context because it is not at top of stack');\n    }\n\n    updatingExecutionContextStack.pop();\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // I'm not sure if we need to check this, but let's verify that this context isn't anywhere in the stack\n    for (const ctx of updatingExecutionContextStack) {\n      if (ctx === this) {\n        throw new Error('Should not be terminating context that is in updating stack');\n      }\n    } // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n\n\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error('Expecting to create new hook record in chain, but already present');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error('Expecting to find hook record in chain, but not present');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It's currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!updatingExecutionContextStack.length) {\n    throw new Error('Cannot call hook outside of execution context?');\n  }\n\n  return updatingExecutionContextStack[updatingExecutionContextStack.length - 1];\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can't we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it's important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\nfunction useEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const stream = {\n      count: 0,\n      // how many events have occurred on this stream\n      latestValue: undefined\n    };\n    record.data = {\n      stream,\n      emit: value => {\n        // This function closes over the stream variable\n        stream.latestValue = value;\n        stream.count++;\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\nfunction useEventReceiver(stream) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      stream,\n      // the stream we are receiving on\n      lastSeenNumber: stream.count\n    };\n  } // TODO: We could support this, just need to consider details.\n\n\n  if (stream !== record.data.stream) {\n    throw new Error('Event receiver found that stream object changed identity');\n  }\n\n  let boxedEvent;\n\n  if (record.data.lastSeenNumber === stream.count) {// There have not been any new events on the stream\n  } else if (record.data.lastSeenNumber === stream.count - 1) {\n    // There has been exactly one new event on the stream that we haven't seen yet.\n    boxedEvent = {\n      value: stream.latestValue\n    };\n    record.data.lastSeenNumber++;\n  } else {\n    throw new Error('Event receiver got too many events or missed some');\n  }\n\n  ctx._endHook();\n\n  return boxedEvent;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new \"version\" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create \"factory\" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2hpbm9vay5qcz9jMTliIl0sIm5hbWVzIjpbInVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dFN0YWNrIiwiRXhlY3V0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RyZWFtRnVuYyIsIm9uUmVxdWVzdFVwZGF0ZSIsImFmdGVyVGVybWluYXRlIiwiaG9va1JlY29yZENoYWluIiwibmV4dCIsInJlY29yZEN1cnNvciIsInVwZGF0ZUNvdW50IiwidXBkYXRlIiwicHVzaCIsInJldHZhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJsZW5ndGgiLCJwb3AiLCJ0ZXJtaW5hdGUiLCJjdHgiLCJjIiwiY2xlYW51cCIsIl9iZWdpbkhvb2siLCJkYXRhIiwidW5kZWZpbmVkIiwiX2VuZEhvb2siLCJfcmVxdWVzdFVwZGF0ZSIsIl9zZXRTdHJlYW1GdW5jIiwibmV3U3RyZWFtRnVuYyIsImNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IiwiZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0IiwidXNlVmFyIiwiaW5pdFZhbCIsInJlY29yZCIsImN1cnJlbnQiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwicmVxdWVzdFVwZGF0ZSIsInVzZUluaXRpYWxpemUiLCJpbml0aWFsaXplciIsInVzZUV2ZW50RW1pdHRlciIsInN0cmVhbSIsImNvdW50IiwibGF0ZXN0VmFsdWUiLCJlbWl0IiwidmFsdWUiLCJ1c2VFdmVudFJlY2VpdmVyIiwibGFzdFNlZW5OdW1iZXIiLCJib3hlZEV2ZW50IiwidXNlRHluYW1pYyIsIm9ydSIsImFjdGl2ZUNvbnRleHRzIiwiU2V0IiwiY3JlYXRlQ29udGV4dCIsImRlbGV0ZSIsImFkZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUlBLDZCQUE2QixHQUFHLEVBQXBDOztBQUVBLE1BQU1DLGdCQUFOLENBQXVCO0FBQ3JCQyxhQUFX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IjpbImxldCB1cGRhdGluZ0V4ZWN1dGlvbkNvbnRleHRTdGFjayA9IFtdO1xuXG5jbGFzcyBFeGVjdXRpb25Db250ZXh0IHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlLCBhZnRlclRlcm1pbmF0ZSkge1xuICAgIHRoaXMuc3RyZWFtRnVuYyA9IHN0cmVhbUZ1bmM7XG4gICAgdGhpcy5vblJlcXVlc3RVcGRhdGUgPSBvblJlcXVlc3RVcGRhdGU7XG4gICAgdGhpcy5hZnRlclRlcm1pbmF0ZSA9IGFmdGVyVGVybWluYXRlO1xuXG4gICAgdGhpcy5ob29rUmVjb3JkQ2hhaW4gPSB7bmV4dDogbnVsbH07IC8vIGR1bW15XG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSBudWxsOyAvLyBvbmx5IHNldCB3aGVuIHRoaXMgY29udGV4dCBpcyB1cGRhdGluZ1xuICAgIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIFB1c2ggdGhpcyBjb250ZXh0IG9udG8gdGhlIHN0YWNrXG4gICAgdXBkYXRpbmdFeGVjdXRpb25Db250ZXh0U3RhY2sucHVzaCh0aGlzKTtcblxuICAgIC8vIE1vdmUgaG9vayByZWNvcmQgY3Vyc29yIHRvIHN0YXJ0IG9mIGNoYWluXG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSB0aGlzLmhvb2tSZWNvcmRDaGFpbjtcblxuICAgIGNvbnN0IHJldHZhbCA9IHRoaXMuc3RyZWFtRnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgbnVsbCwgb3RoZXJ3aXNlIHRoZXJlIGFyZSBob29rIHJlY29yZHMgd2UgZGlkbid0IGdldCB0bywgYW5kIHNvbWV0aGluZyBpcyBhbWlzc1xuICAgIGlmICh0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgcmVhY2ggYWxsIGhvb2sgcmVjb3JkcyBpbiB1cGRhdGUnKTtcbiAgICB9XG5cbiAgICAvLyBQb3AgdGhpcyBjb250ZXh0IGZyb20gdGhlIHN0YWNrLCBtYWtpbmcgc3VyZSBpdCBpcyB0aGUgdG9wIGVudHJ5LlxuICAgIGlmICghdXBkYXRpbmdFeGVjdXRpb25Db250ZXh0U3RhY2subGVuZ3RoIHx8ICh1cGRhdGluZ0V4ZWN1dGlvbkNvbnRleHRTdGFja1t1cGRhdGluZ0V4ZWN1dGlvbkNvbnRleHRTdGFjay5sZW5ndGgtMV0gIT09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwb3AgY29udGV4dCBiZWNhdXNlIGl0IGlzIG5vdCBhdCB0b3Agb2Ygc3RhY2snKTtcbiAgICB9XG4gICAgdXBkYXRpbmdFeGVjdXRpb25Db250ZXh0U3RhY2sucG9wKCk7XG5cbiAgICB0aGlzLnVwZGF0ZUNvdW50Kys7XG5cbiAgICByZXR1cm4gcmV0dmFsO1xuICB9XG5cbiAgdGVybWluYXRlKCkge1xuICAgIC8vIEknbSBub3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNoZWNrIHRoaXMsIGJ1dCBsZXQncyB2ZXJpZnkgdGhhdCB0aGlzIGNvbnRleHQgaXNuJ3QgYW55d2hlcmUgaW4gdGhlIHN0YWNrXG4gICAgZm9yIChjb25zdCBjdHggb2YgdXBkYXRpbmdFeGVjdXRpb25Db250ZXh0U3RhY2spIHtcbiAgICAgIGlmIChjdHggPT09IHRoaXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGJlIHRlcm1pbmF0aW5nIGNvbnRleHQgdGhhdCBpcyBpbiB1cGRhdGluZyBzdGFjaycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhbGwgYW55IGNsZWFudXAgZnVuY3Rpb25zIHNldCBieSBob29rc1xuICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gd29ycnkgYWJvdXQgb3JkZXI/XG4gICAgZm9yIChsZXQgYyA9IHRoaXMuaG9va1JlY29yZENoYWluLm5leHQ7IGM7IGMgPSBjLm5leHQpIHtcbiAgICAgIGlmIChjLmNsZWFudXApIHtcbiAgICAgICAgYy5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWZ0ZXJUZXJtaW5hdGUpIHtcbiAgICAgIHRoaXMuYWZ0ZXJUZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfYmVnaW5Ib29rKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUNvdW50ID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5yZWNvcmRDdXJzb3IubmV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyB0byBjcmVhdGUgbmV3IGhvb2sgcmVjb3JkIGluIGNoYWluLCBidXQgYWxyZWFkeSBwcmVzZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgbmV3IHJlY29yZFxuICAgICAgdGhpcy5yZWNvcmRDdXJzb3IubmV4dCA9IHtcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBjbGVhbnVwOiB1bmRlZmluZWQsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyB0byBmaW5kIGhvb2sgcmVjb3JkIGluIGNoYWluLCBidXQgbm90IHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWNvcmRDdXJzb3IubmV4dDtcbiAgfVxuXG4gIF9lbmRIb29rKCkge1xuICAgIHRoaXMucmVjb3JkQ3Vyc29yID0gdGhpcy5yZWNvcmRDdXJzb3IubmV4dDsgLy8gbW92ZSBjdXJzb3IgZm9yd2FyZFxuICB9XG5cbiAgX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgdGhpcy5vblJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG9ubHkgc2FmZSB0byBkbyBpZiB0aGUgcmVwbGFjZW1lbnQgZnVuY3Rpb24gY2FsbHMgdGhlIHNhbWUgaG9va3MsIGhhcyBzYW1lIHNpZ25hdHVyZSwgZXRjLlxuICAgKiBJdCdzIGN1cnJlbnRseSB1c2VkIHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGlzIGxleGljYWxseSB0aGUgc2FtZSBidXQgYm91bmQgdG8gZGlmZmVyZW50IG91dGVyLXNjb3BlXG4gICAqIHZhcmlhYmxlcy5cbiAgICovXG4gIF9zZXRTdHJlYW1GdW5jKG5ld1N0cmVhbUZ1bmMpIHtcbiAgICB0aGlzLnN0cmVhbUZ1bmMgPSBuZXdTdHJlYW1GdW5jO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dChzdHJlYW1GdW5jKSB7XG4gIGNvbnN0IG9uUmVxdWVzdFVwZGF0ZSA9ICgpID0+IHsgY3R4LnVwZGF0ZSgpIH07XG4gIGNvbnN0IGN0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSlcbiAgcmV0dXJuIGN0eDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgYnkgaG9va3MgdG8gZ2V0IHRoZSBjdXJyZW50bHkgdXBkYXRpbmcgY29udGV4dCAoYWZ0ZXIgdmVyaWZ5aW5nIGl0IGlzIHNldClcbiAqL1xuZnVuY3Rpb24gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCkge1xuICBpZiAoIXVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dFN0YWNrLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgaG9vayBvdXRzaWRlIG9mIGV4ZWN1dGlvbiBjb250ZXh0PycpO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dFN0YWNrW3VwZGF0aW5nRXhlY3V0aW9uQ29udGV4dFN0YWNrLmxlbmd0aC0xXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVZhcihpbml0VmFsKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIENyZWF0ZSB2YWx1ZSBib3ggaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtjdXJyZW50OiBpbml0VmFsfTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiByZWNvcmQuZGF0YTtcbn1cblxuLyoqXG4gKiBXaHkgZG8gd2UgbmVlZCBhIGhvb2s/IFdoeSBjYW4ndCB3ZSBqdXN0IGNhbGwgY3R4LnJlcXVlc3RVcGRhdGUoKT8gQmVjYXVzZSB0aGUgcmVxdWVzdFVwZGF0ZVxuICogZnVuY3Rpb24gdGhhdCB3ZSByZXR1cm4gd2lsbCBvZnRlbiBiZSBjYWxsZWQgd2l0aG91dCB0aGVyZSBiZWluZyBhbnkgdXBkYXRpbmcgZXhlY3V0aW9uIGNvbnRleHRcbiAqIChlLmcuIGZyb20gYW4gZXZlbnQgaGFuZGxlcikuIFNvIGl0IGhhcyB0byBiZSBib3VuZCB0byB0aGUgY29ycmVjdCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVxdWVzdFVwZGF0ZSgpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gQ3JlYXRlIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeS4gV2Ugc3RvcmUgaXQgc28gdGhhdCB3ZSBhbHJlYWR5IHJldHVybiB0aGUgc2FtZSBvbmUuXG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtyZXF1ZXN0VXBkYXRlOiAoKSA9PiB7XG4gICAgICBjdHguX3JlcXVlc3RVcGRhdGUoKTsgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSB1c2UgY3R4IGZyb20gY2xvc3VyZSwgbm90IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpIGhlcmVcbiAgICB9fTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiByZWNvcmQuZGF0YS5yZXF1ZXN0VXBkYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5pdGlhbGl6ZShpbml0aWFsaXplcikge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgLy8gZGF0YSBiZWluZyB1bmRlZmluZWQgbWVhbnMgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbFxuXG4gICAgcmVjb3JkLmNsZWFudXAgPSBpbml0aWFsaXplcigpO1xuXG4gICAgcmVjb3JkLmRhdGEgPSB7fTsgLy8gbm8gZGF0YSB0byBzdG9yZSB5ZXQsIGp1c3QgbmVlZHMgdG8gYmUgdHJ1dGh5IHRvIGluZGljYXRlIHRoYXQgaW5pdGlhbGl6YXRpb24gcmFuXG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV2ZW50RW1pdHRlcigpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHtcbiAgICAgIGNvdW50OiAwLCAvLyBob3cgbWFueSBldmVudHMgaGF2ZSBvY2N1cnJlZCBvbiB0aGlzIHN0cmVhbVxuICAgICAgbGF0ZXN0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB9XG5cbiAgICByZWNvcmQuZGF0YSA9IHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIGVtaXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNsb3NlcyBvdmVyIHRoZSBzdHJlYW0gdmFyaWFibGVcbiAgICAgICAgc3RyZWFtLmxhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHN0cmVhbS5jb3VudCsrO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIFtyZWNvcmQuZGF0YS5zdHJlYW0sIHJlY29yZC5kYXRhLmVtaXRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRSZWNlaXZlcihzdHJlYW0pIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge1xuICAgICAgc3RyZWFtLCAvLyB0aGUgc3RyZWFtIHdlIGFyZSByZWNlaXZpbmcgb25cbiAgICAgIGxhc3RTZWVuTnVtYmVyOiBzdHJlYW0uY291bnQsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE86IFdlIGNvdWxkIHN1cHBvcnQgdGhpcywganVzdCBuZWVkIHRvIGNvbnNpZGVyIGRldGFpbHMuXG4gIGlmIChzdHJlYW0gIT09IHJlY29yZC5kYXRhLnN0cmVhbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgcmVjZWl2ZXIgZm91bmQgdGhhdCBzdHJlYW0gb2JqZWN0IGNoYW5nZWQgaWRlbnRpdHknKTtcbiAgfVxuXG4gIGxldCBib3hlZEV2ZW50O1xuXG4gIGlmIChyZWNvcmQuZGF0YS5sYXN0U2Vlbk51bWJlciA9PT0gc3RyZWFtLmNvdW50KSB7XG4gICAgLy8gVGhlcmUgaGF2ZSBub3QgYmVlbiBhbnkgbmV3IGV2ZW50cyBvbiB0aGUgc3RyZWFtXG4gIH0gZWxzZSBpZiAocmVjb3JkLmRhdGEubGFzdFNlZW5OdW1iZXIgPT09IChzdHJlYW0uY291bnQgLSAxKSkge1xuICAgIC8vIFRoZXJlIGhhcyBiZWVuIGV4YWN0bHkgb25lIG5ldyBldmVudCBvbiB0aGUgc3RyZWFtIHRoYXQgd2UgaGF2ZW4ndCBzZWVuIHlldC5cbiAgICBib3hlZEV2ZW50ID0ge3ZhbHVlOiBzdHJlYW0ubGF0ZXN0VmFsdWV9O1xuICAgIHJlY29yZC5kYXRhLmxhc3RTZWVuTnVtYmVyKys7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCByZWNlaXZlciBnb3QgdG9vIG1hbnkgZXZlbnRzIG9yIG1pc3NlZCBzb21lJyk7XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gYm94ZWRFdmVudDtcbn1cblxuLyoqXG4gKiBUaGUgc3RyZWFtRnVuYyBhcmd1bWVudCBtYXkgY2hhbmdlLCBidXQgaXQgc2hvdWxkIG9ubHkgY2hhbmdlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgc2FmZWx5XG4gKiBzd2FwcGVkIGluIChpLmUuIG9uZSB0aGF0IGNhbGxzIHRoZSBzYW1lIGhvb2tzLCBldGMuKS4gQSBjb21tb24gY2FzZSBpcyB0aGF0IHN0cmVhbUZ1bmMgaXMgYVxuICogY2xvc3VyZSB0aGF0IHJlZmVyZW5jZXMgc29tZSBvdXRlciBzY29wZSB2YXJpYWJsZXMsIGFuZCB3aGVuIHRob3NlIGNoYW5nZSwgYSBuZXcgXCJ2ZXJzaW9uXCIgb2ZcbiAqIHRoZSBmdW5jdGlvbiBpcyBjcmVhdGVkIChsZXhpY2FsbHkgdGhlIHNhbWUsIGJ1dCBjbG9zaW5nIG92ZXIgYSBkaWZmZXJlbnQgc2NvcGUpLlxuICpcbiAqIG9uUmVxdWVzdFVwZGF0ZSBpcyBjdXJyZW50bHkgb25seSByZWFkIG9uIHRoZSBmaXJzdCBjYWxsLCBzbyBjaGFuZ2VzIHRvIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEeW5hbWljKHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuXG4gICAgLy8gSWYgbm8gb25SZXF1ZXN0VXBkYXRlIGlzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIHJlcXVlc3RpbmcgdXBkYXRlIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICBjb25zdCBvcnUgPSBvblJlcXVlc3RVcGRhdGUgfHwgKCgpID0+IHtcbiAgICAgIGN0eC5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gVHJhY2sgRXhlY3V0aW9uQ29udGV4dHMgY3JlYXRlZCAoYW5kIG5vdCB5ZXQgdGVybWluYXRlZCkgc28gd2UgY2FuIHRlcm1pbmF0ZSB0aGVtIHVwb24gY2xlYW51cFxuICAgIGRhdGEuYWN0aXZlQ29udGV4dHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBDcmVhdGUgXCJmYWN0b3J5XCIgZnVuY3Rpb24gdG8gaW5zdGFudGlhdGUgbmV3IGNvbnRleHRzXG4gICAgZGF0YS5jcmVhdGVDb250ZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoZGF0YS5zdHJlYW1GdW5jLCBvcnUsICgpID0+IHsgZGF0YS5hY3RpdmVDb250ZXh0cy5kZWxldGUoY3R4KTsgfSk7XG4gICAgICBkYXRhLmFjdGl2ZUNvbnRleHRzLmFkZChjdHgpO1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuXG4gICAgcmVjb3JkLmRhdGEgPSBkYXRhO1xuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjdHggb2YgZGF0YS5hY3RpdmVDb250ZXh0cykge1xuICAgICAgICBjdHgudGVybWluYXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgc3RyZWFtIGZ1bmN0aW9uIGluIHJlY29yZCBhbmQgYWxsIGFjdGl2ZSBjb250ZXh0cy5cbiAgcmVjb3JkLmRhdGEuc3RyZWFtRnVuYyA9IHN0cmVhbUZ1bmM7XG4gIGZvciAoY29uc3QgY3R4IG9mIHJlY29yZC5kYXRhLmFjdGl2ZUNvbnRleHRzKSB7XG4gICAgY3R4Ll9zZXRTdHJlYW1GdW5jKHN0cmVhbUZ1bmMpO1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhLmNyZWF0ZUNvbnRleHQ7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/chinook.js\nvar chinook = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useEventEmitter,\n  useEventReceiver,\n  useDynamic\n} = __webpack_require__(0);\n\nfunction displayAsString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'position: absolute; top: 0; right: 0; pointer-events: none; background: white; border: 1px solid red; color: black; font-size: 24px; padding: 5px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = v === undefined ? '(undefined)' : v.toString();\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvts, emitClick] = useEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvts;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction random(repickEvts) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvts);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  const [advanceFrameEvts, emitAdvanceFrame] = useEventEmitter();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        emitAdvanceFrame({});\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvts, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvts);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvts, emitTick] = useEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    displayAsString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    displayAsString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    displayAsString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    displayAsString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvts, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    displayAsString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    displayAsString(nums.join(' '));\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(chinook[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUV2ZW50RW1pdHRlciIsInVzZUV2ZW50UmVjZWl2ZXIiLCJ1c2VEeW5hbWljIiwicmVxdWlyZSIsImRpc3BsYXlBc1N0cmluZyIsInYiLCJlbGVtIiwiY3VycmVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsInRleHRDb250ZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImFuaW1hdGlvblRpbWUiLCJyZXF1ZXN0VXBkYXRlIiwidGltZSIsInJlcUlkIiwib25GcmFtZSIsInQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uRnJhbWVFdnRzIiwiZnJhbWVFdnRzIiwiZW1pdEZyYW1lIiwiY291bnRFdmVudHMiLCJldnRzIiwiY291bnQiLCJldmVudCIsIm1vdXNlQ2xpY2tFdnRzIiwiY2xpY2tFdnRzIiwiZW1pdENsaWNrIiwib25Nb3VzZURvd24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdXNlRG93biIsImlzRG93biIsIm9uTW91c2VVcCIsInJhbmRvbSIsInJlcGlja0V2dHMiLCJ2YWwiLCJNYXRoIiwicmVwaWNrIiwiYXVkaW9Ecml2ZXIiLCJnZW5lcmF0b3IiLCJjcmVhdGVHZW5lcmF0b3IiLCJnZW5lcmF0b3JDdHgiLCJmcmFtZUNvdW50Iiwic2FtcGxlUmF0ZSIsImFkdmFuY2VGcmFtZUV2dHMiLCJlbWl0QWR2YW5jZUZyYW1lIiwiQlVGRkVSX1NJWkUiLCJhdWRpb0NvbnRleHQiLCJ3aW5kb3ciLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzY3JpcHROb2RlIiwiY3JlYXRlU2NyaXB0UHJvY2Vzc29yIiwib25hdWRpb3Byb2Nlc3MiLCJlIiwiYnVmZmVyIiwib3V0cHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJpIiwibGVuZ3RoIiwidXBkYXRlIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiZGlzY29ubmVjdCIsImNsb3NlIiwic2FtcGxlVXBvbiIsInRvU2FtcGxlIiwidXBvbkV2dHMiLCJpbml0aWFsVmFsdWUiLCJoZWxkIiwidXBvbiIsImV2ZXJ5U2Vjb25kIiwidGlja0V2dHMiLCJlbWl0VGljayIsIm9uSW50ZXJ2YWwiLCJ0aW1lcklkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmFtZSIsIm1haW4iLCJ0b0ZpeGVkIiwibWQiLCJhdWRpb1RpbWUiLCJub2lzZSIsImxhc3RDbGlja1RpbWUiLCJJbmZpbml0eSIsImRlY2F5aW5nR2FpbiIsImV4cCIsImNsaWNrIiwiY3JlYXRlQ291bnRlciIsImFjdGl2ZUNvdW50ZXIiLCJ0ZXJtaW5hdGUiLCJkaXNwbGF5ZWRDb3VudCIsImNyZWF0ZUNsb2NrIiwiY2xvY2tBcnJheSIsInB1c2giLCJudW1zIiwibWFwIiwiY2xvY2siLCJqb2luIiwicHJvZ3JhbUxpc3RFbGVtIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9ncmFtU291cmNlRWxlbSIsImN1cnJlbnRDb250ZXh0IiwiZml4SW5kZW50IiwiY29kZSIsInNwbGl0IiwibGluZSIsImlkeCIsInN1YnN0ciIsInN0YXJ0UHJvZ3JhbSIsInByb2dyYW0iLCJjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dCIsInByb2ciLCJwcm9ncmFtcyIsImFuY2hvckVsZW0iLCJzZXRBdHRyaWJ1dGUiLCJwcmV2ZW50RGVmYXVsdCIsInNldFRpbWVvdXQiLCJpdGVtRWxlbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxNQUFNO0FBQUVBLFFBQUY7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QixFQUFnQyxHQUFoQzs7QUFDQSxHQUFDLE1BQU07QUFDTEQsY0FBVSxDQUFDdkYsZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBc0MwQixDQUFELElBQU87QUFDMUNBLE9BQUMsQ0FBQytELGNBQUY7QUFDQUMsZ0JBQVUsQ0FBQyxNQUFNO0FBQUU7QUFDakJSLG9CQUFZLENBQUNHLElBQUQsQ0FBWjtBQUNELE9BRlMsRUFFUCxDQUZPLENBQVY7QUFHRCxLQUxEO0FBTUQsR0FQRDs7QUFTQSxRQUFNTSxRQUFRLEdBQUcxSCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBakI7QUFDQXlILFVBQVEsQ0FBQ3BILFdBQVQsQ0FBcUJnSCxVQUFyQjtBQUVBZixpQkFBZSxDQUFDakcsV0FBaEIsQ0FBNEJvSCxRQUE1QjtBQUNEOztBQUVEVCxZQUFZLENBQUNJLFFBQVEsQ0FBQyxDQUFELENBQVQsQ0FBWiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTk9URTogVXNpbmcgcmVxdWlyZSBpbnN0ZWFkIG9mIGltcG9ydCBoZXJlIG1ha2VzIHRoZSB0aGluZyB3aGVyZSB3ZSBwcmludCBwcm9ncmFtIHRleHQgd29yayBiZXR0ZXIuXG5jb25zdCB7IHVzZVZhciwgdXNlUmVxdWVzdFVwZGF0ZSwgdXNlSW5pdGlhbGl6ZSwgdXNlRXZlbnRFbWl0dGVyLCB1c2VFdmVudFJlY2VpdmVyLCB1c2VEeW5hbWljIH0gPSByZXF1aXJlKCcuL2NoaW5vb2snKTtcblxuZnVuY3Rpb24gZGlzcGxheUFzU3RyaW5nKHYpIHtcbiAgY29uc3QgZWxlbSA9IHVzZVZhcihudWxsKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBlbGVtLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtLmN1cnJlbnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgcmlnaHQ6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyBiYWNrZ3JvdW5kOiB3aGl0ZTsgYm9yZGVyOiAxcHggc29saWQgcmVkOyBjb2xvcjogYmxhY2s7IGZvbnQtc2l6ZTogMjRweDsgcGFkZGluZzogNXB4JztcbiAgICBlbGVtLmN1cnJlbnQudGV4dENvbnRlbnQgPSAnKHVuZGVmaW5lZCknO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbS5jdXJyZW50KTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbS5jdXJyZW50KTtcbiAgICB9XG4gIH0pXG5cbiAgZWxlbS5jdXJyZW50LnRleHRDb250ZW50ID0gKHYgPT09IHVuZGVmaW5lZCkgPyAnKHVuZGVmaW5lZCknIDogdi50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRpb25UaW1lKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCB0aW1lID0gdXNlVmFyKCk7XG4gIGNvbnN0IHJlcUlkID0gdXNlVmFyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICB0aW1lLmN1cnJlbnQgPSAwLjAwMSp0O1xuICAgICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTsgLy8gcmVxdWVzdCBhbm90aGVyXG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXFJZC5jdXJyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvbkZyYW1lRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2ZyYW1lRXZ0cywgZW1pdEZyYW1lXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uRnJhbWUgPSAodCkgPT4ge1xuICAgICAgZW1pdEZyYW1lKCk7XG4gICAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpOyAvLyByZXF1ZXN0IGFub3RoZXJcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcUlkLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZyYW1lRXZ0cztcbn1cblxuZnVuY3Rpb24gY291bnRFdmVudHMoZXZ0cykge1xuICBjb25zdCBjb3VudCA9IHVzZVZhcigwKTtcbiAgY29uc3QgZXZlbnQgPSB1c2VFdmVudFJlY2VpdmVyKGV2dHMpO1xuXG4gIGlmIChldmVudCkge1xuICAgIGNvdW50LmN1cnJlbnQrKztcbiAgfVxuXG4gIHJldHVybiBjb3VudC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBtb3VzZUNsaWNrRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW2NsaWNrRXZ0cywgZW1pdENsaWNrXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgZW1pdENsaWNrKCk7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbGlja0V2dHM7XG59XG5cbmZ1bmN0aW9uIG1vdXNlRG93bigpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgaXNEb3duID0gdXNlVmFyKGZhbHNlKTsgLy8gd2UgY2FuJ3QgcG9sbCBkb3duLW5lc3MsIHNvIHdlIGFzc3VtZSBpdCdzIGluaXRpYWxseSBub3QgZG93blxuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgaXNEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBpc0Rvd24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzRG93bi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiByYW5kb20ocmVwaWNrRXZ0cykge1xuICBjb25zdCB2YWwgPSB1c2VWYXIoTWF0aC5yYW5kb20oKSk7XG4gIGNvbnN0IHJlcGljayA9IHVzZUV2ZW50UmVjZWl2ZXIocmVwaWNrRXZ0cyk7XG5cbiAgaWYgKHJlcGljaykge1xuICAgIHZhbC5jdXJyZW50ID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuXG4gIHJldHVybiB2YWwuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYXVkaW9Ecml2ZXIoZ2VuZXJhdG9yKSB7XG4gIGNvbnN0IGNyZWF0ZUdlbmVyYXRvciA9IHVzZUR5bmFtaWMoZ2VuZXJhdG9yKTtcbiAgY29uc3QgZ2VuZXJhdG9yQ3R4ID0gdXNlVmFyKCk7XG4gIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VWYXIoMCk7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2FkdmFuY2VGcmFtZUV2dHMsIGVtaXRBZHZhbmNlRnJhbWVdID0gdXNlRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgZ2VuZXJhdG9yQ3R4LmN1cnJlbnQgPSBjcmVhdGVHZW5lcmF0b3IoKTtcblxuICAgIGNvbnN0IEJVRkZFUl9TSVpFID0gMTAyNDtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBjb25zdCBzY3JpcHROb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihCVUZGRVJfU0laRSwgMCwgMSk7IC8vIDAgaW5wdXQgY2hhbm5lbHMsIDEgb3V0cHV0IGNoYW5uZWxcbiAgICBzY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGUub3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW1pdEFkdmFuY2VGcmFtZSh7fSk7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCBhZHZhbmNlRnJhbWVFdnRzKTtcbiAgICAgICAgZnJhbWVDb3VudC5jdXJyZW50Kys7XG4gICAgICB9XG4gICAgfTtcbiAgICBzY3JpcHROb2RlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIHNhbXBsZVJhdGUuY3VycmVudCA9IGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNjcmlwdE5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgYXVkaW9Db250ZXh0LmNsb3NlKCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIE1vc3Qgb2Ygb3VyIGdlbmVyYXRvciB1cGRhdGluZyB3aWxsIGhhcHBlbiBpbiB0aGUgYXVkaW8gcHJvY2Vzc2luZyBjYWxsYmFjayBhYm92ZS5cbiAgICogVGhpcyB1cGRhdGUgaGVyZSBpcyBmb3Igd2hlbiB0aGUgYXVkaW9Ecml2ZXIgdXBkYXRlIGlzIGNhbGxlZCwgZS5nLiB3aGVuIGFuIG91dGVyIHNjb3BlXG4gICAqIHJlZmVyZW5jZSB0aGF0IHRoZSBnZW5lcmF0b3IgZGVwZW5kcyBvbiBoYXMgY2hhbmdlZC4gU28gd2UgbXVzdCB1cGRhdGUgdGhlIGdlbmVyYXRvcixcbiAgICogYnV0IGRvbid0IG5lZWQgaXRzIG91dHB1dCBhbXBsaXR1ZGUuXG4gICAqL1xuICBnZW5lcmF0b3JDdHguY3VycmVudC51cGRhdGUoZnJhbWVDb3VudC5jdXJyZW50L3NhbXBsZVJhdGUuY3VycmVudCwgYWR2YW5jZUZyYW1lRXZ0cyk7IC8vIE5PVEU6IHdlIGRpc2NhcmQgcmV0dmFsXG59XG5cbmZ1bmN0aW9uIHNhbXBsZVVwb24odG9TYW1wbGUsIHVwb25FdnRzLCBpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgaGVsZCA9IHVzZVZhcihpbml0aWFsVmFsdWUpO1xuICBjb25zdCB1cG9uID0gdXNlRXZlbnRSZWNlaXZlcih1cG9uRXZ0cyk7XG5cbiAgaWYgKHVwb24pIHtcbiAgICBoZWxkLmN1cnJlbnQgPSB0b1NhbXBsZTtcbiAgfVxuXG4gIHJldHVybiBoZWxkLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGV2ZXJ5U2Vjb25kKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBbdGlja0V2dHMsIGVtaXRUaWNrXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uSW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgICBlbWl0VGljaygpO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25JbnRlcnZhbCwgMTAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRpY2tFdnRzO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbXG4gIHtcbiAgICBuYW1lOiAnZG8gbm90aGluZycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdhbmltYXRpb24gdGltZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgZGlzcGxheUFzU3RyaW5nKGFuaW1hdGlvblRpbWUoKS50b0ZpeGVkKDMpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY291bnQgY2xpY2tzJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBkaXNwbGF5QXNTdHJpbmcoY291bnRFdmVudHMobW91c2VDbGlja0V2dHMoKSkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdpcyBtb3VzZSBidXR0b24gZG93bicsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgZGlzcGxheUFzU3RyaW5nKG1vdXNlRG93bigpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmFuZG9tIG51bWJlciwgY2xpY2sgdG8gcmVwaWNrJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBkaXNwbGF5QXNTdHJpbmcocmFuZG9tKG1vdXNlQ2xpY2tFdnRzKCkpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnYXVkaW8gbm9pc2Ugd2hlbiBtb3VzZSBpcyBkb3duJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBtZCA9IG1vdXNlRG93bigpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0cykgPT4ge1xuICAgICAgICBjb25zdCBub2lzZSA9IHJhbmRvbShhZHZhbmNlRnJhbWVFdnRzKSAtIDAuNTtcbiAgICAgICAgcmV0dXJuIG1kID8gbm9pc2UgOiAwO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2RlY2F5aW5nIG5vaXNlIHVwb24gY2xpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBhdWRpb0RyaXZlcigoYXVkaW9UaW1lLCBhZHZhbmNlRnJhbWVFdnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vaXNlID0gcmFuZG9tKGFkdmFuY2VGcmFtZUV2dHMpIC0gMC41O1xuICAgICAgICBjb25zdCBsYXN0Q2xpY2tUaW1lID0gc2FtcGxlVXBvbihhdWRpb1RpbWUsIGNsaWNrRXZ0cywgLUluZmluaXR5KTtcbiAgICAgICAgY29uc3QgZGVjYXlpbmdHYWluID0gTWF0aC5leHAoNSoobGFzdENsaWNrVGltZSAtIGF1ZGlvVGltZSkpO1xuICAgICAgICByZXR1cm4gZGVjYXlpbmdHYWluKm5vaXNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3Jlc2V0dGluZyBmcmFtZSBjb3VudGVyLCBjbGljayB0byByZXNldCcsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgZnJhbWVFdnRzID0gYW5pbWF0aW9uRnJhbWVFdnRzKCk7XG4gICAgICBjb25zdCBjbGlja0V2dHMgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2sgPSB1c2VFdmVudFJlY2VpdmVyKGNsaWNrRXZ0cyk7XG4gICAgICBjb25zdCBjcmVhdGVDb3VudGVyID0gdXNlRHluYW1pYyhjb3VudEV2ZW50cyk7XG4gICAgICBjb25zdCBhY3RpdmVDb3VudGVyID0gdXNlVmFyKCk7XG5cbiAgICAgIGlmIChjbGljaykge1xuICAgICAgICBpZiAoYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheWVkQ291bnQgPSBhY3RpdmVDb3VudGVyLmN1cnJlbnQudXBkYXRlKGZyYW1lRXZ0cyk7XG4gICAgICBkaXNwbGF5QXNTdHJpbmcoZGlzcGxheWVkQ291bnQpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2R5bmFtaWMgYXJyYXkgb2YgYXN5bmMgY2xvY2tzLCBjbGljayB0byBhZGQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjbGljayA9IHVzZUV2ZW50UmVjZWl2ZXIoY2xpY2tFdnRzKTtcbiAgICAgIGNvbnN0IGNyZWF0ZUNsb2NrID0gdXNlRHluYW1pYygoKSA9PiBjb3VudEV2ZW50cyhldmVyeVNlY29uZCgpKSk7XG4gICAgICBjb25zdCBjbG9ja0FycmF5ID0gdXNlVmFyKFtdKTtcblxuICAgICAgaWYgKGNsaWNrKSB7XG4gICAgICAgIGNsb2NrQXJyYXkuY3VycmVudC5wdXNoKGNyZWF0ZUNsb2NrKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBudW1zID0gY2xvY2tBcnJheS5jdXJyZW50Lm1hcChjbG9jayA9PiBjbG9jay51cGRhdGUoKSk7XG4gICAgICBkaXNwbGF5QXNTdHJpbmcobnVtcy5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXVxuIiwiaW1wb3J0IHsgY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tICcuL2NoaW5vb2snO1xuaW1wb3J0IHByb2dyYW1zIGZyb20gJy4vcHJvZ3JhbXMnO1xuXG5jb25zdCBwcm9ncmFtTGlzdEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3JhbS1saXN0Jyk7XG5jb25zdCBwcm9ncmFtU291cmNlRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmFtLXNvdXJjZScpO1xuXG5sZXQgY3VycmVudENvbnRleHQ7XG5cbi8vIE5PVEU6IFRoaXMgaXMgYSBoYWNrIGJ1dCB3b3JrcyBmb3Igbm93XG5jb25zdCBmaXhJbmRlbnQgPSAoY29kZSkgPT4ge1xuICByZXR1cm4gY29kZS5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBpZHgpID0+IChpZHggPT09IDApID8gbGluZSA6IGxpbmUuc3Vic3RyKDIpKS5qb2luKCdcXG4nKTtcbn1cblxuY29uc3Qgc3RhcnRQcm9ncmFtID0gKHByb2dyYW0pID0+IHtcbiAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQudGVybWluYXRlKCk7XG4gICAgY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9ncmFtU291cmNlRWxlbS50ZXh0Q29udGVudCA9IGZpeEluZGVudChwcm9ncmFtLm1haW4udG9TdHJpbmcoKSk7IC8vIGhhY2t5IGJ1dCB3b3JrcyBmb3Igbm93XG4gIGN1cnJlbnRDb250ZXh0ID0gY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQocHJvZ3JhbS5tYWluKTtcbiAgY3VycmVudENvbnRleHQudXBkYXRlKCk7IC8vIGRvIGluaXRpYWwgdXBkYXRlLiBhbnkgZnVydGhlciB1cGRhdGVzIHdpbGwgYmUgYXN5bmNcbn1cblxuZm9yIChjb25zdCBwcm9nIG9mIHByb2dyYW1zKSB7XG4gIGNvbnN0IGFuY2hvckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGFuY2hvckVsZW0udGV4dENvbnRlbnQgPSBwcm9nLm5hbWU7XG4gIGFuY2hvckVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgJyMnKTtcbiAgKCgpID0+IHtcbiAgICBhbmNob3JFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBzdGFydCBwcm9ncmFtIHdpdGggZGVsYXkgc28gaXQgZG9lc24ndCBnZXQgdGhpcyBjbGljayBldmVudFxuICAgICAgICBzdGFydFByb2dyYW0ocHJvZyk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfSkoKTtcblxuICBjb25zdCBpdGVtRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGl0ZW1FbGVtLmFwcGVuZENoaWxkKGFuY2hvckVsZW0pO1xuXG4gIHByb2dyYW1MaXN0RWxlbS5hcHBlbmRDaGlsZChpdGVtRWxlbSk7XG59XG5cbnN0YXJ0UHJvZ3JhbShwcm9ncmFtc1swXSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}]);