!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=1)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNoInOutExecutionContext", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useVar", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRequestUpdate", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useInitialize", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventEmitter", function() { return useEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventReceiver", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDynamic", function() { return useDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return useReducer; });\nlet currentUpdateFrame = null;\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push a new update frame onto the update stack for this context\n    const newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn\'t get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error(\'Did not reach all hook records in update\');\n    } // Pop the top frame from the update stack\n\n\n    const poppedFrame = currentUpdateFrame;\n\n    if (!poppedFrame) {\n      throw new Error(\'Cannot pop update frame because current is null\');\n    }\n\n    if (poppedFrame.executionContext !== this) {\n      throw new Error("Popped frame from update stack but context did not match");\n    }\n\n    currentUpdateFrame = poppedFrame.previousFrame;\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // NOTE: Might we want to sanity check that this context isn\'t anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error(\'Expecting to create new hook record in chain, but already present\');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error(\'Expecting to find hook record in chain, but not present\');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It\'s currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error(\'Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?\');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can\'t we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it\'s important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\nfunction useEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const stream = {\n      count: 0,\n      // how many events have occurred on this stream\n      latestValue: undefined\n    };\n    record.data = {\n      stream,\n      emit: value => {\n        // This function closes over the stream variable\n        stream.latestValue = value;\n        stream.count++;\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\nfunction useEventReceiver(stream) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      stream,\n      // the stream we are receiving on\n      lastSeenNumber: stream.count\n    };\n  } // TODO: We could support this, just need to consider details.\n\n\n  if (stream !== record.data.stream) {\n    throw new Error(\'Event receiver found that stream object changed identity\');\n  }\n\n  let boxedEvent;\n\n  if (record.data.lastSeenNumber === stream.count) {// There have not been any new events on the stream\n  } else if (record.data.lastSeenNumber === stream.count - 1) {\n    // There has been exactly one new event on the stream that we haven\'t seen yet.\n    boxedEvent = {\n      value: stream.latestValue\n    };\n    record.data.lastSeenNumber++;\n  } else {\n    throw new Error(\'Event receiver got too many events or missed some\');\n  }\n\n  ctx._endHook();\n\n  return boxedEvent;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new "version" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create "factory" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\nfunction useReducer(actionEvts, reducerFunc, initialState) {\n  const state = useVar(initialState);\n  const action = useEventReceiver(actionEvts);\n  state.current = reducerFunc(action, state.current);\n  return state.current;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcml2LmpzPzgxNWEiXSwibmFtZXMiOlsiY3VycmVudFVwZGF0ZUZyYW1lIiwiRXhlY3V0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RyZWFtRnVuYyIsIm9uUmVxdWVzdFVwZGF0ZSIsImFmdGVyVGVybWluYXRlIiwiaG9va1JlY29yZENoYWluIiwibmV4dCIsInJlY29yZEN1cnNvciIsInVwZGF0ZUNvdW50IiwidXBkYXRlIiwibmV3RnJhbWUiLCJleGVjdXRpb25Db250ZXh0IiwicHJldmlvdXNGcmFtZSIsInJldHZhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJwb3BwZWRGcmFtZSIsInRlcm1pbmF0ZSIsImMiLCJjbGVhbnVwIiwiX2JlZ2luSG9vayIsImRhdGEiLCJ1bmRlZmluZWQiLCJfZW5kSG9vayIsIl9yZXF1ZXN0VXBkYXRlIiwiX3NldFN0cmVhbUZ1bmMiLCJuZXdTdHJlYW1GdW5jIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJjdHgiLCJnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQiLCJ1c2VWYXIiLCJpbml0VmFsIiwicmVjb3JkIiwiY3VycmVudCIsInVzZVJlcXVlc3RVcGRhdGUiLCJyZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsImluaXRpYWxpemVyIiwidXNlRXZlbnRFbWl0dGVyIiwic3RyZWFtIiwiY291bnQiLCJsYXRlc3RWYWx1ZSIsImVtaXQiLCJ2YWx1ZSIsInVzZUV2ZW50UmVjZWl2ZXIiLCJsYXN0U2Vlbk51bWJlciIsImJveGVkRXZlbnQiLCJ1c2VEeW5hbWljIiwib3J1IiwiYWN0aXZlQ29udGV4dHMiLCJTZXQiLCJjcmVhdGVDb250ZXh0IiwiZGVsZXRlIiwiYWRkIiwidXNlUmVkdWNlciIsImFjdGlvbkV2dHMiLCJyZWR1Y2VyRnVuYyIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwiYWN0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFB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bkI7QUFDRDtBQUVNLFNBQVNHLFVBQVQsQ0FBb0JDLFVBQXBCLEVBQWdDQyxXQUFoQyxFQUE2Q0MsWUFBN0MsRUFBMkQ7QUFDaEUsUUFBTUMsS0FBSyxHQUFHNUIsTUFBTSxDQUFDMkIsWUFBRCxDQUFwQjtBQUNBLFFBQU1FLE1BQU0sR0FBR2YsZ0JBQWdCLENBQUNXLFVBQUQsQ0FBL0I7QUFDQUcsT0FBSyxDQUFDekIsT0FBTixHQUFnQnVCLFdBQVcsQ0FBQ0csTUFBRCxFQUFTRCxLQUFLLENBQUN6QixPQUFmLENBQTNCO0FBQ0EsU0FBT3lCLEtBQUssQ0FBQ3pCLE9BQWI7QUFDRCIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibGV0IGN1cnJlbnRVcGRhdGVGcmFtZSA9IG51bGw7XG5cbmNsYXNzIEV4ZWN1dGlvbkNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihzdHJlYW1GdW5jLCBvblJlcXVlc3RVcGRhdGUsIGFmdGVyVGVybWluYXRlKSB7XG4gICAgdGhpcy5zdHJlYW1GdW5jID0gc3RyZWFtRnVuYztcbiAgICB0aGlzLm9uUmVxdWVzdFVwZGF0ZSA9IG9uUmVxdWVzdFVwZGF0ZTtcbiAgICB0aGlzLmFmdGVyVGVybWluYXRlID0gYWZ0ZXJUZXJtaW5hdGU7XG5cbiAgICB0aGlzLmhvb2tSZWNvcmRDaGFpbiA9IHtuZXh0OiBudWxsfTsgLy8gZHVtbXlcbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IG51bGw7IC8vIG9ubHkgc2V0IHdoZW4gdGhpcyBjb250ZXh0IGlzIHVwZGF0aW5nXG4gICAgdGhpcy51cGRhdGVDb3VudCA9IDA7XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgLy8gUHVzaCBhIG5ldyB1cGRhdGUgZnJhbWUgb250byB0aGUgdXBkYXRlIHN0YWNrIGZvciB0aGlzIGNvbnRleHRcbiAgICBjb25zdCBuZXdGcmFtZSA9IHtcbiAgICAgIGV4ZWN1dGlvbkNvbnRleHQ6IHRoaXMsXG4gICAgICBwcmV2aW91c0ZyYW1lOiBjdXJyZW50VXBkYXRlRnJhbWUsXG4gICAgfTtcbiAgICBjdXJyZW50VXBkYXRlRnJhbWUgPSBuZXdGcmFtZTtcblxuICAgIC8vIE1vdmUgaG9vayByZWNvcmQgY3Vyc29yIHRvIHN0YXJ0IG9mIGNoYWluXG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSB0aGlzLmhvb2tSZWNvcmRDaGFpbjtcblxuICAgIGNvbnN0IHJldHZhbCA9IHRoaXMuc3RyZWFtRnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgbnVsbCwgb3RoZXJ3aXNlIHRoZXJlIGFyZSBob29rIHJlY29yZHMgd2UgZGlkbid0IGdldCB0bywgYW5kIHNvbWV0aGluZyBpcyBhbWlzc1xuICAgIGlmICh0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgcmVhY2ggYWxsIGhvb2sgcmVjb3JkcyBpbiB1cGRhdGUnKTtcbiAgICB9XG5cbiAgICAvLyBQb3AgdGhlIHRvcCBmcmFtZSBmcm9tIHRoZSB1cGRhdGUgc3RhY2tcbiAgICBjb25zdCBwb3BwZWRGcmFtZSA9IGN1cnJlbnRVcGRhdGVGcmFtZTtcbiAgICBpZiAoIXBvcHBlZEZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwb3AgdXBkYXRlIGZyYW1lIGJlY2F1c2UgY3VycmVudCBpcyBudWxsJyk7XG4gICAgfVxuICAgIGlmIChwb3BwZWRGcmFtZS5leGVjdXRpb25Db250ZXh0ICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3BwZWQgZnJhbWUgZnJvbSB1cGRhdGUgc3RhY2sgYnV0IGNvbnRleHQgZGlkIG5vdCBtYXRjaFwiKTtcbiAgICB9XG4gICAgY3VycmVudFVwZGF0ZUZyYW1lID0gcG9wcGVkRnJhbWUucHJldmlvdXNGcmFtZTtcblxuICAgIHRoaXMudXBkYXRlQ291bnQrKztcblxuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICB0ZXJtaW5hdGUoKSB7XG4gICAgLy8gTk9URTogTWlnaHQgd2Ugd2FudCB0byBzYW5pdHkgY2hlY2sgdGhhdCB0aGlzIGNvbnRleHQgaXNuJ3QgYW55d2hlcmUgaW4gdGhlIGN1cnJlbnQgdXBkYXRlIHN0YWNrP1xuXG4gICAgLy8gQ2FsbCBhbnkgY2xlYW51cCBmdW5jdGlvbnMgc2V0IGJ5IGhvb2tzXG4gICAgLy8gVE9ETzogRG8gd2UgbmVlZCB0byB3b3JyeSBhYm91dCBvcmRlcj9cbiAgICBmb3IgKGxldCBjID0gdGhpcy5ob29rUmVjb3JkQ2hhaW4ubmV4dDsgYzsgYyA9IGMubmV4dCkge1xuICAgICAgaWYgKGMuY2xlYW51cCkge1xuICAgICAgICBjLmNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZnRlclRlcm1pbmF0ZSkge1xuICAgICAgdGhpcy5hZnRlclRlcm1pbmF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9iZWdpbkhvb2soKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlQ291bnQgPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIHRvIGNyZWF0ZSBuZXcgaG9vayByZWNvcmQgaW4gY2hhaW4sIGJ1dCBhbHJlYWR5IHByZXNlbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENyZWF0ZSBuZXcgcmVjb3JkXG4gICAgICB0aGlzLnJlY29yZEN1cnNvci5uZXh0ID0ge1xuICAgICAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgICAgIGNsZWFudXA6IHVuZGVmaW5lZCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0aW5nIHRvIGZpbmQgaG9vayByZWNvcmQgaW4gY2hhaW4sIGJ1dCBub3QgcHJlc2VudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJlY29yZEN1cnNvci5uZXh0O1xuICB9XG5cbiAgX2VuZEhvb2soKSB7XG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSB0aGlzLnJlY29yZEN1cnNvci5uZXh0OyAvLyBtb3ZlIGN1cnNvciBmb3J3YXJkXG4gIH1cblxuICBfcmVxdWVzdFVwZGF0ZSgpIHtcbiAgICB0aGlzLm9uUmVxdWVzdFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgb25seSBzYWZlIHRvIGRvIGlmIHRoZSByZXBsYWNlbWVudCBmdW5jdGlvbiBjYWxscyB0aGUgc2FtZSBob29rcywgaGFzIHNhbWUgc2lnbmF0dXJlLCBldGMuXG4gICAqIEl0J3MgY3VycmVudGx5IHVzZWQgdG8gcHJvdmlkZSBhIGZ1bmN0aW9uIHRoYXQgaXMgbGV4aWNhbGx5IHRoZSBzYW1lIGJ1dCBib3VuZCB0byBkaWZmZXJlbnQgb3V0ZXItc2NvcGVcbiAgICogdmFyaWFibGVzLlxuICAgKi9cbiAgX3NldFN0cmVhbUZ1bmMobmV3U3RyZWFtRnVuYykge1xuICAgIHRoaXMuc3RyZWFtRnVuYyA9IG5ld1N0cmVhbUZ1bmM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0KHN0cmVhbUZ1bmMpIHtcbiAgY29uc3Qgb25SZXF1ZXN0VXBkYXRlID0gKCkgPT4geyBjdHgudXBkYXRlKCkgfTtcbiAgY29uc3QgY3R4ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlKVxuICByZXR1cm4gY3R4O1xufVxuXG4vKipcbiAqIFRoaXMgaXMgdXNlZCBieSBob29rcyB0byBnZXQgdGhlIGN1cnJlbnRseSB1cGRhdGluZyBjb250ZXh0IChhZnRlciB2ZXJpZnlpbmcgaXQgaXMgc2V0KVxuICovXG5mdW5jdGlvbiBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKSB7XG4gIGlmICghY3VycmVudFVwZGF0ZUZyYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IGN1cnJlbnRseSB1cGRhdGluZyBleGVjdXRpb24gY29udGV4dCBiZWNhdXNlIHVwZGF0ZSBzdGFjayBpcyBlbXB0eS4gV2FzIGEgaG9vayBjYWxsZWQgb3V0c2lkZSBvZiBhbiBleGVjdXRpb24gY29udGV4dCB1cGRhdGU/Jyk7XG4gIH1cbiAgcmV0dXJuIGN1cnJlbnRVcGRhdGVGcmFtZS5leGVjdXRpb25Db250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVmFyKGluaXRWYWwpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gQ3JlYXRlIHZhbHVlIGJveCBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge2N1cnJlbnQ6IGluaXRWYWx9O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhO1xufVxuXG4vKipcbiAqIFdoeSBkbyB3ZSBuZWVkIGEgaG9vaz8gV2h5IGNhbid0IHdlIGp1c3QgY2FsbCBjdHgucmVxdWVzdFVwZGF0ZSgpPyBCZWNhdXNlIHRoZSByZXF1ZXN0VXBkYXRlXG4gKiBmdW5jdGlvbiB0aGF0IHdlIHJldHVybiB3aWxsIG9mdGVuIGJlIGNhbGxlZCB3aXRob3V0IHRoZXJlIGJlaW5nIGFueSB1cGRhdGluZyBleGVjdXRpb24gY29udGV4dFxuICogKGUuZy4gZnJvbSBhbiBldmVudCBoYW5kbGVyKS4gU28gaXQgaGFzIHRvIGJlIGJvdW5kIHRvIHRoZSBjb3JyZWN0IGNvbnRleHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXF1ZXN0VXBkYXRlKCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBDcmVhdGUgY2FsbGJhY2sgaWYgbmVjZXNzYXJ5LiBXZSBzdG9yZSBpdCBzbyB0aGF0IHdlIGFscmVhZHkgcmV0dXJuIHRoZSBzYW1lIG9uZS5cbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge3JlcXVlc3RVcGRhdGU6ICgpID0+IHtcbiAgICAgIGN0eC5fcmVxdWVzdFVwZGF0ZSgpOyAvLyBpdCdzIGltcG9ydGFudCB0aGF0IHdlIHVzZSBjdHggZnJvbSBjbG9zdXJlLCBub3QgZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCkgaGVyZVxuICAgIH19O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhLnJlcXVlc3RVcGRhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbml0aWFsaXplKGluaXRpYWxpemVyKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICAvLyBkYXRhIGJlaW5nIHVuZGVmaW5lZCBtZWFucyB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsXG5cbiAgICByZWNvcmQuY2xlYW51cCA9IGluaXRpYWxpemVyKCk7XG5cbiAgICByZWNvcmQuZGF0YSA9IHt9OyAvLyBubyBkYXRhIHRvIHN0b3JlIHlldCwganVzdCBuZWVkcyB0byBiZSB0cnV0aHkgdG8gaW5kaWNhdGUgdGhhdCBpbml0aWFsaXphdGlvbiByYW5cbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRFbWl0dGVyKCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgY291bnQ6IDAsIC8vIGhvdyBtYW55IGV2ZW50cyBoYXZlIG9jY3VycmVkIG9uIHRoaXMgc3RyZWFtXG4gICAgICBsYXRlc3RWYWx1ZTogdW5kZWZpbmVkLFxuICAgIH1cblxuICAgIHJlY29yZC5kYXRhID0ge1xuICAgICAgc3RyZWFtLFxuICAgICAgZW1pdDogKHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gY2xvc2VzIG92ZXIgdGhlIHN0cmVhbSB2YXJpYWJsZVxuICAgICAgICBzdHJlYW0ubGF0ZXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgc3RyZWFtLmNvdW50Kys7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gW3JlY29yZC5kYXRhLnN0cmVhbSwgcmVjb3JkLmRhdGEuZW1pdF07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudFJlY2VpdmVyKHN0cmVhbSkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7XG4gICAgICBzdHJlYW0sIC8vIHRoZSBzdHJlYW0gd2UgYXJlIHJlY2VpdmluZyBvblxuICAgICAgbGFzdFNlZW5OdW1iZXI6IHN0cmVhbS5jb3VudCxcbiAgICB9O1xuICB9XG5cbiAgLy8gVE9ETzogV2UgY291bGQgc3VwcG9ydCB0aGlzLCBqdXN0IG5lZWQgdG8gY29uc2lkZXIgZGV0YWlscy5cbiAgaWYgKHN0cmVhbSAhPT0gcmVjb3JkLmRhdGEuc3RyZWFtKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCByZWNlaXZlciBmb3VuZCB0aGF0IHN0cmVhbSBvYmplY3QgY2hhbmdlZCBpZGVudGl0eScpO1xuICB9XG5cbiAgbGV0IGJveGVkRXZlbnQ7XG5cbiAgaWYgKHJlY29yZC5kYXRhLmxhc3RTZWVuTnVtYmVyID09PSBzdHJlYW0uY291bnQpIHtcbiAgICAvLyBUaGVyZSBoYXZlIG5vdCBiZWVuIGFueSBuZXcgZXZlbnRzIG9uIHRoZSBzdHJlYW1cbiAgfSBlbHNlIGlmIChyZWNvcmQuZGF0YS5sYXN0U2Vlbk51bWJlciA9PT0gKHN0cmVhbS5jb3VudCAtIDEpKSB7XG4gICAgLy8gVGhlcmUgaGFzIGJlZW4gZXhhY3RseSBvbmUgbmV3IGV2ZW50IG9uIHRoZSBzdHJlYW0gdGhhdCB3ZSBoYXZlbid0IHNlZW4geWV0LlxuICAgIGJveGVkRXZlbnQgPSB7dmFsdWU6IHN0cmVhbS5sYXRlc3RWYWx1ZX07XG4gICAgcmVjb3JkLmRhdGEubGFzdFNlZW5OdW1iZXIrKztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHJlY2VpdmVyIGdvdCB0b28gbWFueSBldmVudHMgb3IgbWlzc2VkIHNvbWUnKTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiBib3hlZEV2ZW50O1xufVxuXG4vKipcbiAqIFRoZSBzdHJlYW1GdW5jIGFyZ3VtZW50IG1heSBjaGFuZ2UsIGJ1dCBpdCBzaG91bGQgb25seSBjaGFuZ2UgdG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBzYWZlbHlcbiAqIHN3YXBwZWQgaW4gKGkuZS4gb25lIHRoYXQgY2FsbHMgdGhlIHNhbWUgaG9va3MsIGV0Yy4pLiBBIGNvbW1vbiBjYXNlIGlzIHRoYXQgc3RyZWFtRnVuYyBpcyBhXG4gKiBjbG9zdXJlIHRoYXQgcmVmZXJlbmNlcyBzb21lIG91dGVyIHNjb3BlIHZhcmlhYmxlcywgYW5kIHdoZW4gdGhvc2UgY2hhbmdlLCBhIG5ldyBcInZlcnNpb25cIiBvZlxuICogdGhlIGZ1bmN0aW9uIGlzIGNyZWF0ZWQgKGxleGljYWxseSB0aGUgc2FtZSwgYnV0IGNsb3Npbmcgb3ZlciBhIGRpZmZlcmVudCBzY29wZSkuXG4gKlxuICogb25SZXF1ZXN0VXBkYXRlIGlzIGN1cnJlbnRseSBvbmx5IHJlYWQgb24gdGhlIGZpcnN0IGNhbGwsIHNvIGNoYW5nZXMgdG8gaXQgd2lsbCBoYXZlIG5vIGVmZmVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUR5bmFtaWMoc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG5cbiAgICAvLyBJZiBubyBvblJlcXVlc3RVcGRhdGUgaXMgcHJvdmlkZWQsIGRlZmF1bHQgdG8gcmVxdWVzdGluZyB1cGRhdGUgb24gdGhlIGN1cnJlbnQgY29udGV4dFxuICAgIGNvbnN0IG9ydSA9IG9uUmVxdWVzdFVwZGF0ZSB8fCAoKCkgPT4ge1xuICAgICAgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfSk7XG5cbiAgICAvLyBUcmFjayBFeGVjdXRpb25Db250ZXh0cyBjcmVhdGVkIChhbmQgbm90IHlldCB0ZXJtaW5hdGVkKSBzbyB3ZSBjYW4gdGVybWluYXRlIHRoZW0gdXBvbiBjbGVhbnVwXG4gICAgZGF0YS5hY3RpdmVDb250ZXh0cyA9IG5ldyBTZXQoKTtcblxuICAgIC8vIENyZWF0ZSBcImZhY3RvcnlcIiBmdW5jdGlvbiB0byBpbnN0YW50aWF0ZSBuZXcgY29udGV4dHNcbiAgICBkYXRhLmNyZWF0ZUNvbnRleHQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjdHggPSBuZXcgRXhlY3V0aW9uQ29udGV4dChkYXRhLnN0cmVhbUZ1bmMsIG9ydSwgKCkgPT4geyBkYXRhLmFjdGl2ZUNvbnRleHRzLmRlbGV0ZShjdHgpOyB9KTtcbiAgICAgIGRhdGEuYWN0aXZlQ29udGV4dHMuYWRkKGN0eCk7XG4gICAgICByZXR1cm4gY3R4O1xuICAgIH07XG5cbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG4gICAgcmVjb3JkLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGN0eCBvZiBkYXRhLmFjdGl2ZUNvbnRleHRzKSB7XG4gICAgICAgIGN0eC50ZXJtaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBzdHJlYW0gZnVuY3Rpb24gaW4gcmVjb3JkIGFuZCBhbGwgYWN0aXZlIGNvbnRleHRzLlxuICByZWNvcmQuZGF0YS5zdHJlYW1GdW5jID0gc3RyZWFtRnVuYztcbiAgZm9yIChjb25zdCBjdHggb2YgcmVjb3JkLmRhdGEuYWN0aXZlQ29udGV4dHMpIHtcbiAgICBjdHguX3NldFN0cmVhbUZ1bmMoc3RyZWFtRnVuYyk7XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGEuY3JlYXRlQ29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZHVjZXIoYWN0aW9uRXZ0cywgcmVkdWNlckZ1bmMsIGluaXRpYWxTdGF0ZSkge1xuICBjb25zdCBzdGF0ZSA9IHVzZVZhcihpbml0aWFsU3RhdGUpO1xuICBjb25zdCBhY3Rpb24gPSB1c2VFdmVudFJlY2VpdmVyKGFjdGlvbkV2dHMpO1xuICBzdGF0ZS5jdXJyZW50ID0gcmVkdWNlckZ1bmMoYWN0aW9uLCBzdGF0ZS5jdXJyZW50KTtcbiAgcmV0dXJuIHN0YXRlLmN1cnJlbnQ7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/riv.js\nvar riv = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useEventEmitter,\n  useEventReceiver,\n  useDynamic,\n  useReducer\n} = __webpack_require__(0);\n\nfunction showString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'border: 1px solid red; color: black; font-size: 24px; padding: 5px; margin-top: 20px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = 'showString: ' + (v === undefined ? '(undefined)' : v.toString());\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvts, emitClick] = useEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvts;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction mousePosition() {\n  const requestUpdate = useRequestUpdate();\n  const position = useVar({\n    x: 0,\n    y: 0\n  }); // we can't poll position, so start it at origin\n\n  useInitialize(() => {\n    const onMouseMove = e => {\n      position.current = {\n        x: e.clientX || e.pageX,\n        y: e.clientY || e.pageY\n      };\n      requestUpdate();\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n  return position.current;\n}\n\nfunction random(repickEvts) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvts);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  const [advanceFrameEvts, emitAdvanceFrame] = useEventEmitter();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        emitAdvanceFrame({});\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvts, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvts);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvts, emitTick] = useEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\n\nfunction loadAudioAsArray(url) {\n  const requestUpdate = useRequestUpdate();\n  const pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(() => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    let cleanedUp = false;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = () => {\n      const audioData = request.response;\n      audioCtx.decodeAudioData(audioData, buffer => {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return () => {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nfunction integral(integrandFunc, time, initialValue = 0) {\n  const accum = useVar(initialValue);\n  const prevTime = useVar(time);\n  const integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\n\nfunction expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(currentValue => speedConstant * (targetValue - currentValue), time, initialValue);\n}\n\nfunction redCircle(position, radius = 25) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'position: absolute; border-radius: 50%; background: red; pointer-events: none; user-select: none';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  const p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  const halfRadius = 0.5 * radius;\n  elem.current.style.left = p.x - halfRadius + 'px';\n  elem.current.style.top = p.y - halfRadius + 'px';\n  elem.current.style.width = radius + 'px';\n  elem.current.style.height = radius + 'px';\n}\n\nfunction followAtSpeed2d(target, speed, time, initial) {\n  const pos = useVar(initial);\n  const prevTime = useVar(time);\n  const dt = time - prevTime.current;\n  const delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    showString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    showString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    showString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    showString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvts, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    showString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    showString(nums.join(' '));\n  }\n}, {\n  name: 'record player spin up/down, hold mouse down and release',\n  main: () => {\n    const pcm = loadAudioAsArray('amen_break.mp3');\n    showString(pcm.length > 1 ? 'loaded audio' : 'loading audio...');\n    audioDriver((audioTime, advanceFrameEvts, sampleRate) => {\n      const targetSpeed = mouseDown() ? sampleRate : 0;\n      const speed = expFollow(targetSpeed, 3, audioTime, 0);\n      const pos = Math.floor(integral(() => speed, audioTime));\n      return pcm[pos % pcm.length]; // modulo so as to loop\n    });\n  }\n}, {\n  name: 'circle follows mouse',\n  main: () => {\n    redCircle(mousePosition());\n  }\n}, {\n  name: 'circle follows mouse at limited speed',\n  main: () => {\n    const time = animationTime();\n    const mpos = mousePosition();\n    redCircle(followAtSpeed2d(mpos, 300, time, mpos));\n  }\n}, {\n  name: 'circle moves halfway to mouse with each click',\n  main: () => {\n    const midpoint = (a, b) => ({\n      x: 0.5 * (a.x + b.x),\n      y: 0.5 * (a.y + b.y)\n    });\n\n    const mpos = mousePosition();\n    const clickEvts = mouseClickEvts();\n    const cpos = useReducer(clickEvts, (action, prevState) => {\n      return action ? midpoint(prevState, mpos) : prevState;\n    }, {\n      x: 0,\n      y: 0\n    });\n    redCircle(cpos);\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(riv[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUV2ZW50RW1pdHRlciIsInVzZUV2ZW50UmVjZWl2ZXIiLCJ1c2VEeW5hbWljIiwidXNlUmVkdWNlciIsInJlcXVpcmUiLCJzaG93U3RyaW5nIiwidiIsImVsZW0iLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsInVuZGVmaW5lZCIsInRvU3RyaW5nIiwiYW5pbWF0aW9uVGltZSIsInJlcXVlc3RVcGRhdGUiLCJ0aW1lIiwicmVxSWQiLCJvbkZyYW1lIiwidCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInBlcmZvcm1hbmNlIiwibm93IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhbmltYXRpb25GcmFtZUV2dHMiLCJmcmFtZUV2dHMiLCJlbWl0RnJhbWUiLCJjb3VudEV2ZW50cyIsImV2dHMiLCJjb3VudCIsImV2ZW50IiwibW91c2VDbGlja0V2dHMiLCJjbGlja0V2dHMiLCJlbWl0Q2xpY2siLCJvbk1vdXNlRG93biIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibW91c2VEb3duIiwiaXNEb3duIiwib25Nb3VzZVVwIiwibW91c2VQb3NpdGlvbiIsInBvc2l0aW9uIiwieCIsInkiLCJvbk1vdXNlTW92ZSIsImUiLCJjbGllbnRYIiwicGFnZVgiLCJjbGllbnRZIiwicGFnZVkiLCJyYW5kb20iLCJyZXBpY2tFdnRzIiwidmFsIiwiTWF0aCIsInJlcGljayIsImF1ZGlvRHJpdmVyIiwiZ2VuZXJhdG9yIiwiY3JlYXRlR2VuZXJhdG9yIiwiZ2VuZXJhdG9yQ3R4IiwiZnJhbWVDb3VudCIsInNhbXBsZVJhdGUiLCJhZHZhbmNlRnJhbWVFdnRzIiwiZW1pdEFkdmFuY2VGcmFtZSIsIkJVRkZFUl9TSVpFIiwiYXVkaW9Db250ZXh0Iiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic2NyaXB0Tm9kZSIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsIm9uYXVkaW9wcm9jZXNzIiwiYnVmZmVyIiwib3V0cHV0QnVmZmVyIiwiZ2V0Q2hhbm5lbERhdGEiLCJpIiwibGVuZ3RoIiwidXBkYXRlIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwiZGlzY29ubmVjdCIsImNsb3NlIiwic2FtcGxlVXBvbiIsInRvU2FtcGxlIiwidXBvbkV2dHMiLCJpbml0aWFsVmFsdWUiLCJoZWxkIiwidXBvbiIsImV2ZXJ5U2Vjb25kIiwidGlja0V2dHMiLCJlbWl0VGljayIsIm9uSW50ZXJ2YWwiLCJ0aW1lcklkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibG9hZEF1ZGlvQXNBcnJheSIsInVybCIsInBjbSIsImF1ZGlvQ3R4IiwiY2xlYW5lZFVwIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInJlc3BvbnNlVHlwZSIsIm9ubG9hZCIsImF1ZGlvRGF0YSIsInJlc3BvbnNlIiwiZGVjb2RlQXVkaW9EYXRhIiwic2VuZCIsImFib3J0IiwiY29uc29sZUxvZyIsImNvbnNvbGUiLCJsb2ciLCJpbnRlZ3JhbCIsImludGVncmFuZEZ1bmMiLCJhY2N1bSIsInByZXZUaW1lIiwiaW50ZWdyYW5kIiwiZXhwRm9sbG93IiwidGFyZ2V0VmFsdWUiLCJzcGVlZENvbnN0YW50IiwiY3VycmVudFZhbHVlIiwicmVkQ2lyY2xlIiwicmFkaXVzIiwicCIsImhhbGZSYWRpdXMiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJmb2xsb3dBdFNwZWVkMmQiLCJ0YXJnZXQiLCJzcGVlZCIsImluaXRpYWwiLCJwb3MiLCJkdCIsImRlbHRhIiwiZGlzdCIsInNxcnQiLCJuYW1lIiwibWFpbiIsInRvRml4ZWQiLCJtZCIsImF1ZGlvVGltZSIsIm5vaXNlIiwibGFzdENsaWNrVGltZSIsIkluZmluaXR5IiwiZGVjYXlpbmdHYWluIiwiZXhwIiwiY2xpY2siLCJjcmVhdGVDb3VudGVyIiwiYWN0aXZlQ291bnRlciIsInRlcm1pbmF0ZSIsImRpc3BsYXllZENvdW50IiwiY3JlYXRlQ2xvY2siLCJjbG9ja0FycmF5IiwicHVzaCIsIm51bXMiLCJtYXAiLCJjbG9jayIsImpvaW4iLCJ0YXJnZXRTcGVlZCIsImZsb29yIiwibXBvcyIsIm1pZHBvaW50IiwiYSIsImIiLCJjcG9zIiwiYWN0aW9uIiwicHJldlN0YXRlIiwicHJvZ3JhbUxpc3RFbGVtIiwiZ2V0RWxlbWVudEJ5SWQiLCJwcm9ncmFtU291cmNlRWxlbSIsImN1cnJlbnRDb250ZXh0IiwiZml4SW5kZW50IiwiY29kZSIsInNwbGl0IiwibGluZSIsImlkeCIsInN1YnN0ciIsInN0YXJ0UHJvZ3JhbSIsInByb2dyYW0iLCJjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dCIsInByb2ciLCJwcm9ncmFtcyIsImFuY2hvckVsZW0iLCJzZXRBdHRyaWJ1dGUiLCJwcmV2ZW50RGVmYXVsdCIsInNldFRpbWVvdXQiLCJpdGVtRWxlbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxNQUFNO0FBQUVBLFFBQUY7QUFBVUMsa0JBQVY7QUFBNEJDLGVBQTVCO0FBQTJDQyxpQkFBM0M7QUFBNERDLGtCQUE1RDtBQUE4RUMsWUFBOUU7QUFBMEZDO0FBQTFGLElBQXlHQyxtQkFBTyxDQUFDLENBQUQsQ0FBdEg7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUI7QUFDckIsUUFBTUMsSUFBSSxHQUFHVixNQUFNLENBQUMsSUFBRCxDQUFuQjtBQUVBRSxlQUFhLENBQUMsTUFBTTtBQUNsQlEsUUFBSSxDQUFDQyxPQUFMLEdBQWVDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FB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Q0FBWjtBQUNELE9BRlMsRUFFUCxDQUZPLENBQVY7QUFHRCxLQUxEO0FBTUQsR0FQRDs7QUFTQSxRQUFNTSxRQUFRLEdBQUd4TCxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsSUFBdkIsQ0FBakI7QUFDQXVMLFVBQVEsQ0FBQ2xMLFdBQVQsQ0FBcUI4SyxVQUFyQjtBQUVBZixpQkFBZSxDQUFDL0osV0FBaEIsQ0FBNEJrTCxRQUE1QjtBQUNEOztBQUVEVCxZQUFZLENBQUNJLFFBQVEsQ0FBQyxDQUFELENBQVQsQ0FBWiIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTk9URTogVXNpbmcgcmVxdWlyZSBpbnN0ZWFkIG9mIGltcG9ydCBoZXJlIG1ha2VzIHRoZSB0aGluZyB3aGVyZSB3ZSBwcmludCBwcm9ncmFtIHRleHQgd29yayBiZXR0ZXIuXG5jb25zdCB7IHVzZVZhciwgdXNlUmVxdWVzdFVwZGF0ZSwgdXNlSW5pdGlhbGl6ZSwgdXNlRXZlbnRFbWl0dGVyLCB1c2VFdmVudFJlY2VpdmVyLCB1c2VEeW5hbWljLCB1c2VSZWR1Y2VyIH0gPSByZXF1aXJlKCcuL3JpdicpO1xuXG5mdW5jdGlvbiBzaG93U3RyaW5nKHYpIHtcbiAgY29uc3QgZWxlbSA9IHVzZVZhcihudWxsKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBlbGVtLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtLmN1cnJlbnQuc3R5bGUuY3NzVGV4dCA9ICdib3JkZXI6IDFweCBzb2xpZCByZWQ7IGNvbG9yOiBibGFjazsgZm9udC1zaXplOiAyNHB4OyBwYWRkaW5nOiA1cHg7IG1hcmdpbi10b3A6IDIwcHgnO1xuICAgIGVsZW0uY3VycmVudC50ZXh0Q29udGVudCA9ICcodW5kZWZpbmVkKSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtLmN1cnJlbnQpO1xuICAgIH1cbiAgfSlcblxuICBlbGVtLmN1cnJlbnQudGV4dENvbnRlbnQgPSAnc2hvd1N0cmluZzogJyArICgodiA9PT0gdW5kZWZpbmVkKSA/ICcodW5kZWZpbmVkKScgOiB2LnRvU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRpb25UaW1lKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCB0aW1lID0gdXNlVmFyKCk7XG4gIGNvbnN0IHJlcUlkID0gdXNlVmFyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICB0aW1lLmN1cnJlbnQgPSAwLjAwMSp0O1xuICAgICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTsgLy8gcmVxdWVzdCBhbm90aGVyXG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXFJZC5jdXJyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvbkZyYW1lRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2ZyYW1lRXZ0cywgZW1pdEZyYW1lXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uRnJhbWUgPSAodCkgPT4ge1xuICAgICAgZW1pdEZyYW1lKCk7XG4gICAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpOyAvLyByZXF1ZXN0IGFub3RoZXJcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcUlkLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZyYW1lRXZ0cztcbn1cblxuZnVuY3Rpb24gY291bnRFdmVudHMoZXZ0cykge1xuICBjb25zdCBjb3VudCA9IHVzZVZhcigwKTtcbiAgY29uc3QgZXZlbnQgPSB1c2VFdmVudFJlY2VpdmVyKGV2dHMpO1xuXG4gIGlmIChldmVudCkge1xuICAgIGNvdW50LmN1cnJlbnQrKztcbiAgfVxuXG4gIHJldHVybiBjb3VudC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBtb3VzZUNsaWNrRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW2NsaWNrRXZ0cywgZW1pdENsaWNrXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgZW1pdENsaWNrKCk7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbGlja0V2dHM7XG59XG5cbmZ1bmN0aW9uIG1vdXNlRG93bigpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgaXNEb3duID0gdXNlVmFyKGZhbHNlKTsgLy8gd2UgY2FuJ3QgcG9sbCBkb3duLW5lc3MsIHNvIHdlIGFzc3VtZSBpdCdzIGluaXRpYWxseSBub3QgZG93blxuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgaXNEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBpc0Rvd24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzRG93bi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBtb3VzZVBvc2l0aW9uKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBwb3NpdGlvbiA9IHVzZVZhcih7eDogMCwgeTogMH0pOyAvLyB3ZSBjYW4ndCBwb2xsIHBvc2l0aW9uLCBzbyBzdGFydCBpdCBhdCBvcmlnaW5cblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbk1vdXNlTW92ZSA9IChlKSA9PiB7XG4gICAgICBwb3NpdGlvbi5jdXJyZW50ID0ge1xuICAgICAgICB4OiBlLmNsaWVudFggfHwgZS5wYWdlWCxcbiAgICAgICAgeTogZS5jbGllbnRZIHx8IGUucGFnZVksXG4gICAgICB9O1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwb3NpdGlvbi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiByYW5kb20ocmVwaWNrRXZ0cykge1xuICBjb25zdCB2YWwgPSB1c2VWYXIoTWF0aC5yYW5kb20oKSk7XG4gIGNvbnN0IHJlcGljayA9IHVzZUV2ZW50UmVjZWl2ZXIocmVwaWNrRXZ0cyk7XG5cbiAgaWYgKHJlcGljaykge1xuICAgIHZhbC5jdXJyZW50ID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuXG4gIHJldHVybiB2YWwuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYXVkaW9Ecml2ZXIoZ2VuZXJhdG9yKSB7XG4gIGNvbnN0IGNyZWF0ZUdlbmVyYXRvciA9IHVzZUR5bmFtaWMoZ2VuZXJhdG9yKTtcbiAgY29uc3QgZ2VuZXJhdG9yQ3R4ID0gdXNlVmFyKCk7XG4gIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VWYXIoMCk7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2FkdmFuY2VGcmFtZUV2dHMsIGVtaXRBZHZhbmNlRnJhbWVdID0gdXNlRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgZ2VuZXJhdG9yQ3R4LmN1cnJlbnQgPSBjcmVhdGVHZW5lcmF0b3IoKTtcblxuICAgIGNvbnN0IEJVRkZFUl9TSVpFID0gMTAyNDtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBjb25zdCBzY3JpcHROb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihCVUZGRVJfU0laRSwgMCwgMSk7IC8vIDAgaW5wdXQgY2hhbm5lbHMsIDEgb3V0cHV0IGNoYW5uZWxcbiAgICBzY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGUub3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW1pdEFkdmFuY2VGcmFtZSh7fSk7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCBhZHZhbmNlRnJhbWVFdnRzLCBzYW1wbGVSYXRlLmN1cnJlbnQpO1xuICAgICAgICBmcmFtZUNvdW50LmN1cnJlbnQrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdE5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gICAgc2FtcGxlUmF0ZS5jdXJyZW50ID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICB9O1xuICB9KTtcblxuICAvKipcbiAgICogTW9zdCBvZiBvdXIgZ2VuZXJhdG9yIHVwZGF0aW5nIHdpbGwgaGFwcGVuIGluIHRoZSBhdWRpbyBwcm9jZXNzaW5nIGNhbGxiYWNrIGFib3ZlLlxuICAgKiBUaGlzIHVwZGF0ZSBoZXJlIGlzIGZvciB3aGVuIHRoZSBhdWRpb0RyaXZlciB1cGRhdGUgaXMgY2FsbGVkLCBlLmcuIHdoZW4gYW4gb3V0ZXIgc2NvcGVcbiAgICogcmVmZXJlbmNlIHRoYXQgdGhlIGdlbmVyYXRvciBkZXBlbmRzIG9uIGhhcyBjaGFuZ2VkLiBTbyB3ZSBtdXN0IHVwZGF0ZSB0aGUgZ2VuZXJhdG9yLFxuICAgKiBidXQgZG9uJ3QgbmVlZCBpdHMgb3V0cHV0IGFtcGxpdHVkZS5cbiAgICovXG4gIGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCBhZHZhbmNlRnJhbWVFdnRzLCBzYW1wbGVSYXRlLmN1cnJlbnQpOyAvLyBOT1RFOiB3ZSBkaXNjYXJkIHJldHZhbFxufVxuXG5mdW5jdGlvbiBzYW1wbGVVcG9uKHRvU2FtcGxlLCB1cG9uRXZ0cywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGhlbGQgPSB1c2VWYXIoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdXBvbiA9IHVzZUV2ZW50UmVjZWl2ZXIodXBvbkV2dHMpO1xuXG4gIGlmICh1cG9uKSB7XG4gICAgaGVsZC5jdXJyZW50ID0gdG9TYW1wbGU7XG4gIH1cblxuICByZXR1cm4gaGVsZC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBldmVyeVNlY29uZCgpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW3RpY2tFdnRzLCBlbWl0VGlja10gPSB1c2VFdmVudEVtaXR0ZXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkludGVydmFsID0gKCkgPT4ge1xuICAgICAgZW1pdFRpY2soKTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXJJZCA9IHNldEludGVydmFsKG9uSW50ZXJ2YWwsIDEwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aWNrRXZ0cztcbn1cblxuLyoqXG4gKiBVbnRpbCBhdWRpbyBpcyBsb2FkZWQgYW5kIGRlY29kZWQsIGEgc2luZ2xlLXNhbXBsZSBidWZmZXIgb2Ygc2lsZW5jZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gbG9hZEF1ZGlvQXNBcnJheSh1cmwpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcGNtID0gdXNlVmFyKFswXSk7IC8vIHVudGlsIGxvYWRlZCwganVzdCByZXR1cm4gc2luZ2xlIHNhbXBsZSBvZiBzaWxlbmNlXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3QgYXVkaW9DdHggPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBsZXQgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBidWZmZXIgPT4ge1xuICAgICAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgICAgIHBjbS5jdXJyZW50ID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgcmVxdWVzdC5hYm9ydCgpOyAvLyBpdCdzIHNhZmUgdG8gYWx3YXlzIGFib3J0IGhlcmUuIGlmIGFscmVhZHkgY29tcGxldGVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcblxuICAgICAgLy8gZGVjb2RlQXVkaW9EYXRhIGNhbm5vdCBiZSBjYW5jZWxlZC4gU28gdG8gYmUgY29ycmVjdCwgd2UgbXVzdCBzZXQgYSBmbGFnIGhlcmUgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IGRlY29kaW5nIGlzIGlnbm9yZWRcbiAgICAgIGNsZWFuZWRVcCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGNtLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2codikge1xuICBjb25zb2xlLmxvZyh2KTtcbn1cblxuZnVuY3Rpb24gaW50ZWdyYWwoaW50ZWdyYW5kRnVuYywgdGltZSwgaW5pdGlhbFZhbHVlID0gMCkge1xuICBjb25zdCBhY2N1bSA9IHVzZVZhcihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBwcmV2VGltZSA9IHVzZVZhcih0aW1lKTtcblxuICBjb25zdCBpbnRlZ3JhbmQgPSBpbnRlZ3JhbmRGdW5jKGFjY3VtLmN1cnJlbnQsIHByZXZUaW1lLmN1cnJlbnQpO1xuICBhY2N1bS5jdXJyZW50ICs9ICh0aW1lIC0gcHJldlRpbWUuY3VycmVudCkqaW50ZWdyYW5kO1xuXG4gIHByZXZUaW1lLmN1cnJlbnQgPSB0aW1lO1xuXG4gIHJldHVybiBhY2N1bS5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBleHBGb2xsb3codGFyZ2V0VmFsdWUsIHNwZWVkQ29uc3RhbnQsIHRpbWUsIGluaXRpYWxWYWx1ZSkge1xuICByZXR1cm4gaW50ZWdyYWwoY3VycmVudFZhbHVlID0+IHNwZWVkQ29uc3RhbnQqKHRhcmdldFZhbHVlIC0gY3VycmVudFZhbHVlKSwgdGltZSwgaW5pdGlhbFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gcmVkQ2lyY2xlKHBvc2l0aW9uLCByYWRpdXMgPSAyNSkge1xuICBjb25zdCBlbGVtID0gdXNlVmFyKG51bGwpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGVsZW0uY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW0uY3VycmVudC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgYm9yZGVyLXJhZGl1czogNTAlOyBiYWNrZ3JvdW5kOiByZWQ7IHBvaW50ZXItZXZlbnRzOiBub25lOyB1c2VyLXNlbGVjdDogbm9uZSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtLmN1cnJlbnQpO1xuICAgIH1cbiAgfSlcblxuICBjb25zdCBwID0gcG9zaXRpb24gfHwge3g6IDAsIHk6IDB9O1xuICBpZiAocmFkaXVzIDwgMCkge1xuICAgIHJhZGl1cyA9IDA7XG4gIH1cbiAgY29uc3QgaGFsZlJhZGl1cyA9IDAuNSpyYWRpdXM7XG5cbiAgZWxlbS5jdXJyZW50LnN0eWxlLmxlZnQgPSAocC54IC0gaGFsZlJhZGl1cykgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUudG9wID0gKHAueSAtIGhhbGZSYWRpdXMpICsgJ3B4JztcbiAgZWxlbS5jdXJyZW50LnN0eWxlLndpZHRoID0gcmFkaXVzICsgJ3B4JztcbiAgZWxlbS5jdXJyZW50LnN0eWxlLmhlaWdodCA9IHJhZGl1cyArICdweCc7XG59XG5cbmZ1bmN0aW9uIGZvbGxvd0F0U3BlZWQyZCh0YXJnZXQsIHNwZWVkLCB0aW1lLCBpbml0aWFsKSB7XG4gIGNvbnN0IHBvcyA9IHVzZVZhcihpbml0aWFsKTtcbiAgY29uc3QgcHJldlRpbWUgPSB1c2VWYXIodGltZSk7XG5cbiAgY29uc3QgZHQgPSB0aW1lIC0gcHJldlRpbWUuY3VycmVudDtcbiAgY29uc3QgZGVsdGEgPSB7eDogdGFyZ2V0LngtcG9zLmN1cnJlbnQueCwgeTogdGFyZ2V0LnktcG9zLmN1cnJlbnQueX07XG4gIGNvbnN0IGRpc3QgPSBNYXRoLnNxcnQoZGVsdGEueCpkZWx0YS54ICsgZGVsdGEueSpkZWx0YS55KTtcbiAgaWYgKHNwZWVkKmR0ID49IGRpc3QpIHtcbiAgICAvLyBKdW1wIHRvIHRhcmdldCBwb3NpdGlvblxuICAgIHBvcy5jdXJyZW50ID0gdGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIC8vIE5PVEU6IFdlIG11c3Qgbm90IG11dGF0ZSBwb3MuY3VycmVudCwgc2luY2Ugd2UgcmV0dXJuIHRoYXRcbiAgICBwb3MuY3VycmVudCA9IHtcbiAgICAgIHg6IHBvcy5jdXJyZW50LnggKyBkdCpzcGVlZCpkZWx0YS54L2Rpc3QsXG4gICAgICB5OiBwb3MuY3VycmVudC55ICsgZHQqc3BlZWQqZGVsdGEueS9kaXN0LFxuICAgIH07XG4gIH1cblxuICBwcmV2VGltZS5jdXJyZW50ID0gdGltZTtcblxuICByZXR1cm4gcG9zLmN1cnJlbnQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFtcbiAge1xuICAgIG5hbWU6ICdkbyBub3RoaW5nJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2FuaW1hdGlvbiB0aW1lJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKGFuaW1hdGlvblRpbWUoKS50b0ZpeGVkKDMpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY291bnQgY2xpY2tzJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKGNvdW50RXZlbnRzKG1vdXNlQ2xpY2tFdnRzKCkpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnaXMgbW91c2UgYnV0dG9uIGRvd24nLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcobW91c2VEb3duKCkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyYW5kb20gbnVtYmVyLCBjbGljayB0byByZXBpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcocmFuZG9tKG1vdXNlQ2xpY2tFdnRzKCkpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnYXVkaW8gbm9pc2Ugd2hlbiBtb3VzZSBpcyBkb3duJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBtZCA9IG1vdXNlRG93bigpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0cykgPT4ge1xuICAgICAgICBjb25zdCBub2lzZSA9IHJhbmRvbShhZHZhbmNlRnJhbWVFdnRzKSAtIDAuNTtcbiAgICAgICAgcmV0dXJuIG1kID8gbm9pc2UgOiAwO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2RlY2F5aW5nIG5vaXNlIHVwb24gY2xpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBhdWRpb0RyaXZlcigoYXVkaW9UaW1lLCBhZHZhbmNlRnJhbWVFdnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vaXNlID0gcmFuZG9tKGFkdmFuY2VGcmFtZUV2dHMpIC0gMC41O1xuICAgICAgICBjb25zdCBsYXN0Q2xpY2tUaW1lID0gc2FtcGxlVXBvbihhdWRpb1RpbWUsIGNsaWNrRXZ0cywgLUluZmluaXR5KTtcbiAgICAgICAgY29uc3QgZGVjYXlpbmdHYWluID0gTWF0aC5leHAoNSoobGFzdENsaWNrVGltZSAtIGF1ZGlvVGltZSkpO1xuICAgICAgICByZXR1cm4gZGVjYXlpbmdHYWluKm5vaXNlO1xuICAgICAgfSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3Jlc2V0dGluZyBmcmFtZSBjb3VudGVyLCBjbGljayB0byByZXNldCcsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgZnJhbWVFdnRzID0gYW5pbWF0aW9uRnJhbWVFdnRzKCk7XG4gICAgICBjb25zdCBjbGlja0V2dHMgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2sgPSB1c2VFdmVudFJlY2VpdmVyKGNsaWNrRXZ0cyk7XG4gICAgICBjb25zdCBjcmVhdGVDb3VudGVyID0gdXNlRHluYW1pYyhjb3VudEV2ZW50cyk7XG4gICAgICBjb25zdCBhY3RpdmVDb3VudGVyID0gdXNlVmFyKCk7XG5cbiAgICAgIGlmIChjbGljaykge1xuICAgICAgICBpZiAoYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50LnRlcm1pbmF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICghYWN0aXZlQ291bnRlci5jdXJyZW50KSB7XG4gICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudCA9IGNyZWF0ZUNvdW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGlzcGxheWVkQ291bnQgPSBhY3RpdmVDb3VudGVyLmN1cnJlbnQudXBkYXRlKGZyYW1lRXZ0cyk7XG4gICAgICBzaG93U3RyaW5nKGRpc3BsYXllZENvdW50KTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdkeW5hbWljIGFycmF5IG9mIGFzeW5jIGNsb2NrcywgY2xpY2sgdG8gYWRkJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBjbGlja0V2dHMgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2sgPSB1c2VFdmVudFJlY2VpdmVyKGNsaWNrRXZ0cyk7XG4gICAgICBjb25zdCBjcmVhdGVDbG9jayA9IHVzZUR5bmFtaWMoKCkgPT4gY291bnRFdmVudHMoZXZlcnlTZWNvbmQoKSkpO1xuICAgICAgY29uc3QgY2xvY2tBcnJheSA9IHVzZVZhcihbXSk7XG5cbiAgICAgIGlmIChjbGljaykge1xuICAgICAgICBjbG9ja0FycmF5LmN1cnJlbnQucHVzaChjcmVhdGVDbG9jaygpKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbnVtcyA9IGNsb2NrQXJyYXkuY3VycmVudC5tYXAoY2xvY2sgPT4gY2xvY2sudXBkYXRlKCkpO1xuICAgICAgc2hvd1N0cmluZyhudW1zLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmVjb3JkIHBsYXllciBzcGluIHVwL2Rvd24sIGhvbGQgbW91c2UgZG93biBhbmQgcmVsZWFzZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgcGNtID0gbG9hZEF1ZGlvQXNBcnJheSgnYW1lbl9icmVhay5tcDMnKTtcbiAgICAgIHNob3dTdHJpbmcocGNtLmxlbmd0aCA+IDEgPyAnbG9hZGVkIGF1ZGlvJyA6ICdsb2FkaW5nIGF1ZGlvLi4uJyk7XG4gICAgICBhdWRpb0RyaXZlcigoYXVkaW9UaW1lLCBhZHZhbmNlRnJhbWVFdnRzLCBzYW1wbGVSYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldFNwZWVkID0gbW91c2VEb3duKCkgPyBzYW1wbGVSYXRlIDogMDtcbiAgICAgICAgY29uc3Qgc3BlZWQgPSBleHBGb2xsb3codGFyZ2V0U3BlZWQsIDMsIGF1ZGlvVGltZSwgMCk7XG4gICAgICAgIGNvbnN0IHBvcyA9IE1hdGguZmxvb3IoaW50ZWdyYWwoKCkgPT4gc3BlZWQsIGF1ZGlvVGltZSkpO1xuICAgICAgICByZXR1cm4gcGNtW3BvcyAlIHBjbS5sZW5ndGhdOyAvLyBtb2R1bG8gc28gYXMgdG8gbG9vcFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY2lyY2xlIGZvbGxvd3MgbW91c2UnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHJlZENpcmNsZShtb3VzZVBvc2l0aW9uKCkpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NpcmNsZSBmb2xsb3dzIG1vdXNlIGF0IGxpbWl0ZWQgc3BlZWQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBhbmltYXRpb25UaW1lKCk7XG4gICAgICBjb25zdCBtcG9zID0gbW91c2VQb3NpdGlvbigpO1xuICAgICAgcmVkQ2lyY2xlKGZvbGxvd0F0U3BlZWQyZChtcG9zLCAzMDAsIHRpbWUsIG1wb3MpKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjaXJjbGUgbW92ZXMgaGFsZndheSB0byBtb3VzZSB3aXRoIGVhY2ggY2xpY2snLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IG1pZHBvaW50ID0gKGEsIGIpID0+ICh7eDogMC41KihhLngrYi54KSwgeTogMC41KihhLnkrYi55KX0pO1xuICAgICAgY29uc3QgbXBvcyA9IG1vdXNlUG9zaXRpb24oKTtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjcG9zID0gdXNlUmVkdWNlcihjbGlja0V2dHMsIChhY3Rpb24sIHByZXZTdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gYWN0aW9uID8gbWlkcG9pbnQocHJldlN0YXRlLCBtcG9zKSA6IHByZXZTdGF0ZTtcbiAgICAgIH0sIHt4OiAwLCB5OiAwfSk7XG4gICAgICByZWRDaXJjbGUoY3Bvcyk7XG4gICAgfVxuICB9LFxuXVxuIiwiaW1wb3J0IHsgY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQgfSBmcm9tICcuL3Jpdic7XG5pbXBvcnQgcHJvZ3JhbXMgZnJvbSAnLi9wcm9ncmFtcyc7XG5cbmNvbnN0IHByb2dyYW1MaXN0RWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmFtLWxpc3QnKTtcbmNvbnN0IHByb2dyYW1Tb3VyY2VFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyYW0tc291cmNlJyk7XG5cbmxldCBjdXJyZW50Q29udGV4dDtcblxuLy8gTk9URTogVGhpcyBpcyBhIGhhY2sgYnV0IHdvcmtzIGZvciBub3dcbmNvbnN0IGZpeEluZGVudCA9IChjb2RlKSA9PiB7XG4gIHJldHVybiBjb2RlLnNwbGl0KCdcXG4nKS5tYXAoKGxpbmUsIGlkeCkgPT4gKGlkeCA9PT0gMCkgPyBsaW5lIDogbGluZS5zdWJzdHIoMikpLmpvaW4oJ1xcbicpO1xufVxuXG5jb25zdCBzdGFydFByb2dyYW0gPSAocHJvZ3JhbSkgPT4ge1xuICBpZiAoY3VycmVudENvbnRleHQpIHtcbiAgICBjdXJyZW50Q29udGV4dC50ZXJtaW5hdGUoKTtcbiAgICBjdXJyZW50Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb2dyYW1Tb3VyY2VFbGVtLnRleHRDb250ZW50ID0gZml4SW5kZW50KHByb2dyYW0ubWFpbi50b1N0cmluZygpKTsgLy8gaGFja3kgYnV0IHdvcmtzIGZvciBub3dcbiAgY3VycmVudENvbnRleHQgPSBjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dChwcm9ncmFtLm1haW4pO1xuICBjdXJyZW50Q29udGV4dC51cGRhdGUoKTsgLy8gZG8gaW5pdGlhbCB1cGRhdGUuIGFueSBmdXJ0aGVyIHVwZGF0ZXMgd2lsbCBiZSBhc3luY1xufVxuXG5mb3IgKGNvbnN0IHByb2cgb2YgcHJvZ3JhbXMpIHtcbiAgY29uc3QgYW5jaG9yRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgYW5jaG9yRWxlbS50ZXh0Q29udGVudCA9IHByb2cubmFtZTtcbiAgYW5jaG9yRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAoKCkgPT4ge1xuICAgIGFuY2hvckVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7IC8vIHN0YXJ0IHByb2dyYW0gd2l0aCBkZWxheSBzbyBpdCBkb2Vzbid0IGdldCB0aGlzIGNsaWNrIGV2ZW50XG4gICAgICAgIHN0YXJ0UHJvZ3JhbShwcm9nKTtcbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICB9KSgpO1xuXG4gIGNvbnN0IGl0ZW1FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgaXRlbUVsZW0uYXBwZW5kQ2hpbGQoYW5jaG9yRWxlbSk7XG5cbiAgcHJvZ3JhbUxpc3RFbGVtLmFwcGVuZENoaWxkKGl0ZW1FbGVtKTtcbn1cblxuc3RhcnRQcm9ncmFtKHByb2dyYW1zWzBdKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")}]);