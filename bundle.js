!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=1)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createNoInOutExecutionContext\", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useVar\", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useRequestUpdate\", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useInitialize\", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventEmitter\", function() { return useEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useEventReceiver\", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useDynamic\", function() { return useDynamic; });\nlet currentUpdateFrame = null;\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push a new update frame onto the update stack for this context\n    const newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn't get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error('Did not reach all hook records in update');\n    } // Pop the top frame from the update stack\n\n\n    const poppedFrame = currentUpdateFrame;\n\n    if (!poppedFrame) {\n      throw new Error('Cannot pop update frame because current is null');\n    }\n\n    if (poppedFrame.executionContext !== this) {\n      throw new Error(\"Popped frame from update stack but context did not match\");\n    }\n\n    currentUpdateFrame = poppedFrame.previousFrame;\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // NOTE: Might we want to sanity check that this context isn't anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error('Expecting to create new hook record in chain, but already present');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error('Expecting to find hook record in chain, but not present');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It's currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error('Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can't we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it's important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\nfunction useEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const stream = {\n      count: 0,\n      // how many events have occurred on this stream\n      latestValue: undefined\n    };\n    record.data = {\n      stream,\n      emit: value => {\n        // This function closes over the stream variable\n        stream.latestValue = value;\n        stream.count++;\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\nfunction useEventReceiver(stream) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      stream,\n      // the stream we are receiving on\n      lastSeenNumber: stream.count\n    };\n  } // TODO: We could support this, just need to consider details.\n\n\n  if (stream !== record.data.stream) {\n    throw new Error('Event receiver found that stream object changed identity');\n  }\n\n  let boxedEvent;\n\n  if (record.data.lastSeenNumber === stream.count) {// There have not been any new events on the stream\n  } else if (record.data.lastSeenNumber === stream.count - 1) {\n    // There has been exactly one new event on the stream that we haven't seen yet.\n    boxedEvent = {\n      value: stream.latestValue\n    };\n    record.data.lastSeenNumber++;\n  } else {\n    throw new Error('Event receiver got too many events or missed some');\n  }\n\n  ctx._endHook();\n\n  return boxedEvent;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new \"version\" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create \"factory\" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY2hpbm9vay5qcz9jMTliIl0sIm5hbWVzIjpbImN1cnJlbnRVcGRhdGVGcmFtZSIsIkV4ZWN1dGlvbkNvbnRleHQiLCJjb25zdHJ1Y3RvciIsInN0cmVhbUZ1bmMiLCJvblJlcXVlc3RVcGRhdGUiLCJhZnRlclRlcm1pbmF0ZSIsImhvb2tSZWNvcmRDaGFpbiIsIm5leHQiLCJyZWNvcmRDdXJzb3IiLCJ1cGRhdGVDb3VudCIsInVwZGF0ZSIsIm5ld0ZyYW1lIiwiZXhlY3V0aW9uQ29udGV4dCIsInByZXZpb3VzRnJhbWUiLCJyZXR2YWwiLCJhcHBseSIsImFyZ3VtZW50cyIsIkVycm9yIiwicG9wcGVkRnJhbWUiLCJ0ZXJtaW5hdGUiLCJjIiwiY2xlYW51cCIsIl9iZWdpbkhvb2siLCJkYXRhIiwidW5kZWZpbmVkIiwiX2VuZEhvb2siLCJfcmVxdWVzdFVwZGF0ZSIsIl9zZXRTdHJlYW1GdW5jIiwibmV3U3RyZWFtRnVuYyIsImNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IiwiY3R4IiwiZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0IiwidXNlVmFyIiwiaW5pdFZhbCIsInJlY29yZCIsImN1cnJlbnQiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwicmVxdWVzdFVwZGF0ZSIsInVzZUluaXRpYWxpemUiLCJpbml0aWFsaXplciIsInVzZUV2ZW50RW1pdHRlciIsInN0cmVhbSIsImNvdW50IiwibGF0ZXN0VmFsdWUiLCJlbWl0IiwidmFsdWUiLCJ1c2VFdmVudFJlY2VpdmVyIiwibGFzdFNlZW5OdW1iZXIiLCJib3hlZEV2ZW50IiwidXNlRHluYW1pYyIsIm9ydSIsImFjdGl2ZUNvbnRleHRzIiwiU2V0IiwiY3JlYXRlQ29udGV4dCIsImRlbGV0ZSIsImFkZCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBQUlBLGtCQUFrQixHQUFHLElBQXpCOztBQUVBLE1B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blxuY2xhc3MgRXhlY3V0aW9uQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSwgYWZ0ZXJUZXJtaW5hdGUpIHtcbiAgICB0aGlzLnN0cmVhbUZ1bmMgPSBzdHJlYW1GdW5jO1xuICAgIHRoaXMub25SZXF1ZXN0VXBkYXRlID0gb25SZXF1ZXN0VXBkYXRlO1xuICAgIHRoaXMuYWZ0ZXJUZXJtaW5hdGUgPSBhZnRlclRlcm1pbmF0ZTtcblxuICAgIHRoaXMuaG9va1JlY29yZENoYWluID0ge25leHQ6IG51bGx9OyAvLyBkdW1teVxuICAgIHRoaXMucmVjb3JkQ3Vyc29yID0gbnVsbDsgLy8gb25seSBzZXQgd2hlbiB0aGlzIGNvbnRleHQgaXMgdXBkYXRpbmdcbiAgICB0aGlzLnVwZGF0ZUNvdW50ID0gMDtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICAvLyBQdXNoIGEgbmV3IHVwZGF0ZSBmcmFtZSBvbnRvIHRoZSB1cGRhdGUgc3RhY2sgZm9yIHRoaXMgY29udGV4dFxuICAgIGNvbnN0IG5ld0ZyYW1lID0ge1xuICAgICAgZXhlY3V0aW9uQ29udGV4dDogdGhpcyxcbiAgICAgIHByZXZpb3VzRnJhbWU6IGN1cnJlbnRVcGRhdGVGcmFtZSxcbiAgICB9O1xuICAgIGN1cnJlbnRVcGRhdGVGcmFtZSA9IG5ld0ZyYW1lO1xuXG4gICAgLy8gTW92ZSBob29rIHJlY29yZCBjdXJzb3IgdG8gc3RhcnQgb2YgY2hhaW5cbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IHRoaXMuaG9va1JlY29yZENoYWluO1xuXG4gICAgY29uc3QgcmV0dmFsID0gdGhpcy5zdHJlYW1GdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBudWxsLCBvdGhlcndpc2UgdGhlcmUgYXJlIGhvb2sgcmVjb3JkcyB3ZSBkaWRuJ3QgZ2V0IHRvLCBhbmQgc29tZXRoaW5nIGlzIGFtaXNzXG4gICAgaWYgKHRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRGlkIG5vdCByZWFjaCBhbGwgaG9vayByZWNvcmRzIGluIHVwZGF0ZScpO1xuICAgIH1cblxuICAgIC8vIFBvcCB0aGUgdG9wIGZyYW1lIGZyb20gdGhlIHVwZGF0ZSBzdGFja1xuICAgIGNvbnN0IHBvcHBlZEZyYW1lID0gY3VycmVudFVwZGF0ZUZyYW1lO1xuICAgIGlmICghcG9wcGVkRnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBvcCB1cGRhdGUgZnJhbWUgYmVjYXVzZSBjdXJyZW50IGlzIG51bGwnKTtcbiAgICB9XG4gICAgaWYgKHBvcHBlZEZyYW1lLmV4ZWN1dGlvbkNvbnRleHQgIT09IHRoaXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvcHBlZCBmcmFtZSBmcm9tIHVwZGF0ZSBzdGFjayBidXQgY29udGV4dCBkaWQgbm90IG1hdGNoXCIpO1xuICAgIH1cbiAgICBjdXJyZW50VXBkYXRlRnJhbWUgPSBwb3BwZWRGcmFtZS5wcmV2aW91c0ZyYW1lO1xuXG4gICAgdGhpcy51cGRhdGVDb3VudCsrO1xuXG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICAvLyBOT1RFOiBNaWdodCB3ZSB3YW50IHRvIHNhbml0eSBjaGVjayB0aGF0IHRoaXMgY29udGV4dCBpc24ndCBhbnl3aGVyZSBpbiB0aGUgY3VycmVudCB1cGRhdGUgc3RhY2s/XG5cbiAgICAvLyBDYWxsIGFueSBjbGVhbnVwIGZ1bmN0aW9ucyBzZXQgYnkgaG9va3NcbiAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIHdvcnJ5IGFib3V0IG9yZGVyP1xuICAgIGZvciAobGV0IGMgPSB0aGlzLmhvb2tSZWNvcmRDaGFpbi5uZXh0OyBjOyBjID0gYy5uZXh0KSB7XG4gICAgICBpZiAoYy5jbGVhbnVwKSB7XG4gICAgICAgIGMuY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmFmdGVyVGVybWluYXRlKSB7XG4gICAgICB0aGlzLmFmdGVyVGVybWluYXRlKCk7XG4gICAgfVxuICB9XG5cbiAgX2JlZ2luSG9vaygpIHtcbiAgICBpZiAodGhpcy51cGRhdGVDb3VudCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucmVjb3JkQ3Vyc29yLm5leHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgdG8gY3JlYXRlIG5ldyBob29rIHJlY29yZCBpbiBjaGFpbiwgYnV0IGFscmVhZHkgcHJlc2VudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ3JlYXRlIG5ldyByZWNvcmRcbiAgICAgIHRoaXMucmVjb3JkQ3Vyc29yLm5leHQgPSB7XG4gICAgICAgIGRhdGE6IHVuZGVmaW5lZCxcbiAgICAgICAgY2xlYW51cDogdW5kZWZpbmVkLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5yZWNvcmRDdXJzb3IubmV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RpbmcgdG8gZmluZCBob29rIHJlY29yZCBpbiBjaGFpbiwgYnV0IG5vdCBwcmVzZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVjb3JkQ3Vyc29yLm5leHQ7XG4gIH1cblxuICBfZW5kSG9vaygpIHtcbiAgICB0aGlzLnJlY29yZEN1cnNvciA9IHRoaXMucmVjb3JkQ3Vyc29yLm5leHQ7IC8vIG1vdmUgY3Vyc29yIGZvcndhcmRcbiAgfVxuXG4gIF9yZXF1ZXN0VXBkYXRlKCkge1xuICAgIHRoaXMub25SZXF1ZXN0VXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBvbmx5IHNhZmUgdG8gZG8gaWYgdGhlIHJlcGxhY2VtZW50IGZ1bmN0aW9uIGNhbGxzIHRoZSBzYW1lIGhvb2tzLCBoYXMgc2FtZSBzaWduYXR1cmUsIGV0Yy5cbiAgICogSXQncyBjdXJyZW50bHkgdXNlZCB0byBwcm92aWRlIGEgZnVuY3Rpb24gdGhhdCBpcyBsZXhpY2FsbHkgdGhlIHNhbWUgYnV0IGJvdW5kIHRvIGRpZmZlcmVudCBvdXRlci1zY29wZVxuICAgKiB2YXJpYWJsZXMuXG4gICAqL1xuICBfc2V0U3RyZWFtRnVuYyhuZXdTdHJlYW1GdW5jKSB7XG4gICAgdGhpcy5zdHJlYW1GdW5jID0gbmV3U3RyZWFtRnVuYztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQoc3RyZWFtRnVuYykge1xuICBjb25zdCBvblJlcXVlc3RVcGRhdGUgPSAoKSA9PiB7IGN0eC51cGRhdGUoKSB9O1xuICBjb25zdCBjdHggPSBuZXcgRXhlY3V0aW9uQ29udGV4dChzdHJlYW1GdW5jLCBvblJlcXVlc3RVcGRhdGUpXG4gIHJldHVybiBjdHg7XG59XG5cbi8qKlxuICogVGhpcyBpcyB1c2VkIGJ5IGhvb2tzIHRvIGdldCB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGNvbnRleHQgKGFmdGVyIHZlcmlmeWluZyBpdCBpcyBzZXQpXG4gKi9cbmZ1bmN0aW9uIGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpIHtcbiAgaWYgKCFjdXJyZW50VXBkYXRlRnJhbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgY3VycmVudGx5IHVwZGF0aW5nIGV4ZWN1dGlvbiBjb250ZXh0IGJlY2F1c2UgdXBkYXRlIHN0YWNrIGlzIGVtcHR5LiBXYXMgYSBob29rIGNhbGxlZCBvdXRzaWRlIG9mIGFuIGV4ZWN1dGlvbiBjb250ZXh0IHVwZGF0ZT8nKTtcbiAgfVxuICByZXR1cm4gY3VycmVudFVwZGF0ZUZyYW1lLmV4ZWN1dGlvbkNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VWYXIoaW5pdFZhbCkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBDcmVhdGUgdmFsdWUgYm94IGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7Y3VycmVudDogaW5pdFZhbH07XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGE7XG59XG5cbi8qKlxuICogV2h5IGRvIHdlIG5lZWQgYSBob29rPyBXaHkgY2FuJ3Qgd2UganVzdCBjYWxsIGN0eC5yZXF1ZXN0VXBkYXRlKCk/IEJlY2F1c2UgdGhlIHJlcXVlc3RVcGRhdGVcbiAqIGZ1bmN0aW9uIHRoYXQgd2UgcmV0dXJuIHdpbGwgb2Z0ZW4gYmUgY2FsbGVkIHdpdGhvdXQgdGhlcmUgYmVpbmcgYW55IHVwZGF0aW5nIGV4ZWN1dGlvbiBjb250ZXh0XG4gKiAoZS5nLiBmcm9tIGFuIGV2ZW50IGhhbmRsZXIpLiBTbyBpdCBoYXMgdG8gYmUgYm91bmQgdG8gdGhlIGNvcnJlY3QgY29udGV4dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlcXVlc3RVcGRhdGUoKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIENyZWF0ZSBjYWxsYmFjayBpZiBuZWNlc3NhcnkuIFdlIHN0b3JlIGl0IHNvIHRoYXQgd2UgYWxyZWFkeSByZXR1cm4gdGhlIHNhbWUgb25lLlxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgcmVjb3JkLmRhdGEgPSB7cmVxdWVzdFVwZGF0ZTogKCkgPT4ge1xuICAgICAgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7IC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgdXNlIGN0eCBmcm9tIGNsb3N1cmUsIG5vdCBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKSBoZXJlXG4gICAgfX07XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmVjb3JkLmRhdGEucmVxdWVzdFVwZGF0ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUluaXRpYWxpemUoaW5pdGlhbGl6ZXIpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIC8vIGRhdGEgYmVpbmcgdW5kZWZpbmVkIG1lYW5zIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGxcblxuICAgIHJlY29yZC5jbGVhbnVwID0gaW5pdGlhbGl6ZXIoKTtcblxuICAgIHJlY29yZC5kYXRhID0ge307IC8vIG5vIGRhdGEgdG8gc3RvcmUgeWV0LCBqdXN0IG5lZWRzIHRvIGJlIHRydXRoeSB0byBpbmRpY2F0ZSB0aGF0IGluaXRpYWxpemF0aW9uIHJhblxuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFdmVudEVtaXR0ZXIoKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB7XG4gICAgICBjb3VudDogMCwgLy8gaG93IG1hbnkgZXZlbnRzIGhhdmUgb2NjdXJyZWQgb24gdGhpcyBzdHJlYW1cbiAgICAgIGxhdGVzdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgfVxuXG4gICAgcmVjb3JkLmRhdGEgPSB7XG4gICAgICBzdHJlYW0sXG4gICAgICBlbWl0OiAodmFsdWUpID0+IHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjbG9zZXMgb3ZlciB0aGUgc3RyZWFtIHZhcmlhYmxlXG4gICAgICAgIHN0cmVhbS5sYXRlc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBzdHJlYW0uY291bnQrKztcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiBbcmVjb3JkLmRhdGEuc3RyZWFtLCByZWNvcmQuZGF0YS5lbWl0XTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV2ZW50UmVjZWl2ZXIoc3RyZWFtKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIEluaXRpYWxpemUgcmVjb3JkIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtcbiAgICAgIHN0cmVhbSwgLy8gdGhlIHN0cmVhbSB3ZSBhcmUgcmVjZWl2aW5nIG9uXG4gICAgICBsYXN0U2Vlbk51bWJlcjogc3RyZWFtLmNvdW50LFxuICAgIH07XG4gIH1cblxuICAvLyBUT0RPOiBXZSBjb3VsZCBzdXBwb3J0IHRoaXMsIGp1c3QgbmVlZCB0byBjb25zaWRlciBkZXRhaWxzLlxuICBpZiAoc3RyZWFtICE9PSByZWNvcmQuZGF0YS5zdHJlYW0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50IHJlY2VpdmVyIGZvdW5kIHRoYXQgc3RyZWFtIG9iamVjdCBjaGFuZ2VkIGlkZW50aXR5Jyk7XG4gIH1cblxuICBsZXQgYm94ZWRFdmVudDtcblxuICBpZiAocmVjb3JkLmRhdGEubGFzdFNlZW5OdW1iZXIgPT09IHN0cmVhbS5jb3VudCkge1xuICAgIC8vIFRoZXJlIGhhdmUgbm90IGJlZW4gYW55IG5ldyBldmVudHMgb24gdGhlIHN0cmVhbVxuICB9IGVsc2UgaWYgKHJlY29yZC5kYXRhLmxhc3RTZWVuTnVtYmVyID09PSAoc3RyZWFtLmNvdW50IC0gMSkpIHtcbiAgICAvLyBUaGVyZSBoYXMgYmVlbiBleGFjdGx5IG9uZSBuZXcgZXZlbnQgb24gdGhlIHN0cmVhbSB0aGF0IHdlIGhhdmVuJ3Qgc2VlbiB5ZXQuXG4gICAgYm94ZWRFdmVudCA9IHt2YWx1ZTogc3RyZWFtLmxhdGVzdFZhbHVlfTtcbiAgICByZWNvcmQuZGF0YS5sYXN0U2Vlbk51bWJlcisrO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgcmVjZWl2ZXIgZ290IHRvbyBtYW55IGV2ZW50cyBvciBtaXNzZWQgc29tZScpO1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIGJveGVkRXZlbnQ7XG59XG5cbi8qKlxuICogVGhlIHN0cmVhbUZ1bmMgYXJndW1lbnQgbWF5IGNoYW5nZSwgYnV0IGl0IHNob3VsZCBvbmx5IGNoYW5nZSB0byBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHNhZmVseVxuICogc3dhcHBlZCBpbiAoaS5lLiBvbmUgdGhhdCBjYWxscyB0aGUgc2FtZSBob29rcywgZXRjLikuIEEgY29tbW9uIGNhc2UgaXMgdGhhdCBzdHJlYW1GdW5jIGlzIGFcbiAqIGNsb3N1cmUgdGhhdCByZWZlcmVuY2VzIHNvbWUgb3V0ZXIgc2NvcGUgdmFyaWFibGVzLCBhbmQgd2hlbiB0aG9zZSBjaGFuZ2UsIGEgbmV3IFwidmVyc2lvblwiIG9mXG4gKiB0aGUgZnVuY3Rpb24gaXMgY3JlYXRlZCAobGV4aWNhbGx5IHRoZSBzYW1lLCBidXQgY2xvc2luZyBvdmVyIGEgZGlmZmVyZW50IHNjb3BlKS5cbiAqXG4gKiBvblJlcXVlc3RVcGRhdGUgaXMgY3VycmVudGx5IG9ubHkgcmVhZCBvbiB0aGUgZmlyc3QgY2FsbCwgc28gY2hhbmdlcyB0byBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRHluYW1pYyhzdHJlYW1GdW5jLCBvblJlcXVlc3RVcGRhdGUpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcblxuICAgIC8vIElmIG5vIG9uUmVxdWVzdFVwZGF0ZSBpcyBwcm92aWRlZCwgZGVmYXVsdCB0byByZXF1ZXN0aW5nIHVwZGF0ZSBvbiB0aGUgY3VycmVudCBjb250ZXh0XG4gICAgY29uc3Qgb3J1ID0gb25SZXF1ZXN0VXBkYXRlIHx8ICgoKSA9PiB7XG4gICAgICBjdHguX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9KTtcblxuICAgIC8vIFRyYWNrIEV4ZWN1dGlvbkNvbnRleHRzIGNyZWF0ZWQgKGFuZCBub3QgeWV0IHRlcm1pbmF0ZWQpIHNvIHdlIGNhbiB0ZXJtaW5hdGUgdGhlbSB1cG9uIGNsZWFudXBcbiAgICBkYXRhLmFjdGl2ZUNvbnRleHRzID0gbmV3IFNldCgpO1xuXG4gICAgLy8gQ3JlYXRlIFwiZmFjdG9yeVwiIGZ1bmN0aW9uIHRvIGluc3RhbnRpYXRlIG5ldyBjb250ZXh0c1xuICAgIGRhdGEuY3JlYXRlQ29udGV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KGRhdGEuc3RyZWFtRnVuYywgb3J1LCAoKSA9PiB7IGRhdGEuYWN0aXZlQ29udGV4dHMuZGVsZXRlKGN0eCk7IH0pO1xuICAgICAgZGF0YS5hY3RpdmVDb250ZXh0cy5hZGQoY3R4KTtcbiAgICAgIHJldHVybiBjdHg7XG4gICAgfTtcblxuICAgIHJlY29yZC5kYXRhID0gZGF0YTtcbiAgICByZWNvcmQuY2xlYW51cCA9ICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgY3R4IG9mIGRhdGEuYWN0aXZlQ29udGV4dHMpIHtcbiAgICAgICAgY3R4LnRlcm1pbmF0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIHN0cmVhbSBmdW5jdGlvbiBpbiByZWNvcmQgYW5kIGFsbCBhY3RpdmUgY29udGV4dHMuXG4gIHJlY29yZC5kYXRhLnN0cmVhbUZ1bmMgPSBzdHJlYW1GdW5jO1xuICBmb3IgKGNvbnN0IGN0eCBvZiByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0cykge1xuICAgIGN0eC5fc2V0U3RyZWFtRnVuYyhzdHJlYW1GdW5jKTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiByZWNvcmQuZGF0YS5jcmVhdGVDb250ZXh0O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/chinook.js\nvar chinook = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useEventEmitter,\n  useEventReceiver,\n  useDynamic\n} = __webpack_require__(0);\n\nfunction showString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'border: 1px solid red; color: black; font-size: 24px; padding: 5px; margin-top: 20px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = 'showString: ' + (v === undefined ? '(undefined)' : v.toString());\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvts, emitClick] = useEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvts;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction random(repickEvts) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvts);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  const [advanceFrameEvts, emitAdvanceFrame] = useEventEmitter();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        emitAdvanceFrame({});\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvts, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvts);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvts, emitTick] = useEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\n\nfunction loadAudioAsArray(url) {\n  const requestUpdate = useRequestUpdate();\n  const pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(() => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    let cleanedUp = false;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = () => {\n      const audioData = request.response;\n      audioCtx.decodeAudioData(audioData, buffer => {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return () => {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nfunction integral(integrandFunc, time, initialValue = 0) {\n  const accum = useVar(initialValue);\n  const prevTime = useVar(time);\n  const integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\n\nfunction smoothFollow(targetValue, time, speedConstant) {\n  return integral(currentValue => speedConstant * (targetValue - currentValue), time);\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    showString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    showString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    showString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    showString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvts, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    showString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    showString(nums.join(' '));\n  }\n}, {\n  name: 'record player spin up/down, hold mouse down and release',\n  main: () => {\n    const pcm = loadAudioAsArray('amen_break.mp3');\n    showString(pcm.length > 1 ? 'loaded audio' : 'loading audio...');\n    audioDriver((audioTime, advanceFrameEvts, sampleRate) => {\n      const targetSpeed = mouseDown() ? sampleRate : 0;\n      const speed = smoothFollow(targetSpeed, audioTime, 3);\n      const pos = Math.floor(integral(() => speed, audioTime));\n      return pcm[pos % pcm.length]; // modulo so as to loop\n    });\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(chinook[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUV2ZW50RW1pdHRlciIsInVzZUV2ZW50UmVjZWl2ZXIiLCJ1c2VEeW5hbWljIiwicmVxdWlyZSIsInNob3dTdHJpbmciLCJ2IiwiZWxlbSIsImN1cnJlbnQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwidW5kZWZpbmVkIiwidG9TdHJpbmciLCJhbmltYXRpb25UaW1lIiwicmVxdWVzdFVwZGF0ZSIsInRpbWUiLCJyZXFJZCIsIm9uRnJhbWUiLCJ0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbkZyYW1lRXZ0cyIsImZyYW1lRXZ0cyIsImVtaXRGcmFtZSIsImNvdW50RXZlbnRzIiwiZXZ0cyIsImNvdW50IiwiZXZlbnQiLCJtb3VzZUNsaWNrRXZ0cyIsImNsaWNrRXZ0cyIsImVtaXRDbGljayIsIm9uTW91c2VEb3duIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJtb3VzZURvd24iLCJpc0Rvd24iLCJvbk1vdXNlVXAiLCJyYW5kb20iLCJyZXBpY2tFdnRzIiwidmFsIiwiTWF0aCIsInJlcGljayIsImF1ZGlvRHJpdmVyIiwiZ2VuZXJhdG9yIiwiY3JlYXRlR2VuZXJhdG9yIiwiZ2VuZXJhdG9yQ3R4IiwiZnJhbWVDb3VudCIsInNhbXBsZVJhdGUiLCJhZHZhbmNlRnJhbWVFdnRzIiwiZW1pdEFkdmFuY2VGcmFtZSIsIkJVRkZFUl9TSVpFIiwiYXVkaW9Db250ZXh0Iiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwic2NyaXB0Tm9kZSIsImNyZWF0ZVNjcmlwdFByb2Nlc3NvciIsIm9uYXVkaW9wcm9jZXNzIiwiZSIsImJ1ZmZlciIsIm91dHB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaSIsImxlbmd0aCIsInVwZGF0ZSIsImNvbm5lY3QiLCJkZXN0aW5hdGlvbiIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsInNhbXBsZVVwb24iLCJ0b1NhbXBsZSIsInVwb25FdnRzIiwiaW5pdGlhbFZhbHVlIiwiaGVsZCIsInVwb24iLCJldmVyeVNlY29uZCIsInRpY2tFdnRzIiwiZW1pdFRpY2siLCJvbkludGVydmFsIiwidGltZXJJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImxvYWRBdWRpb0FzQXJyYXkiLCJ1cmwiLCJwY20iLCJhdWRpb0N0eCIsImNsZWFuZWRVcCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJhdWRpb0RhdGEiLCJyZXNwb25zZSIsImRlY29kZUF1ZGlvRGF0YSIsInNlbmQiLCJhYm9ydCIsImNvbnNvbGVMb2ciLCJjb25zb2xlIiwibG9nIiwiaW50ZWdyYWwiLCJpbnRlZ3JhbmRGdW5jIiwiYWNjdW0iLCJwcmV2VGltZSIsImludGVncmFuZCIsInNtb290aEZvbGxvdyIsInRhcmdldFZhbHVlIiwic3BlZWRDb25zdGFudCIsImN1cnJlbnRWYWx1ZSIsIm5hbWUiLCJtYWluIiwidG9GaXhlZCIsIm1kIiwiYXVkaW9UaW1lIiwibm9pc2UiLCJsYXN0Q2xpY2tUaW1lIiwiSW5maW5pdHkiLCJkZWNheWluZ0dhaW4iLCJleHAiLCJjbGljayIsImNyZWF0ZUNvdW50ZXIiLCJhY3RpdmVDb3VudGVyIiwidGVybWluYXRlIiwiZGlzcGxheWVkQ291bnQiLCJjcmVhdGVDbG9jayIsImNsb2NrQXJyYXkiLCJwdXNoIiwibnVtcyIsIm1hcCIsImNsb2NrIiwiam9pbiIsInRhcmdldFNwZWVkIiwic3BlZWQiLCJwb3MiLCJmbG9vciIsInByb2dyYW1MaXN0RWxlbSIsImdldEVsZW1lbnRCeUlkIiwicHJvZ3JhbVNvdXJjZUVsZW0iLCJjdXJyZW50Q29udGV4dCIsImZpeEluZGVudCIsImNvZGUiLCJzcGxpdCIsImxpbmUiLCJpZHgiLCJzdWJzdHIiLCJzdGFydFByb2dyYW0iLCJwcm9ncmFtIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJwcm9nIiwicHJvZ3JhbXMiLCJhbmNob3JFbGVtIiwic2V0QXR0cmlidXRlIiwicHJldmVudERlZmF1bHQiLCJzZXRUaW1lb3V0IiwiaXRlbUVsZW0iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0EsTUFBTTtBQUFFQSxRQUFGO0FBQVVDLGtCQUFWO0FBQTRCQyxlQUE1QjtBQUEyQ0MsaUJBQTNDO0FBQTREQyxrQkFBNUQ7QUFBOEVDO0FBQTlFLElBQTZGQyxtQkFBTyxDQUFDLENBQUQsQ0FBMUc7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUI7QUFDckIsUUFBTUMsSUFBSSxHQUFHVCxNQUFNLENBQUMsSUFBRCxDQUFuQjtBQUVBRSxlQUFhLENBQUMsTUFBTTtBQUNsQk8sUUFBSSxDQUFDQyxPQUFMLEdBQWVDLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFmO0FBQ0FILFFBQUksQ0FBQ0MsT0FBTCxDQUFhRyxLQUFiLENBQW1CQyxPQUFuQixHQUE2QixzRkFBN0I7QUFDQUwsUUFBSSxDQUFDQyxPQUFMLENBQWFLLFdBQWIsR0FBMkIsYUFBM0I7QUFDQUosWUFBUSxDQUFDSyxJQUFULENBQWNDLFdBQWQsQ0FBMEJSLElBQUksQ0FBQ0MsT0FBL0I7QUFFQSxXQUFPLE1BQU07QUFBRTtBQUNiQyxjQUFRLENBQUNLLElBQVQsQ0FBY0UsV0FBZCxDQUEwQlQsSUFBSSxDQUFDQyxPQUEvQjtBQUNELEtBRkQ7QUFHRCxHQVRZLENBQWI7QUFXQUQsTUFBSSxDQUFDQyxPQUFMLENBQWFLLFdBQWIs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QUNBd0osVUFBUSxDQUFDbkosV0FBVCxDQUFxQitJLFVBQXJCO0FBRUFmLGlCQUFlLENBQUNoSSxXQUFoQixDQUE0Qm1KLFFBQTVCO0FBQ0Q7O0FBRURULFlBQVksQ0FBQ0ksUUFBUSxDQUFDLENBQUQsQ0FBVCxDQUFaIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOT1RFOiBVc2luZyByZXF1aXJlIGluc3RlYWQgb2YgaW1wb3J0IGhlcmUgbWFrZXMgdGhlIHRoaW5nIHdoZXJlIHdlIHByaW50IHByb2dyYW0gdGV4dCB3b3JrIGJldHRlci5cbmNvbnN0IHsgdXNlVmFyLCB1c2VSZXF1ZXN0VXBkYXRlLCB1c2VJbml0aWFsaXplLCB1c2VFdmVudEVtaXR0ZXIsIHVzZUV2ZW50UmVjZWl2ZXIsIHVzZUR5bmFtaWMgfSA9IHJlcXVpcmUoJy4vY2hpbm9vaycpO1xuXG5mdW5jdGlvbiBzaG93U3RyaW5nKHYpIHtcbiAgY29uc3QgZWxlbSA9IHVzZVZhcihudWxsKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBlbGVtLmN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtLmN1cnJlbnQuc3R5bGUuY3NzVGV4dCA9ICdib3JkZXI6IDFweCBzb2xpZCByZWQ7IGNvbG9yOiBibGFjazsgZm9udC1zaXplOiAyNHB4OyBwYWRkaW5nOiA1cHg7IG1hcmdpbi10b3A6IDIwcHgnO1xuICAgIGVsZW0uY3VycmVudC50ZXh0Q29udGVudCA9ICcodW5kZWZpbmVkKSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtLmN1cnJlbnQpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbGVtLmN1cnJlbnQpO1xuICAgIH1cbiAgfSlcblxuICBlbGVtLmN1cnJlbnQudGV4dENvbnRlbnQgPSAnc2hvd1N0cmluZzogJyArICgodiA9PT0gdW5kZWZpbmVkKSA/ICcodW5kZWZpbmVkKScgOiB2LnRvU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBhbmltYXRpb25UaW1lKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCB0aW1lID0gdXNlVmFyKCk7XG4gIGNvbnN0IHJlcUlkID0gdXNlVmFyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICB0aW1lLmN1cnJlbnQgPSAwLjAwMSp0O1xuICAgICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTsgLy8gcmVxdWVzdCBhbm90aGVyXG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZXFJZC5jdXJyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aW1lLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvbkZyYW1lRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2ZyYW1lRXZ0cywgZW1pdEZyYW1lXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uRnJhbWUgPSAodCkgPT4ge1xuICAgICAgZW1pdEZyYW1lKCk7XG4gICAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpOyAvLyByZXF1ZXN0IGFub3RoZXJcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcUlkLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGZyYW1lRXZ0cztcbn1cblxuZnVuY3Rpb24gY291bnRFdmVudHMoZXZ0cykge1xuICBjb25zdCBjb3VudCA9IHVzZVZhcigwKTtcbiAgY29uc3QgZXZlbnQgPSB1c2VFdmVudFJlY2VpdmVyKGV2dHMpO1xuXG4gIGlmIChldmVudCkge1xuICAgIGNvdW50LmN1cnJlbnQrKztcbiAgfVxuXG4gIHJldHVybiBjb3VudC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBtb3VzZUNsaWNrRXZ0cygpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW2NsaWNrRXZ0cywgZW1pdENsaWNrXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgZW1pdENsaWNrKCk7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjbGlja0V2dHM7XG59XG5cbmZ1bmN0aW9uIG1vdXNlRG93bigpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgaXNEb3duID0gdXNlVmFyKGZhbHNlKTsgLy8gd2UgY2FuJ3QgcG9sbCBkb3duLW5lc3MsIHNvIHdlIGFzc3VtZSBpdCdzIGluaXRpYWxseSBub3QgZG93blxuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VEb3duID0gKCkgPT4ge1xuICAgICAgaXNEb3duLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBvbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBpc0Rvd24uY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZVVwKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VEb3duKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlzRG93bi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiByYW5kb20ocmVwaWNrRXZ0cykge1xuICBjb25zdCB2YWwgPSB1c2VWYXIoTWF0aC5yYW5kb20oKSk7XG4gIGNvbnN0IHJlcGljayA9IHVzZUV2ZW50UmVjZWl2ZXIocmVwaWNrRXZ0cyk7XG5cbiAgaWYgKHJlcGljaykge1xuICAgIHZhbC5jdXJyZW50ID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuXG4gIHJldHVybiB2YWwuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYXVkaW9Ecml2ZXIoZ2VuZXJhdG9yKSB7XG4gIGNvbnN0IGNyZWF0ZUdlbmVyYXRvciA9IHVzZUR5bmFtaWMoZ2VuZXJhdG9yKTtcbiAgY29uc3QgZ2VuZXJhdG9yQ3R4ID0gdXNlVmFyKCk7XG4gIGNvbnN0IGZyYW1lQ291bnQgPSB1c2VWYXIoMCk7XG4gIGNvbnN0IHNhbXBsZVJhdGUgPSB1c2VWYXIoKTtcbiAgY29uc3QgW2FkdmFuY2VGcmFtZUV2dHMsIGVtaXRBZHZhbmNlRnJhbWVdID0gdXNlRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgZ2VuZXJhdG9yQ3R4LmN1cnJlbnQgPSBjcmVhdGVHZW5lcmF0b3IoKTtcblxuICAgIGNvbnN0IEJVRkZFUl9TSVpFID0gMTAyNDtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBjb25zdCBzY3JpcHROb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZVNjcmlwdFByb2Nlc3NvcihCVUZGRVJfU0laRSwgMCwgMSk7IC8vIDAgaW5wdXQgY2hhbm5lbHMsIDEgb3V0cHV0IGNoYW5uZWxcbiAgICBzY3JpcHROb2RlLm9uYXVkaW9wcm9jZXNzID0gKGUpID0+IHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGUub3V0cHV0QnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW1pdEFkdmFuY2VGcmFtZSh7fSk7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCBhZHZhbmNlRnJhbWVFdnRzLCBzYW1wbGVSYXRlLmN1cnJlbnQpO1xuICAgICAgICBmcmFtZUNvdW50LmN1cnJlbnQrKztcbiAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdE5vZGUuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuXG4gICAgc2FtcGxlUmF0ZS5jdXJyZW50ID0gYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2NyaXB0Tm9kZS5kaXNjb25uZWN0KCk7XG4gICAgICBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICB9O1xuICB9KTtcblxuICAvKipcbiAgICogTW9zdCBvZiBvdXIgZ2VuZXJhdG9yIHVwZGF0aW5nIHdpbGwgaGFwcGVuIGluIHRoZSBhdWRpbyBwcm9jZXNzaW5nIGNhbGxiYWNrIGFib3ZlLlxuICAgKiBUaGlzIHVwZGF0ZSBoZXJlIGlzIGZvciB3aGVuIHRoZSBhdWRpb0RyaXZlciB1cGRhdGUgaXMgY2FsbGVkLCBlLmcuIHdoZW4gYW4gb3V0ZXIgc2NvcGVcbiAgICogcmVmZXJlbmNlIHRoYXQgdGhlIGdlbmVyYXRvciBkZXBlbmRzIG9uIGhhcyBjaGFuZ2VkLiBTbyB3ZSBtdXN0IHVwZGF0ZSB0aGUgZ2VuZXJhdG9yLFxuICAgKiBidXQgZG9uJ3QgbmVlZCBpdHMgb3V0cHV0IGFtcGxpdHVkZS5cbiAgICovXG4gIGdlbmVyYXRvckN0eC5jdXJyZW50LnVwZGF0ZShmcmFtZUNvdW50LmN1cnJlbnQvc2FtcGxlUmF0ZS5jdXJyZW50LCBhZHZhbmNlRnJhbWVFdnRzLCBzYW1wbGVSYXRlLmN1cnJlbnQpOyAvLyBOT1RFOiB3ZSBkaXNjYXJkIHJldHZhbFxufVxuXG5mdW5jdGlvbiBzYW1wbGVVcG9uKHRvU2FtcGxlLCB1cG9uRXZ0cywgaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGhlbGQgPSB1c2VWYXIoaW5pdGlhbFZhbHVlKTtcbiAgY29uc3QgdXBvbiA9IHVzZUV2ZW50UmVjZWl2ZXIodXBvbkV2dHMpO1xuXG4gIGlmICh1cG9uKSB7XG4gICAgaGVsZC5jdXJyZW50ID0gdG9TYW1wbGU7XG4gIH1cblxuICByZXR1cm4gaGVsZC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBldmVyeVNlY29uZCgpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgW3RpY2tFdnRzLCBlbWl0VGlja10gPSB1c2VFdmVudEVtaXR0ZXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkludGVydmFsID0gKCkgPT4ge1xuICAgICAgZW1pdFRpY2soKTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXJJZCA9IHNldEludGVydmFsKG9uSW50ZXJ2YWwsIDEwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcklkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aWNrRXZ0cztcbn1cblxuLyoqXG4gKiBVbnRpbCBhdWRpbyBpcyBsb2FkZWQgYW5kIGRlY29kZWQsIGEgc2luZ2xlLXNhbXBsZSBidWZmZXIgb2Ygc2lsZW5jZSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gbG9hZEF1ZGlvQXNBcnJheSh1cmwpIHtcbiAgY29uc3QgcmVxdWVzdFVwZGF0ZSA9IHVzZVJlcXVlc3RVcGRhdGUoKTtcbiAgY29uc3QgcGNtID0gdXNlVmFyKFswXSk7IC8vIHVudGlsIGxvYWRlZCwganVzdCByZXR1cm4gc2luZ2xlIHNhbXBsZSBvZiBzaWxlbmNlXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3QgYXVkaW9DdHggPSBuZXcgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkoKTtcbiAgICBsZXQgY2xlYW5lZFVwID0gZmFsc2U7XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGF1ZGlvRGF0YSA9IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhLCBidWZmZXIgPT4ge1xuICAgICAgICBpZiAoIWNsZWFuZWRVcCkge1xuICAgICAgICAgIHBjbS5jdXJyZW50ID0gYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJlcXVlc3Quc2VuZCgpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgcmVxdWVzdC5hYm9ydCgpOyAvLyBpdCdzIHNhZmUgdG8gYWx3YXlzIGFib3J0IGhlcmUuIGlmIGFscmVhZHkgY29tcGxldGVkLCBpdCB3aWxsIGJlIGlnbm9yZWRcblxuICAgICAgLy8gZGVjb2RlQXVkaW9EYXRhIGNhbm5vdCBiZSBjYW5jZWxlZC4gU28gdG8gYmUgY29ycmVjdCwgd2UgbXVzdCBzZXQgYSBmbGFnIGhlcmUgdG8gbWFrZSBzdXJlXG4gICAgICAvLyB0aGF0IGRlY29kaW5nIGlzIGlnbm9yZWRcbiAgICAgIGNsZWFuZWRVcCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGNtLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbnNvbGVMb2codikge1xuICBjb25zb2xlLmxvZyh2KTtcbn1cblxuZnVuY3Rpb24gaW50ZWdyYWwoaW50ZWdyYW5kRnVuYywgdGltZSwgaW5pdGlhbFZhbHVlID0gMCkge1xuICBjb25zdCBhY2N1bSA9IHVzZVZhcihpbml0aWFsVmFsdWUpO1xuICBjb25zdCBwcmV2VGltZSA9IHVzZVZhcih0aW1lKTtcblxuICBjb25zdCBpbnRlZ3JhbmQgPSBpbnRlZ3JhbmRGdW5jKGFjY3VtLmN1cnJlbnQsIHByZXZUaW1lLmN1cnJlbnQpO1xuICBhY2N1bS5jdXJyZW50ICs9ICh0aW1lIC0gcHJldlRpbWUuY3VycmVudCkqaW50ZWdyYW5kO1xuXG4gIHByZXZUaW1lLmN1cnJlbnQgPSB0aW1lO1xuXG4gIHJldHVybiBhY2N1bS5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBzbW9vdGhGb2xsb3codGFyZ2V0VmFsdWUsIHRpbWUsIHNwZWVkQ29uc3RhbnQpIHtcbiAgcmV0dXJuIGludGVncmFsKGN1cnJlbnRWYWx1ZSA9PiBzcGVlZENvbnN0YW50Kih0YXJnZXRWYWx1ZSAtIGN1cnJlbnRWYWx1ZSksIHRpbWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBbXG4gIHtcbiAgICBuYW1lOiAnZG8gbm90aGluZycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdhbmltYXRpb24gdGltZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhhbmltYXRpb25UaW1lKCkudG9GaXhlZCgzKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NvdW50IGNsaWNrcycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhjb3VudEV2ZW50cyhtb3VzZUNsaWNrRXZ0cygpKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2lzIG1vdXNlIGJ1dHRvbiBkb3duJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKG1vdXNlRG93bigpKTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmFuZG9tIG51bWJlciwgY2xpY2sgdG8gcmVwaWNrJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBzaG93U3RyaW5nKHJhbmRvbShtb3VzZUNsaWNrRXZ0cygpKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2F1ZGlvIG5vaXNlIHdoZW4gbW91c2UgaXMgZG93bicsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgbWQgPSBtb3VzZURvd24oKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9pc2UgPSByYW5kb20oYWR2YW5jZUZyYW1lRXZ0cykgLSAwLjU7XG4gICAgICAgIHJldHVybiBtZCA/IG5vaXNlIDogMDtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdkZWNheWluZyBub2lzZSB1cG9uIGNsaWNrJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBjbGlja0V2dHMgPSBtb3VzZUNsaWNrRXZ0cygpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0cykgPT4ge1xuICAgICAgICBjb25zdCBub2lzZSA9IHJhbmRvbShhZHZhbmNlRnJhbWVFdnRzKSAtIDAuNTtcbiAgICAgICAgY29uc3QgbGFzdENsaWNrVGltZSA9IHNhbXBsZVVwb24oYXVkaW9UaW1lLCBjbGlja0V2dHMsIC1JbmZpbml0eSk7XG4gICAgICAgIGNvbnN0IGRlY2F5aW5nR2FpbiA9IE1hdGguZXhwKDUqKGxhc3RDbGlja1RpbWUgLSBhdWRpb1RpbWUpKTtcbiAgICAgICAgcmV0dXJuIGRlY2F5aW5nR2Fpbipub2lzZTtcbiAgICAgIH0pO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyZXNldHRpbmcgZnJhbWUgY291bnRlciwgY2xpY2sgdG8gcmVzZXQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGZyYW1lRXZ0cyA9IGFuaW1hdGlvbkZyYW1lRXZ0cygpO1xuICAgICAgY29uc3QgY2xpY2tFdnRzID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrID0gdXNlRXZlbnRSZWNlaXZlcihjbGlja0V2dHMpO1xuICAgICAgY29uc3QgY3JlYXRlQ291bnRlciA9IHVzZUR5bmFtaWMoY291bnRFdmVudHMpO1xuICAgICAgY29uc3QgYWN0aXZlQ291bnRlciA9IHVzZVZhcigpO1xuXG4gICAgICBpZiAoY2xpY2spIHtcbiAgICAgICAgaWYgKGFjdGl2ZUNvdW50ZXIuY3VycmVudCkge1xuICAgICAgICAgIGFjdGl2ZUNvdW50ZXIuY3VycmVudC50ZXJtaW5hdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVDb3VudGVyLmN1cnJlbnQgPSBjcmVhdGVDb3VudGVyKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWFjdGl2ZUNvdW50ZXIuY3VycmVudCkge1xuICAgICAgICBhY3RpdmVDb3VudGVyLmN1cnJlbnQgPSBjcmVhdGVDb3VudGVyKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpc3BsYXllZENvdW50ID0gYWN0aXZlQ291bnRlci5jdXJyZW50LnVwZGF0ZShmcmFtZUV2dHMpO1xuICAgICAgc2hvd1N0cmluZyhkaXNwbGF5ZWRDb3VudCk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnZHluYW1pYyBhcnJheSBvZiBhc3luYyBjbG9ja3MsIGNsaWNrIHRvIGFkZCcsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgY2xpY2tFdnRzID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrID0gdXNlRXZlbnRSZWNlaXZlcihjbGlja0V2dHMpO1xuICAgICAgY29uc3QgY3JlYXRlQ2xvY2sgPSB1c2VEeW5hbWljKCgpID0+IGNvdW50RXZlbnRzKGV2ZXJ5U2Vjb25kKCkpKTtcbiAgICAgIGNvbnN0IGNsb2NrQXJyYXkgPSB1c2VWYXIoW10pO1xuXG4gICAgICBpZiAoY2xpY2spIHtcbiAgICAgICAgY2xvY2tBcnJheS5jdXJyZW50LnB1c2goY3JlYXRlQ2xvY2soKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG51bXMgPSBjbG9ja0FycmF5LmN1cnJlbnQubWFwKGNsb2NrID0+IGNsb2NrLnVwZGF0ZSgpKTtcbiAgICAgIHNob3dTdHJpbmcobnVtcy5qb2luKCcgJykpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3JlY29yZCBwbGF5ZXIgc3BpbiB1cC9kb3duLCBob2xkIG1vdXNlIGRvd24gYW5kIHJlbGVhc2UnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHBjbSA9IGxvYWRBdWRpb0FzQXJyYXkoJ2FtZW5fYnJlYWsubXAzJyk7XG4gICAgICBzaG93U3RyaW5nKHBjbS5sZW5ndGggPiAxID8gJ2xvYWRlZCBhdWRpbycgOiAnbG9hZGluZyBhdWRpby4uLicpO1xuICAgICAgYXVkaW9Ecml2ZXIoKGF1ZGlvVGltZSwgYWR2YW5jZUZyYW1lRXZ0cywgc2FtcGxlUmF0ZSkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRTcGVlZCA9IG1vdXNlRG93bigpID8gc2FtcGxlUmF0ZSA6IDA7XG4gICAgICAgIGNvbnN0IHNwZWVkID0gc21vb3RoRm9sbG93KHRhcmdldFNwZWVkLCBhdWRpb1RpbWUsIDMpO1xuICAgICAgICBjb25zdCBwb3MgPSBNYXRoLmZsb29yKGludGVncmFsKCgpID0+IHNwZWVkLCBhdWRpb1RpbWUpKTtcbiAgICAgICAgcmV0dXJuIHBjbVtwb3MgJSBwY20ubGVuZ3RoXTsgLy8gbW9kdWxvIHNvIGFzIHRvIGxvb3BcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbl1cbiIsImltcG9ydCB7IGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IH0gZnJvbSAnLi9jaGlub29rJztcbmltcG9ydCBwcm9ncmFtcyBmcm9tICcuL3Byb2dyYW1zJztcblxuY29uc3QgcHJvZ3JhbUxpc3RFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2dyYW0tbGlzdCcpO1xuY29uc3QgcHJvZ3JhbVNvdXJjZUVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3JhbS1zb3VyY2UnKTtcblxubGV0IGN1cnJlbnRDb250ZXh0O1xuXG4vLyBOT1RFOiBUaGlzIGlzIGEgaGFjayBidXQgd29ya3MgZm9yIG5vd1xuY29uc3QgZml4SW5kZW50ID0gKGNvZGUpID0+IHtcbiAgcmV0dXJuIGNvZGUuc3BsaXQoJ1xcbicpLm1hcCgobGluZSwgaWR4KSA9PiAoaWR4ID09PSAwKSA/IGxpbmUgOiBsaW5lLnN1YnN0cigyKSkuam9pbignXFxuJyk7XG59XG5cbmNvbnN0IHN0YXJ0UHJvZ3JhbSA9IChwcm9ncmFtKSA9PiB7XG4gIGlmIChjdXJyZW50Q29udGV4dCkge1xuICAgIGN1cnJlbnRDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIGN1cnJlbnRDb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcHJvZ3JhbVNvdXJjZUVsZW0udGV4dENvbnRlbnQgPSBmaXhJbmRlbnQocHJvZ3JhbS5tYWluLnRvU3RyaW5nKCkpOyAvLyBoYWNreSBidXQgd29ya3MgZm9yIG5vd1xuICBjdXJyZW50Q29udGV4dCA9IGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0KHByb2dyYW0ubWFpbik7XG4gIGN1cnJlbnRDb250ZXh0LnVwZGF0ZSgpOyAvLyBkbyBpbml0aWFsIHVwZGF0ZS4gYW55IGZ1cnRoZXIgdXBkYXRlcyB3aWxsIGJlIGFzeW5jXG59XG5cbmZvciAoY29uc3QgcHJvZyBvZiBwcm9ncmFtcykge1xuICBjb25zdCBhbmNob3JFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhbmNob3JFbGVtLnRleHRDb250ZW50ID0gcHJvZy5uYW1lO1xuICBhbmNob3JFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICgoKSA9PiB7XG4gICAgYW5jaG9yRWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHsgLy8gc3RhcnQgcHJvZ3JhbSB3aXRoIGRlbGF5IHNvIGl0IGRvZXNuJ3QgZ2V0IHRoaXMgY2xpY2sgZXZlbnRcbiAgICAgICAgc3RhcnRQcm9ncmFtKHByb2cpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG4gIH0pKCk7XG5cbiAgY29uc3QgaXRlbUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICBpdGVtRWxlbS5hcHBlbmRDaGlsZChhbmNob3JFbGVtKTtcblxuICBwcm9ncmFtTGlzdEVsZW0uYXBwZW5kQ2hpbGQoaXRlbUVsZW0pO1xufVxuXG5zdGFydFByb2dyYW0ocHJvZ3JhbXNbMF0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")}]);