!function(Q){var F={};function B(U){if(F[U])return F[U].exports;var n=F[U]={i:U,l:!1,exports:{}};return Q[U].call(n.exports,n,n.exports,B),n.l=!0,n.exports}B.m=Q,B.c=F,B.d=function(Q,F,U){B.o(Q,F)||Object.defineProperty(Q,F,{enumerable:!0,get:U})},B.r=function(Q){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(Q,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(Q,"__esModule",{value:!0})},B.t=function(Q,F){if(1&F&&(Q=B(Q)),8&F)return Q;if(4&F&&"object"==typeof Q&&Q&&Q.__esModule)return Q;var U=Object.create(null);if(B.r(U),Object.defineProperty(U,"default",{enumerable:!0,value:Q}),2&F&&"string"!=typeof Q)for(var n in Q)B.d(U,n,function(F){return Q[F]}.bind(null,n));return U},B.n=function(Q){var F=Q&&Q.__esModule?function(){return Q.default}:function(){return Q};return B.d(F,"a",F),F},B.o=function(Q,F){return Object.prototype.hasOwnProperty.call(Q,F)},B.p="",B(B.s=1)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createNoInOutExecutionContext", function() { return createNoInOutExecutionContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useVar", function() { return useVar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useRequestUpdate", function() { return useRequestUpdate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useInitialize", function() { return useInitialize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventEmitter", function() { return useEventEmitter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useEventReceiver", function() { return useEventReceiver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDynamic", function() { return useDynamic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReducer", function() { return useReducer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useMachine", function() { return useMachine; });\nlet currentUpdateFrame = null;\n\nclass ExecutionContext {\n  constructor(streamFunc, onRequestUpdate, afterTerminate) {\n    this.streamFunc = streamFunc;\n    this.onRequestUpdate = onRequestUpdate;\n    this.afterTerminate = afterTerminate;\n    this.hookRecordChain = {\n      next: null\n    }; // dummy\n\n    this.recordCursor = null; // only set when this context is updating\n\n    this.updateCount = 0;\n  }\n\n  update() {\n    // Push a new update frame onto the update stack for this context\n    const newFrame = {\n      executionContext: this,\n      previousFrame: currentUpdateFrame\n    };\n    currentUpdateFrame = newFrame; // Move hook record cursor to start of chain\n\n    this.recordCursor = this.hookRecordChain;\n    const retval = this.streamFunc.apply(null, arguments); // This should be null, otherwise there are hook records we didn\'t get to, and something is amiss\n\n    if (this.recordCursor.next) {\n      throw new Error(\'Did not reach all hook records in update\');\n    } // Pop the top frame from the update stack\n\n\n    const poppedFrame = currentUpdateFrame;\n\n    if (!poppedFrame) {\n      throw new Error(\'Cannot pop update frame because current is null\');\n    }\n\n    if (poppedFrame.executionContext !== this) {\n      throw new Error("Popped frame from update stack but context did not match");\n    }\n\n    currentUpdateFrame = poppedFrame.previousFrame;\n    this.updateCount++;\n    return retval;\n  }\n\n  terminate() {\n    // NOTE: Might we want to sanity check that this context isn\'t anywhere in the current update stack?\n    // Call any cleanup functions set by hooks\n    // TODO: Do we need to worry about order?\n    for (let c = this.hookRecordChain.next; c; c = c.next) {\n      if (c.cleanup) {\n        c.cleanup();\n      }\n    }\n\n    if (this.afterTerminate) {\n      this.afterTerminate();\n    }\n  }\n\n  _beginHook() {\n    if (this.updateCount === 0) {\n      if (this.recordCursor.next) {\n        throw new Error(\'Expecting to create new hook record in chain, but already present\');\n      } // Create new record\n\n\n      this.recordCursor.next = {\n        data: undefined,\n        cleanup: undefined,\n        next: null\n      };\n    }\n\n    if (!this.recordCursor.next) {\n      throw new Error(\'Expecting to find hook record in chain, but not present\');\n    }\n\n    return this.recordCursor.next;\n  }\n\n  _endHook() {\n    this.recordCursor = this.recordCursor.next; // move cursor forward\n  }\n\n  _requestUpdate() {\n    this.onRequestUpdate();\n  }\n  /**\n   * This is only safe to do if the replacement function calls the same hooks, has same signature, etc.\n   * It\'s currently used to provide a function that is lexically the same but bound to different outer-scope\n   * variables.\n   */\n\n\n  _setStreamFunc(newStreamFunc) {\n    this.streamFunc = newStreamFunc;\n  }\n\n}\n\nfunction createNoInOutExecutionContext(streamFunc) {\n  const onRequestUpdate = () => {\n    ctx.update();\n  };\n\n  const ctx = new ExecutionContext(streamFunc, onRequestUpdate);\n  return ctx;\n}\n/**\n * This is used by hooks to get the currently updating context (after verifying it is set)\n */\n\nfunction getTopUpdatingExecutionContext() {\n  if (!currentUpdateFrame) {\n    throw new Error(\'Cannot get currently updating execution context because update stack is empty. Was a hook called outside of an execution context update?\');\n  }\n\n  return currentUpdateFrame.executionContext;\n}\n\nfunction useVar(initVal) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create value box if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      current: initVal\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data;\n}\n/**\n * Why do we need a hook? Why can\'t we just call ctx.requestUpdate()? Because the requestUpdate\n * function that we return will often be called without there being any updating execution context\n * (e.g. from an event handler). So it has to be bound to the correct context.\n */\n\nfunction useRequestUpdate() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Create callback if necessary. We store it so that we already return the same one.\n\n\n  if (!record.data) {\n    record.data = {\n      requestUpdate: () => {\n        ctx._requestUpdate(); // it\'s important that we use ctx from closure, not getTopUpdatingExecutionContext() here\n\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return record.data.requestUpdate;\n}\nfunction useInitialize(initializer) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize if necessary\n\n\n  if (!record.data) {\n    // data being undefined means this is the first call\n    record.cleanup = initializer();\n    record.data = {}; // no data to store yet, just needs to be truthy to indicate that initialization ran\n  }\n\n  ctx._endHook();\n}\nfunction useEventEmitter() {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const stream = {\n      count: 0,\n      // how many events have occurred on this stream\n      latestValue: undefined\n    };\n    record.data = {\n      stream,\n      emit: value => {\n        // This function closes over the stream variable\n        stream.latestValue = value;\n        stream.count++;\n      }\n    };\n  }\n\n  ctx._endHook();\n\n  return [record.data.stream, record.data.emit];\n}\nfunction useEventReceiver(stream) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    record.data = {\n      stream,\n      // the stream we are receiving on\n      lastSeenNumber: stream.count\n    };\n  } // TODO: We could support this, just need to consider details.\n\n\n  if (stream !== record.data.stream) {\n    throw new Error(\'Event receiver found that stream object changed identity\');\n  }\n\n  let boxedEvent;\n\n  if (record.data.lastSeenNumber === stream.count) {// There have not been any new events on the stream\n  } else if (record.data.lastSeenNumber === stream.count - 1) {\n    // There has been exactly one new event on the stream that we haven\'t seen yet.\n    boxedEvent = {\n      value: stream.latestValue\n    };\n    record.data.lastSeenNumber++;\n  } else {\n    throw new Error(\'Event receiver got too many events or missed some\');\n  }\n\n  ctx._endHook();\n\n  return boxedEvent;\n}\n/**\n * The streamFunc argument may change, but it should only change to a function that can be safely\n * swapped in (i.e. one that calls the same hooks, etc.). A common case is that streamFunc is a\n * closure that references some outer scope variables, and when those change, a new "version" of\n * the function is created (lexically the same, but closing over a different scope).\n *\n * onRequestUpdate is currently only read on the first call, so changes to it will have no effect.\n */\n\nfunction useDynamic(streamFunc, onRequestUpdate) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook(); // Initialize record data if necessary\n\n\n  if (!record.data) {\n    const data = {}; // If no onRequestUpdate is provided, default to requesting update on the current context\n\n    const oru = onRequestUpdate || (() => {\n      ctx._requestUpdate();\n    }); // Track ExecutionContexts created (and not yet terminated) so we can terminate them upon cleanup\n\n\n    data.activeContexts = new Set(); // Create "factory" function to instantiate new contexts\n\n    data.createContext = () => {\n      const ctx = new ExecutionContext(data.streamFunc, oru, () => {\n        data.activeContexts.delete(ctx);\n      });\n      data.activeContexts.add(ctx);\n      return ctx;\n    };\n\n    record.data = data;\n\n    record.cleanup = () => {\n      for (const ctx of data.activeContexts) {\n        ctx.terminate();\n      }\n    };\n  } // Update the stream function in record and all active contexts.\n\n\n  record.data.streamFunc = streamFunc;\n\n  for (const ctx of record.data.activeContexts) {\n    ctx._setStreamFunc(streamFunc);\n  }\n\n  ctx._endHook();\n\n  return record.data.createContext;\n}\nfunction useReducer(actionEvts, reducerFunc, initialState) {\n  const state = useVar(initialState);\n  const action = useEventReceiver(actionEvts);\n  state.current = reducerFunc(action, state.current);\n  return state.current;\n}\n/**\n * TODO: Could/should this take an optional onRequestUpdate parameter?\n */\n\nfunction useMachine(states, initialTransition) {\n  const ctx = getTopUpdatingExecutionContext();\n\n  const record = ctx._beginHook();\n\n  const takeTransition = trans => {\n    // If there\'s an old context, terminate it\n    if (record.data.activeContext) {\n      record.data.activeContext.terminate();\n    }\n\n    const [newState, newStateArg] = trans; // Create a new context and store it in record (but don\'t update it)\n\n    const newCtx = new ExecutionContext(states[newState], () => {\n      ctx._requestUpdate();\n    });\n    record.data.activeState = newState;\n    record.data.activeContext = newCtx;\n    record.data.activeArgument = newStateArg;\n  };\n\n  if (!record.data) {\n    const data = {};\n    record.data = data;\n    takeTransition(initialTransition); // this will set stuff in record.data\n\n    record.cleanup = () => {\n      data.activeContext.terminate();\n    };\n  }\n\n  let retval;\n\n  while (true) {\n    // Set the state function in the active context (in case it changed)\n    record.data.activeContext._setStreamFunc(states[record.data.activeState]); // Update the active context\n\n\n    const [tmpRetval, transitionEvts] = record.data.activeContext.update(record.data.activeArgument);\n    retval = tmpRetval; // Was there a transition event?\n    // NOTE: Because we transition upon first even on this stream, we can sort of special-case this check\n\n    if (transitionEvts.count) {\n      const transition = transitionEvts.latestValue;\n      takeTransition(transition);\n    } else {\n      // There was no transition\n      break;\n    }\n  }\n\n  ctx._endHook();\n\n  return retval;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcml2LmpzPzgxNWEiXSwibmFtZXMiOlsiY3VycmVudFVwZGF0ZUZyYW1lIiwiRXhlY3V0aW9uQ29udGV4dCIsImNvbnN0cnVjdG9yIiwic3RyZWFtRnVuYyIsIm9uUmVxdWVzdFVwZGF0ZSIsImFmdGVyVGVybWluYXRlIiwiaG9va1JlY29yZENoYWluIiwibmV4dCIsInJlY29yZEN1cnNvciIsInVwZGF0ZUNvdW50IiwidXBkYXRlIiwibmV3RnJhbWUiLCJleGVjdXRpb25Db250ZXh0IiwicHJldmlvdXNGcmFtZSIsInJldHZhbCIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJwb3BwZWRGcmFtZSIsInRlcm1pbmF0ZSIsImMiLCJjbGVhbnVwIiwiX2JlZ2luSG9vayIsImRhdGEiLCJ1bmRlZmluZWQiLCJfZW5kSG9vayIsIl9yZXF1ZXN0VXBkYXRlIiwiX3NldFN0cmVhbUZ1bmMiLCJuZXdTdHJlYW1GdW5jIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJjdHgiLCJnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQiLCJ1c2VWYXIiLCJpbml0VmFsIiwicmVjb3JkIiwiY3VycmVudCIsInVzZVJlcXVlc3RVcGRhdGUiLCJyZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsImluaXRpYWxpemVyIiwidXNlRXZlbnRFbWl0dGVyIiwic3RyZWFtIiwiY291bnQiLCJsYXRlc3RWYWx1ZSIsImVtaXQiLCJ2YWx1ZSIsInVzZUV2ZW50UmVjZWl2ZXIiLCJsYXN0U2Vlbk51bWJlciIsImJveGVkRXZlbnQiLCJ1c2VEeW5hbWljIiwib3J1IiwiYWN0aXZlQ29udGV4dHMiLCJTZXQiLCJjcmVhdGVDb250ZXh0IiwiZGVsZXRlIiwiYWRkIiwidXNlUmVkdWNlciIsImFjdGlvbkV2dHMiLCJyZWR1Y2VyRnVuYyIsImluaXRpYWxTdGF0ZSIsInN0YXRlIiwiYWN0aW9uIiwidXNlTWFjaGluZSIsInN0YXRlcyIsImluaXRpYWxUcmFuc2l0aW9uIiwidGFrZVRyYW5zaXRpb24iLCJ0cmFucyIsImFjdGl2ZUNvbnRleHQiLCJuZXdTdGF0ZSIsIm5ld1N0YXRlQXJnIiwibmV3Q3R4IiwiYWN0aXZlU3RhdGUiLCJhY3RpdmVBcmd1bWVudCIsInRtcFJldHZhbCIsInRyYW5zaXRpb25FdnRzIiwidHJhbnNpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUFJQSxrQkFBa0IsR0FBRyxJQUF6Qjs7QUFFQSxNQUFNQyxnQkFBTixDQUF1QjtBQUNyQkMsYUFBVyxDQUFDQyxVQUFELEVBQWFDLGVBQWIsRUFBOEJDLGNBQTlCLEVBQThDO0FBQ3ZELFNBQUtGLFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0EsU0FBS0MsZUFBTCxHQUF1QkEsZUFBdkI7QUFDQSxTQUFLQyxjQUFMLEdBQXNCQSxjQUF0QjtBQUVBLFNBQUtDLGVBQUwsR0FBdUI7QUFBQ0MsVUFBSSxFQUFFO0FBQVAsS0FBdkIsQ0FMdUQsQ0FLbEI7O0FBQ3JDLFNBQUtDLFlBQUwsR0FBb0IsSUFBcEIsQ0FOdUQsQ0FNN0I7O0FBQzFCLFNBQUtDLFdBQUwsR0FBbUIsQ0FBbkI7QUFDRDs7QUFFREMsUUFBTSxHQUFHO0FBQ1A7QUFDQSxVQUFNQyxRQUFRLEdBQUc7QUFDZkMsc0JBQWdCLEVBQUUsSUFESDtBQUVmQyxtQkFBYSxFQUFFYjtBQUZBLEtBQWpCO0FBSUFBLHNCQUFrQixHQUFHVyxRQUFyQixDQU5PLENBUVA7O0FBQ0EsU0FBS0gsWUFBTCxHQUFvQixLQUFLRixlQUF6QjtBQUVBLFVBQU1RLE1BQU0sR0FBRyxLQUFLWCxVQUFMLENBQWdCWSxLQUFoQixDQUFzQixJQUF0QixFQUE0QkMsU0FBNUIsQ0FBZixDQVhPLENBYVA7O0FBQ0EsUUFBSSxLQUFLUixZQUFMLENBQWtCRCxJQUF0QixFQUE0QjtBQUMxQixZQUFNLElBQUlVLEtBQUosQ0FBVSwwQ0FBVixDQUFOO0FBQ0QsS0Fo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QSxTQUFPWCxNQUFQO0FBQ0QiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImxldCBjdXJyZW50VXBkYXRlRnJhbWUgPSBudWxsO1xuXG5jbGFzcyBFeGVjdXRpb25Db250ZXh0IHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtRnVuYywgb25SZXF1ZXN0VXBkYXRlLCBhZnRlclRlcm1pbmF0ZSkge1xuICAgIHRoaXMuc3RyZWFtRnVuYyA9IHN0cmVhbUZ1bmM7XG4gICAgdGhpcy5vblJlcXVlc3RVcGRhdGUgPSBvblJlcXVlc3RVcGRhdGU7XG4gICAgdGhpcy5hZnRlclRlcm1pbmF0ZSA9IGFmdGVyVGVybWluYXRlO1xuXG4gICAgdGhpcy5ob29rUmVjb3JkQ2hhaW4gPSB7bmV4dDogbnVsbH07IC8vIGR1bW15XG4gICAgdGhpcy5yZWNvcmRDdXJzb3IgPSBudWxsOyAvLyBvbmx5IHNldCB3aGVuIHRoaXMgY29udGV4dCBpcyB1cGRhdGluZ1xuICAgIHRoaXMudXBkYXRlQ291bnQgPSAwO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIC8vIFB1c2ggYSBuZXcgdXBkYXRlIGZyYW1lIG9udG8gdGhlIHVwZGF0ZSBzdGFjayBmb3IgdGhpcyBjb250ZXh0XG4gICAgY29uc3QgbmV3RnJhbWUgPSB7XG4gICAgICBleGVjdXRpb25Db250ZXh0OiB0aGlzLFxuICAgICAgcHJldmlvdXNGcmFtZTogY3VycmVudFVwZGF0ZUZyYW1lLFxuICAgIH07XG4gICAgY3VycmVudFVwZGF0ZUZyYW1lID0gbmV3RnJhbWU7XG5cbiAgICAvLyBNb3ZlIGhvb2sgcmVjb3JkIGN1cnNvciB0byBzdGFydCBvZiBjaGFpblxuICAgIHRoaXMucmVjb3JkQ3Vyc29yID0gdGhpcy5ob29rUmVjb3JkQ2hhaW47XG5cbiAgICBjb25zdCByZXR2YWwgPSB0aGlzLnN0cmVhbUZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG51bGwsIG90aGVyd2lzZSB0aGVyZSBhcmUgaG9vayByZWNvcmRzIHdlIGRpZG4ndCBnZXQgdG8sIGFuZCBzb21ldGhpbmcgaXMgYW1pc3NcbiAgICBpZiAodGhpcy5yZWNvcmRDdXJzb3IubmV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaWQgbm90IHJlYWNoIGFsbCBob29rIHJlY29yZHMgaW4gdXBkYXRlJyk7XG4gICAgfVxuXG4gICAgLy8gUG9wIHRoZSB0b3AgZnJhbWUgZnJvbSB0aGUgdXBkYXRlIHN0YWNrXG4gICAgY29uc3QgcG9wcGVkRnJhbWUgPSBjdXJyZW50VXBkYXRlRnJhbWU7XG4gICAgaWYgKCFwb3BwZWRGcmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcG9wIHVwZGF0ZSBmcmFtZSBiZWNhdXNlIGN1cnJlbnQgaXMgbnVsbCcpO1xuICAgIH1cbiAgICBpZiAocG9wcGVkRnJhbWUuZXhlY3V0aW9uQ29udGV4dCAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9wcGVkIGZyYW1lIGZyb20gdXBkYXRlIHN0YWNrIGJ1dCBjb250ZXh0IGRpZCBub3QgbWF0Y2hcIik7XG4gICAgfVxuICAgIGN1cnJlbnRVcGRhdGVGcmFtZSA9IHBvcHBlZEZyYW1lLnByZXZpb3VzRnJhbWU7XG5cbiAgICB0aGlzLnVwZGF0ZUNvdW50Kys7XG5cbiAgICByZXR1cm4gcmV0dmFsO1xuICB9XG5cbiAgdGVybWluYXRlKCkge1xuICAgIC8vIE5PVEU6IE1pZ2h0IHdlIHdhbnQgdG8gc2FuaXR5IGNoZWNrIHRoYXQgdGhpcyBjb250ZXh0IGlzbid0IGFueXdoZXJlIGluIHRoZSBjdXJyZW50IHVwZGF0ZSBzdGFjaz9cblxuICAgIC8vIENhbGwgYW55IGNsZWFudXAgZnVuY3Rpb25zIHNldCBieSBob29rc1xuICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gd29ycnkgYWJvdXQgb3JkZXI/XG4gICAgZm9yIChsZXQgYyA9IHRoaXMuaG9va1JlY29yZENoYWluLm5leHQ7IGM7IGMgPSBjLm5leHQpIHtcbiAgICAgIGlmIChjLmNsZWFudXApIHtcbiAgICAgICAgYy5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWZ0ZXJUZXJtaW5hdGUpIHtcbiAgICAgIHRoaXMuYWZ0ZXJUZXJtaW5hdGUoKTtcbiAgICB9XG4gIH1cblxuICBfYmVnaW5Ib29rKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUNvdW50ID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5yZWNvcmRDdXJzb3IubmV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyB0byBjcmVhdGUgbmV3IGhvb2sgcmVjb3JkIGluIGNoYWluLCBidXQgYWxyZWFkeSBwcmVzZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDcmVhdGUgbmV3IHJlY29yZFxuICAgICAgdGhpcy5yZWNvcmRDdXJzb3IubmV4dCA9IHtcbiAgICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgICBjbGVhbnVwOiB1bmRlZmluZWQsXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlY29yZEN1cnNvci5uZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyB0byBmaW5kIGhvb2sgcmVjb3JkIGluIGNoYWluLCBidXQgbm90IHByZXNlbnQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWNvcmRDdXJzb3IubmV4dDtcbiAgfVxuXG4gIF9lbmRIb29rKCkge1xuICAgIHRoaXMucmVjb3JkQ3Vyc29yID0gdGhpcy5yZWNvcmRDdXJzb3IubmV4dDsgLy8gbW92ZSBjdXJzb3IgZm9yd2FyZFxuICB9XG5cbiAgX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgdGhpcy5vblJlcXVlc3RVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIG9ubHkgc2FmZSB0byBkbyBpZiB0aGUgcmVwbGFjZW1lbnQgZnVuY3Rpb24gY2FsbHMgdGhlIHNhbWUgaG9va3MsIGhhcyBzYW1lIHNpZ25hdHVyZSwgZXRjLlxuICAgKiBJdCdzIGN1cnJlbnRseSB1c2VkIHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGlzIGxleGljYWxseSB0aGUgc2FtZSBidXQgYm91bmQgdG8gZGlmZmVyZW50IG91dGVyLXNjb3BlXG4gICAqIHZhcmlhYmxlcy5cbiAgICovXG4gIF9zZXRTdHJlYW1GdW5jKG5ld1N0cmVhbUZ1bmMpIHtcbiAgICB0aGlzLnN0cmVhbUZ1bmMgPSBuZXdTdHJlYW1GdW5jO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOb0luT3V0RXhlY3V0aW9uQ29udGV4dChzdHJlYW1GdW5jKSB7XG4gIGNvbnN0IG9uUmVxdWVzdFVwZGF0ZSA9ICgpID0+IHsgY3R4LnVwZGF0ZSgpIH07XG4gIGNvbnN0IGN0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSlcbiAgcmV0dXJuIGN0eDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIHVzZWQgYnkgaG9va3MgdG8gZ2V0IHRoZSBjdXJyZW50bHkgdXBkYXRpbmcgY29udGV4dCAoYWZ0ZXIgdmVyaWZ5aW5nIGl0IGlzIHNldClcbiAqL1xuZnVuY3Rpb24gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCkge1xuICBpZiAoIWN1cnJlbnRVcGRhdGVGcmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBjdXJyZW50bHkgdXBkYXRpbmcgZXhlY3V0aW9uIGNvbnRleHQgYmVjYXVzZSB1cGRhdGUgc3RhY2sgaXMgZW1wdHkuIFdhcyBhIGhvb2sgY2FsbGVkIG91dHNpZGUgb2YgYW4gZXhlY3V0aW9uIGNvbnRleHQgdXBkYXRlPycpO1xuICB9XG4gIHJldHVybiBjdXJyZW50VXBkYXRlRnJhbWUuZXhlY3V0aW9uQ29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVZhcihpbml0VmFsKSB7XG4gIGNvbnN0IGN0eCA9IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpO1xuICBjb25zdCByZWNvcmQgPSBjdHguX2JlZ2luSG9vaygpO1xuXG4gIC8vIENyZWF0ZSB2YWx1ZSBib3ggaWYgbmVjZXNzYXJ5XG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtjdXJyZW50OiBpbml0VmFsfTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiByZWNvcmQuZGF0YTtcbn1cblxuLyoqXG4gKiBXaHkgZG8gd2UgbmVlZCBhIGhvb2s/IFdoeSBjYW4ndCB3ZSBqdXN0IGNhbGwgY3R4LnJlcXVlc3RVcGRhdGUoKT8gQmVjYXVzZSB0aGUgcmVxdWVzdFVwZGF0ZVxuICogZnVuY3Rpb24gdGhhdCB3ZSByZXR1cm4gd2lsbCBvZnRlbiBiZSBjYWxsZWQgd2l0aG91dCB0aGVyZSBiZWluZyBhbnkgdXBkYXRpbmcgZXhlY3V0aW9uIGNvbnRleHRcbiAqIChlLmcuIGZyb20gYW4gZXZlbnQgaGFuZGxlcikuIFNvIGl0IGhhcyB0byBiZSBib3VuZCB0byB0aGUgY29ycmVjdCBjb250ZXh0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVxdWVzdFVwZGF0ZSgpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gQ3JlYXRlIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeS4gV2Ugc3RvcmUgaXQgc28gdGhhdCB3ZSBhbHJlYWR5IHJldHVybiB0aGUgc2FtZSBvbmUuXG4gIGlmICghcmVjb3JkLmRhdGEpIHtcbiAgICByZWNvcmQuZGF0YSA9IHtyZXF1ZXN0VXBkYXRlOiAoKSA9PiB7XG4gICAgICBjdHguX3JlcXVlc3RVcGRhdGUoKTsgLy8gaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSB1c2UgY3R4IGZyb20gY2xvc3VyZSwgbm90IGdldFRvcFVwZGF0aW5nRXhlY3V0aW9uQ29udGV4dCgpIGhlcmVcbiAgICB9fTtcbiAgfVxuXG4gIGN0eC5fZW5kSG9vaygpO1xuXG4gIHJldHVybiByZWNvcmQuZGF0YS5yZXF1ZXN0VXBkYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5pdGlhbGl6ZShpbml0aWFsaXplcikge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgLy8gZGF0YSBiZWluZyB1bmRlZmluZWQgbWVhbnMgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbFxuXG4gICAgcmVjb3JkLmNsZWFudXAgPSBpbml0aWFsaXplcigpO1xuXG4gICAgcmVjb3JkLmRhdGEgPSB7fTsgLy8gbm8gZGF0YSB0byBzdG9yZSB5ZXQsIGp1c3QgbmVlZHMgdG8gYmUgdHJ1dGh5IHRvIGluZGljYXRlIHRoYXQgaW5pdGlhbGl6YXRpb24gcmFuXG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUV2ZW50RW1pdHRlcigpIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbSA9IHtcbiAgICAgIGNvdW50OiAwLCAvLyBob3cgbWFueSBldmVudHMgaGF2ZSBvY2N1cnJlZCBvbiB0aGlzIHN0cmVhbVxuICAgICAgbGF0ZXN0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB9XG5cbiAgICByZWNvcmQuZGF0YSA9IHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIGVtaXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNsb3NlcyBvdmVyIHRoZSBzdHJlYW0gdmFyaWFibGVcbiAgICAgICAgc3RyZWFtLmxhdGVzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHN0cmVhbS5jb3VudCsrO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIFtyZWNvcmQuZGF0YS5zdHJlYW0sIHJlY29yZC5kYXRhLmVtaXRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRXZlbnRSZWNlaXZlcihzdHJlYW0pIHtcbiAgY29uc3QgY3R4ID0gZ2V0VG9wVXBkYXRpbmdFeGVjdXRpb25Db250ZXh0KCk7XG4gIGNvbnN0IHJlY29yZCA9IGN0eC5fYmVnaW5Ib29rKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSByZWNvcmQgZGF0YSBpZiBuZWNlc3NhcnlcbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIHJlY29yZC5kYXRhID0ge1xuICAgICAgc3RyZWFtLCAvLyB0aGUgc3RyZWFtIHdlIGFyZSByZWNlaXZpbmcgb25cbiAgICAgIGxhc3RTZWVuTnVtYmVyOiBzdHJlYW0uY291bnQsXG4gICAgfTtcbiAgfVxuXG4gIC8vIFRPRE86IFdlIGNvdWxkIHN1cHBvcnQgdGhpcywganVzdCBuZWVkIHRvIGNvbnNpZGVyIGRldGFpbHMuXG4gIGlmIChzdHJlYW0gIT09IHJlY29yZC5kYXRhLnN0cmVhbSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXZlbnQgcmVjZWl2ZXIgZm91bmQgdGhhdCBzdHJlYW0gb2JqZWN0IGNoYW5nZWQgaWRlbnRpdHknKTtcbiAgfVxuXG4gIGxldCBib3hlZEV2ZW50O1xuXG4gIGlmIChyZWNvcmQuZGF0YS5sYXN0U2Vlbk51bWJlciA9PT0gc3RyZWFtLmNvdW50KSB7XG4gICAgLy8gVGhlcmUgaGF2ZSBub3QgYmVlbiBhbnkgbmV3IGV2ZW50cyBvbiB0aGUgc3RyZWFtXG4gIH0gZWxzZSBpZiAocmVjb3JkLmRhdGEubGFzdFNlZW5OdW1iZXIgPT09IChzdHJlYW0uY291bnQgLSAxKSkge1xuICAgIC8vIFRoZXJlIGhhcyBiZWVuIGV4YWN0bHkgb25lIG5ldyBldmVudCBvbiB0aGUgc3RyZWFtIHRoYXQgd2UgaGF2ZW4ndCBzZWVuIHlldC5cbiAgICBib3hlZEV2ZW50ID0ge3ZhbHVlOiBzdHJlYW0ubGF0ZXN0VmFsdWV9O1xuICAgIHJlY29yZC5kYXRhLmxhc3RTZWVuTnVtYmVyKys7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCByZWNlaXZlciBnb3QgdG9vIG1hbnkgZXZlbnRzIG9yIG1pc3NlZCBzb21lJyk7XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gYm94ZWRFdmVudDtcbn1cblxuLyoqXG4gKiBUaGUgc3RyZWFtRnVuYyBhcmd1bWVudCBtYXkgY2hhbmdlLCBidXQgaXQgc2hvdWxkIG9ubHkgY2hhbmdlIHRvIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgc2FmZWx5XG4gKiBzd2FwcGVkIGluIChpLmUuIG9uZSB0aGF0IGNhbGxzIHRoZSBzYW1lIGhvb2tzLCBldGMuKS4gQSBjb21tb24gY2FzZSBpcyB0aGF0IHN0cmVhbUZ1bmMgaXMgYVxuICogY2xvc3VyZSB0aGF0IHJlZmVyZW5jZXMgc29tZSBvdXRlciBzY29wZSB2YXJpYWJsZXMsIGFuZCB3aGVuIHRob3NlIGNoYW5nZSwgYSBuZXcgXCJ2ZXJzaW9uXCIgb2ZcbiAqIHRoZSBmdW5jdGlvbiBpcyBjcmVhdGVkIChsZXhpY2FsbHkgdGhlIHNhbWUsIGJ1dCBjbG9zaW5nIG92ZXIgYSBkaWZmZXJlbnQgc2NvcGUpLlxuICpcbiAqIG9uUmVxdWVzdFVwZGF0ZSBpcyBjdXJyZW50bHkgb25seSByZWFkIG9uIHRoZSBmaXJzdCBjYWxsLCBzbyBjaGFuZ2VzIHRvIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEeW5hbWljKHN0cmVhbUZ1bmMsIG9uUmVxdWVzdFVwZGF0ZSkge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICAvLyBJbml0aWFsaXplIHJlY29yZCBkYXRhIGlmIG5lY2Vzc2FyeVxuICBpZiAoIXJlY29yZC5kYXRhKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuXG4gICAgLy8gSWYgbm8gb25SZXF1ZXN0VXBkYXRlIGlzIHByb3ZpZGVkLCBkZWZhdWx0IHRvIHJlcXVlc3RpbmcgdXBkYXRlIG9uIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICBjb25zdCBvcnUgPSBvblJlcXVlc3RVcGRhdGUgfHwgKCgpID0+IHtcbiAgICAgIGN0eC5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gVHJhY2sgRXhlY3V0aW9uQ29udGV4dHMgY3JlYXRlZCAoYW5kIG5vdCB5ZXQgdGVybWluYXRlZCkgc28gd2UgY2FuIHRlcm1pbmF0ZSB0aGVtIHVwb24gY2xlYW51cFxuICAgIGRhdGEuYWN0aXZlQ29udGV4dHMgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBDcmVhdGUgXCJmYWN0b3J5XCIgZnVuY3Rpb24gdG8gaW5zdGFudGlhdGUgbmV3IGNvbnRleHRzXG4gICAgZGF0YS5jcmVhdGVDb250ZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgY3R4ID0gbmV3IEV4ZWN1dGlvbkNvbnRleHQoZGF0YS5zdHJlYW1GdW5jLCBvcnUsICgpID0+IHsgZGF0YS5hY3RpdmVDb250ZXh0cy5kZWxldGUoY3R4KTsgfSk7XG4gICAgICBkYXRhLmFjdGl2ZUNvbnRleHRzLmFkZChjdHgpO1xuICAgICAgcmV0dXJuIGN0eDtcbiAgICB9O1xuXG4gICAgcmVjb3JkLmRhdGEgPSBkYXRhO1xuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjdHggb2YgZGF0YS5hY3RpdmVDb250ZXh0cykge1xuICAgICAgICBjdHgudGVybWluYXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgc3RyZWFtIGZ1bmN0aW9uIGluIHJlY29yZCBhbmQgYWxsIGFjdGl2ZSBjb250ZXh0cy5cbiAgcmVjb3JkLmRhdGEuc3RyZWFtRnVuYyA9IHN0cmVhbUZ1bmM7XG4gIGZvciAoY29uc3QgY3R4IG9mIHJlY29yZC5kYXRhLmFjdGl2ZUNvbnRleHRzKSB7XG4gICAgY3R4Ll9zZXRTdHJlYW1GdW5jKHN0cmVhbUZ1bmMpO1xuICB9XG5cbiAgY3R4Ll9lbmRIb29rKCk7XG5cbiAgcmV0dXJuIHJlY29yZC5kYXRhLmNyZWF0ZUNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKGFjdGlvbkV2dHMsIHJlZHVjZXJGdW5jLCBpbml0aWFsU3RhdGUpIHtcbiAgY29uc3Qgc3RhdGUgPSB1c2VWYXIoaW5pdGlhbFN0YXRlKTtcbiAgY29uc3QgYWN0aW9uID0gdXNlRXZlbnRSZWNlaXZlcihhY3Rpb25FdnRzKTtcbiAgc3RhdGUuY3VycmVudCA9IHJlZHVjZXJGdW5jKGFjdGlvbiwgc3RhdGUuY3VycmVudCk7XG4gIHJldHVybiBzdGF0ZS5jdXJyZW50O1xufVxuXG4vKipcbiAqIFRPRE86IENvdWxkL3Nob3VsZCB0aGlzIHRha2UgYW4gb3B0aW9uYWwgb25SZXF1ZXN0VXBkYXRlIHBhcmFtZXRlcj9cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hY2hpbmUoc3RhdGVzLCBpbml0aWFsVHJhbnNpdGlvbikge1xuICBjb25zdCBjdHggPSBnZXRUb3BVcGRhdGluZ0V4ZWN1dGlvbkNvbnRleHQoKTtcbiAgY29uc3QgcmVjb3JkID0gY3R4Ll9iZWdpbkhvb2soKTtcblxuICBjb25zdCB0YWtlVHJhbnNpdGlvbiA9ICh0cmFucykgPT4ge1xuICAgIC8vIElmIHRoZXJlJ3MgYW4gb2xkIGNvbnRleHQsIHRlcm1pbmF0ZSBpdFxuICAgIGlmIChyZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0KSB7XG4gICAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IFtuZXdTdGF0ZSwgbmV3U3RhdGVBcmddID0gdHJhbnM7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCBhbmQgc3RvcmUgaXQgaW4gcmVjb3JkIChidXQgZG9uJ3QgdXBkYXRlIGl0KVxuICAgIGNvbnN0IG5ld0N0eCA9IG5ldyBFeGVjdXRpb25Db250ZXh0KHN0YXRlc1tuZXdTdGF0ZV0sICgpID0+IHsgY3R4Ll9yZXF1ZXN0VXBkYXRlKCk7IH0pO1xuXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0ID0gbmV3Q3R4O1xuICAgIHJlY29yZC5kYXRhLmFjdGl2ZUFyZ3VtZW50ID0gbmV3U3RhdGVBcmc7XG4gIH07XG5cbiAgaWYgKCFyZWNvcmQuZGF0YSkge1xuICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICByZWNvcmQuZGF0YSA9IGRhdGE7XG5cbiAgICB0YWtlVHJhbnNpdGlvbihpbml0aWFsVHJhbnNpdGlvbik7IC8vIHRoaXMgd2lsbCBzZXQgc3R1ZmYgaW4gcmVjb3JkLmRhdGFcblxuICAgIHJlY29yZC5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgZGF0YS5hY3RpdmVDb250ZXh0LnRlcm1pbmF0ZSgpO1xuICAgIH07XG4gIH1cblxuICBsZXQgcmV0dmFsO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFNldCB0aGUgc3RhdGUgZnVuY3Rpb24gaW4gdGhlIGFjdGl2ZSBjb250ZXh0IChpbiBjYXNlIGl0IGNoYW5nZWQpXG4gICAgcmVjb3JkLmRhdGEuYWN0aXZlQ29udGV4dC5fc2V0U3RyZWFtRnVuYyhzdGF0ZXNbcmVjb3JkLmRhdGEuYWN0aXZlU3RhdGVdKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYWN0aXZlIGNvbnRleHRcbiAgICBjb25zdCBbdG1wUmV0dmFsLCB0cmFuc2l0aW9uRXZ0c10gPSByZWNvcmQuZGF0YS5hY3RpdmVDb250ZXh0LnVwZGF0ZShyZWNvcmQuZGF0YS5hY3RpdmVBcmd1bWVudCk7XG4gICAgcmV0dmFsID0gdG1wUmV0dmFsO1xuXG4gICAgLy8gV2FzIHRoZXJlIGEgdHJhbnNpdGlvbiBldmVudD9cbiAgICAvLyBOT1RFOiBCZWNhdXNlIHdlIHRyYW5zaXRpb24gdXBvbiBmaXJzdCBldmVuIG9uIHRoaXMgc3RyZWFtLCB3ZSBjYW4gc29ydCBvZiBzcGVjaWFsLWNhc2UgdGhpcyBjaGVja1xuICAgIGlmICh0cmFuc2l0aW9uRXZ0cy5jb3VudCkge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25FdnRzLmxhdGVzdFZhbHVlO1xuICAgICAgdGFrZVRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlIHdhcyBubyB0cmFuc2l0aW9uXG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjdHguX2VuZEhvb2soKTtcblxuICByZXR1cm4gcmV0dmFsO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/riv.js\nvar riv = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/programs.js\n// NOTE: Using require instead of import here makes the thing where we print program text work better.\nconst {\n  useVar,\n  useRequestUpdate,\n  useInitialize,\n  useEventEmitter,\n  useEventReceiver,\n  useDynamic,\n  useReducer,\n  useMachine\n} = __webpack_require__(0);\n\nfunction showString(v) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'border: 1px solid red; color: black; font-size: 24px; padding: 5px; margin-top: 20px';\n    elem.current.textContent = '(undefined)';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  elem.current.textContent = 'showString: ' + (v === undefined ? '(undefined)' : v.toString());\n}\n\nfunction animationTime() {\n  const requestUpdate = useRequestUpdate();\n  const time = useVar();\n  const reqId = useVar();\n  useInitialize(() => {\n    const onFrame = t => {\n      time.current = 0.001 * t;\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    time.current = 0.001 * performance.now();\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return time.current;\n}\n\nfunction animationFrameEvts() {\n  const requestUpdate = useRequestUpdate();\n  const reqId = useVar();\n  const [frameEvts, emitFrame] = useEventEmitter();\n  useInitialize(() => {\n    const onFrame = t => {\n      emitFrame();\n      reqId.current = requestAnimationFrame(onFrame); // request another\n\n      requestUpdate();\n    };\n\n    reqId.current = requestAnimationFrame(onFrame);\n    return () => {\n      // cleanup\n      cancelAnimationFrame(reqId.current);\n    };\n  });\n  return frameEvts;\n}\n\nfunction countEvents(evts) {\n  const count = useVar(0);\n  const event = useEventReceiver(evts);\n\n  if (event) {\n    count.current++;\n  }\n\n  return count.current;\n}\n\nfunction mouseClickEvts() {\n  const requestUpdate = useRequestUpdate();\n  const [clickEvts, emitClick] = useEventEmitter();\n  useInitialize(() => {\n    const onMouseDown = () => {\n      emitClick();\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n    };\n  });\n  return clickEvts;\n}\n\nfunction mouseDown() {\n  const requestUpdate = useRequestUpdate();\n  const isDown = useVar(false); // we can't poll down-ness, so we assume it's initially not down\n\n  useInitialize(() => {\n    const onMouseDown = () => {\n      isDown.current = true;\n      requestUpdate();\n    };\n\n    const onMouseUp = () => {\n      isDown.current = false;\n      requestUpdate();\n    };\n\n    document.addEventListener('mousedown', onMouseDown);\n    document.addEventListener('mouseup', onMouseUp);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousedown', onMouseDown);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  });\n  return isDown.current;\n}\n\nfunction mousePosition() {\n  const requestUpdate = useRequestUpdate();\n  const position = useVar({\n    x: 0,\n    y: 0\n  }); // we can't poll position, so start it at origin\n\n  useInitialize(() => {\n    const onMouseMove = e => {\n      position.current = {\n        x: e.clientX || e.pageX,\n        y: e.clientY || e.pageY\n      };\n      requestUpdate();\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    return () => {\n      // cleanup\n      document.removeEventListener('mousemove', onMouseMove);\n    };\n  });\n  return position.current;\n}\n\nfunction random(repickEvts) {\n  const val = useVar(Math.random());\n  const repick = useEventReceiver(repickEvts);\n\n  if (repick) {\n    val.current = Math.random();\n  }\n\n  return val.current;\n}\n\nfunction audioDriver(generator) {\n  const createGenerator = useDynamic(generator);\n  const generatorCtx = useVar();\n  const frameCount = useVar(0);\n  const sampleRate = useVar();\n  const [advanceFrameEvts, emitAdvanceFrame] = useEventEmitter();\n  useInitialize(() => {\n    generatorCtx.current = createGenerator();\n    const BUFFER_SIZE = 1024;\n    const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n    const scriptNode = audioContext.createScriptProcessor(BUFFER_SIZE, 0, 1); // 0 input channels, 1 output channel\n\n    scriptNode.onaudioprocess = e => {\n      const buffer = e.outputBuffer.getChannelData(0);\n\n      for (let i = 0; i < buffer.length; i++) {\n        emitAdvanceFrame({});\n        buffer[i] = generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current);\n        frameCount.current++;\n      }\n    };\n\n    scriptNode.connect(audioContext.destination);\n    sampleRate.current = audioContext.sampleRate;\n    return () => {\n      scriptNode.disconnect();\n      audioContext.close();\n    };\n  });\n  /**\n   * Most of our generator updating will happen in the audio processing callback above.\n   * This update here is for when the audioDriver update is called, e.g. when an outer scope\n   * reference that the generator depends on has changed. So we must update the generator,\n   * but don't need its output amplitude.\n   */\n\n  generatorCtx.current.update(frameCount.current / sampleRate.current, advanceFrameEvts, sampleRate.current); // NOTE: we discard retval\n}\n\nfunction sampleUpon(toSample, uponEvts, initialValue) {\n  const held = useVar(initialValue);\n  const upon = useEventReceiver(uponEvts);\n\n  if (upon) {\n    held.current = toSample;\n  }\n\n  return held.current;\n}\n\nfunction everySecond() {\n  const requestUpdate = useRequestUpdate();\n  const [tickEvts, emitTick] = useEventEmitter();\n  useInitialize(() => {\n    const onInterval = () => {\n      emitTick();\n      requestUpdate();\n    };\n\n    const timerId = setInterval(onInterval, 1000);\n    return () => {\n      // cleanup\n      clearInterval(timerId);\n    };\n  });\n  return tickEvts;\n}\n/**\n * Until audio is loaded and decoded, a single-sample buffer of silence is returned.\n */\n\n\nfunction loadAudioAsArray(url) {\n  const requestUpdate = useRequestUpdate();\n  const pcm = useVar([0]); // until loaded, just return single sample of silence\n\n  useInitialize(() => {\n    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n    let cleanedUp = false;\n    const request = new XMLHttpRequest();\n    request.open('GET', url, true);\n    request.responseType = 'arraybuffer';\n\n    request.onload = () => {\n      const audioData = request.response;\n      audioCtx.decodeAudioData(audioData, buffer => {\n        if (!cleanedUp) {\n          pcm.current = buffer.getChannelData(0);\n          requestUpdate();\n        }\n      });\n    };\n\n    request.send();\n    return () => {\n      // cleanup\n      request.abort(); // it's safe to always abort here. if already completed, it will be ignored\n      // decodeAudioData cannot be canceled. So to be correct, we must set a flag here to make sure\n      // that decoding is ignored\n\n      cleanedUp = true;\n    };\n  });\n  return pcm.current;\n}\n\nfunction consoleLog(v) {\n  console.log(v);\n}\n\nfunction integral(integrandFunc, time, initialValue = 0) {\n  const accum = useVar(initialValue);\n  const prevTime = useVar(time);\n  const integrand = integrandFunc(accum.current, prevTime.current);\n  accum.current += (time - prevTime.current) * integrand;\n  prevTime.current = time;\n  return accum.current;\n}\n\nfunction expFollow(targetValue, speedConstant, time, initialValue) {\n  return integral(currentValue => speedConstant * (targetValue - currentValue), time, initialValue);\n}\n\nfunction redCircle(position, radius = 25) {\n  const elem = useVar(null);\n  useInitialize(() => {\n    elem.current = document.createElement('div');\n    elem.current.style.cssText = 'position: absolute; border-radius: 50%; background: red; pointer-events: none; user-select: none';\n    document.body.appendChild(elem.current);\n    return () => {\n      // cleanup\n      document.body.removeChild(elem.current);\n    };\n  });\n  const p = position || {\n    x: 0,\n    y: 0\n  };\n\n  if (radius < 0) {\n    radius = 0;\n  }\n\n  const halfRadius = 0.5 * radius;\n  elem.current.style.left = p.x - halfRadius + 'px';\n  elem.current.style.top = p.y - halfRadius + 'px';\n  elem.current.style.width = radius + 'px';\n  elem.current.style.height = radius + 'px';\n}\n\nfunction followAtSpeed2d(target, speed, time, initial) {\n  const pos = useVar(initial);\n  const prevTime = useVar(time);\n  const dt = time - prevTime.current;\n  const delta = {\n    x: target.x - pos.current.x,\n    y: target.y - pos.current.y\n  };\n  const dist = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n\n  if (speed * dt >= dist) {\n    // Jump to target position\n    pos.current = target;\n  } else {\n    // NOTE: We must not mutate pos.current, since we return that\n    pos.current = {\n      x: pos.current.x + dt * speed * delta.x / dist,\n      y: pos.current.y + dt * speed * delta.y / dist\n    };\n  }\n\n  prevTime.current = time;\n  return pos.current;\n}\n/**\n * Note that this _will_ fire in first call if condition starts truthy\n */\n\n\nfunction eventWhen(condition, valueToEmit) {\n  const [evts, emit] = useEventEmitter();\n  const prevCondition = useVar(false);\n  const bcond = !!condition;\n\n  if (bcond && !prevCondition.current) {\n    emit(valueToEmit);\n  }\n\n  prevCondition.current = bcond;\n  return evts;\n}\n/**\n * Note that seconds argument is only read initially. But valueToEmit is re-read on changes\n */\n\n\nfunction eventAfter(seconds, valueToEmit) {\n  const [evts, emit] = useEventEmitter();\n  const value = useVar(valueToEmit);\n  value.current = valueToEmit;\n  useInitialize(() => {\n    const timerId = setTimeout(() => {\n      emit(value.current);\n    }, 1000 * seconds);\n    return () => {\n      clearTimeout(timerId);\n    };\n  });\n  return evts;\n}\n\nfunction neverEvts() {\n  const [evts, emit] = useEventEmitter();\n  return evts;\n}\n\n/* harmony default export */ var programs = ([{\n  name: 'do nothing',\n  main: () => {}\n}, {\n  name: 'animation time',\n  main: () => {\n    showString(animationTime().toFixed(3));\n  }\n}, {\n  name: 'count clicks',\n  main: () => {\n    showString(countEvents(mouseClickEvts()));\n  }\n}, {\n  name: 'is mouse button down',\n  main: () => {\n    showString(mouseDown());\n  }\n}, {\n  name: 'random number, click to repick',\n  main: () => {\n    showString(random(mouseClickEvts()));\n  }\n}, {\n  name: 'audio noise when mouse is down',\n  main: () => {\n    const md = mouseDown();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      return md ? noise : 0;\n    });\n  }\n}, {\n  name: 'decaying noise upon click',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    audioDriver((audioTime, advanceFrameEvts) => {\n      const noise = random(advanceFrameEvts) - 0.5;\n      const lastClickTime = sampleUpon(audioTime, clickEvts, -Infinity);\n      const decayingGain = Math.exp(5 * (lastClickTime - audioTime));\n      return decayingGain * noise;\n    });\n  }\n}, {\n  name: 'resetting frame counter, click to reset',\n  main: () => {\n    const frameEvts = animationFrameEvts();\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createCounter = useDynamic(countEvents);\n    const activeCounter = useVar();\n\n    if (click) {\n      if (activeCounter.current) {\n        activeCounter.current.terminate();\n      }\n\n      activeCounter.current = createCounter();\n    }\n\n    if (!activeCounter.current) {\n      activeCounter.current = createCounter();\n    }\n\n    const displayedCount = activeCounter.current.update(frameEvts);\n    showString(displayedCount);\n  }\n}, {\n  name: 'dynamic array of async clocks, click to add',\n  main: () => {\n    const clickEvts = mouseClickEvts();\n    const click = useEventReceiver(clickEvts);\n    const createClock = useDynamic(() => countEvents(everySecond()));\n    const clockArray = useVar([]);\n\n    if (click) {\n      clockArray.current.push(createClock());\n    }\n\n    const nums = clockArray.current.map(clock => clock.update());\n    showString(nums.join(' '));\n  }\n}, {\n  name: 'record player spin up/down, hold mouse down and release',\n  main: () => {\n    const pcm = loadAudioAsArray('amen_break.mp3');\n    showString(pcm.length > 1 ? 'loaded audio' : 'loading audio...');\n    audioDriver((audioTime, advanceFrameEvts, sampleRate) => {\n      const targetSpeed = mouseDown() ? sampleRate : 0;\n      const speed = expFollow(targetSpeed, 3, audioTime, 0);\n      const pos = Math.floor(integral(() => speed, audioTime));\n      return pcm[pos % pcm.length]; // modulo so as to loop\n    });\n  }\n}, {\n  name: 'circle follows mouse',\n  main: () => {\n    redCircle(mousePosition());\n  }\n}, {\n  name: 'circle follows mouse at limited speed',\n  main: () => {\n    const time = animationTime();\n    const mpos = mousePosition();\n    redCircle(followAtSpeed2d(mpos, 300, time, mpos));\n  }\n}, {\n  name: 'circle moves halfway to mouse with each click',\n  main: () => {\n    const midpoint = (a, b) => ({\n      x: 0.5 * (a.x + b.x),\n      y: 0.5 * (a.y + b.y)\n    });\n\n    const mpos = mousePosition();\n    const clickEvts = mouseClickEvts();\n    const cpos = useReducer(clickEvts, (action, prevState) => {\n      return action ? midpoint(prevState, mpos) : prevState;\n    }, {\n      x: 0,\n      y: 0\n    });\n    redCircle(cpos);\n  }\n}, {\n  name: 'roaming circle (state machine)',\n  main: () => {\n    const time = animationTime();\n    const position = useMachine({\n      moving: initialPosition => {\n        const targetPosition = {\n          x: 500 * random(neverEvts()),\n          y: 500 * random(neverEvts())\n        };\n        const position = followAtSpeed2d(targetPosition, 300, time, initialPosition);\n        const arrived = position.x === targetPosition.x && position.y === targetPosition.y;\n        return [position, eventWhen(arrived, ['resting', position])];\n      },\n      resting: initialPosition => {\n        return [initialPosition, eventAfter(random(neverEvts()), ['moving', initialPosition])];\n      }\n    }, ['moving', {\n      x: 0,\n      y: 0\n    }]);\n    redCircle(position);\n  }\n}]);\n// CONCATENATED MODULE: ./src/index.js\n\n\nconst programListElem = document.getElementById('program-list');\nconst programSourceElem = document.getElementById('program-source');\nlet currentContext; // NOTE: This is a hack but works for now\n\nconst fixIndent = code => {\n  return code.split('\\n').map((line, idx) => idx === 0 ? line : line.substr(2)).join('\\n');\n};\n\nconst startProgram = program => {\n  if (currentContext) {\n    currentContext.terminate();\n    currentContext = undefined;\n  }\n\n  programSourceElem.textContent = fixIndent(program.main.toString()); // hacky but works for now\n\n  currentContext = Object(riv[\"createNoInOutExecutionContext\"])(program.main);\n  currentContext.update(); // do initial update. any further updates will be async\n};\n\nfor (const prog of programs) {\n  const anchorElem = document.createElement('a');\n  anchorElem.textContent = prog.name;\n  anchorElem.setAttribute('href', '#');\n\n  (() => {\n    anchorElem.addEventListener('click', e => {\n      e.preventDefault();\n      setTimeout(() => {\n        // start program with delay so it doesn't get this click event\n        startProgram(prog);\n      }, 0);\n    });\n  })();\n\n  const itemElem = document.createElement('li');\n  itemElem.appendChild(anchorElem);\n  programListElem.appendChild(itemElem);\n}\n\nstartProgram(programs[0]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcHJvZ3JhbXMuanM/NWMyYSIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJuYW1lcyI6WyJ1c2VWYXIiLCJ1c2VSZXF1ZXN0VXBkYXRlIiwidXNlSW5pdGlhbGl6ZSIsInVzZUV2ZW50RW1pdHRlciIsInVzZUV2ZW50UmVjZWl2ZXIiLCJ1c2VEeW5hbWljIiwidXNlUmVkdWNlciIsInVzZU1hY2hpbmUiLCJyZXF1aXJlIiwic2hvd1N0cmluZyIsInYiLCJlbGVtIiwiY3VycmVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsInRleHRDb250ZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJ1bmRlZmluZWQiLCJ0b1N0cmluZyIsImFuaW1hdGlvblRpbWUiLCJyZXF1ZXN0VXBkYXRlIiwidGltZSIsInJlcUlkIiwib25GcmFtZSIsInQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwZXJmb3JtYW5jZSIsIm5vdyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiYW5pbWF0aW9uRnJhbWVFdnRzIiwiZnJhbWVFdnRzIiwiZW1pdEZyYW1lIiwiY291bnRFdmVudHMiLCJldnRzIiwiY291bnQiLCJldmVudCIsIm1vdXNlQ2xpY2tFdnRzIiwiY2xpY2tFdnRzIiwiZW1pdENsaWNrIiwib25Nb3VzZURvd24iLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm1vdXNlRG93biIsImlzRG93biIsIm9uTW91c2VVcCIsIm1vdXNlUG9zaXRpb24iLCJwb3NpdGlvbiIsIngiLCJ5Iiwib25Nb3VzZU1vdmUiLCJlIiwiY2xpZW50WCIsInBhZ2VYIiwiY2xpZW50WSIsInBhZ2VZIiwicmFuZG9tIiwicmVwaWNrRXZ0cyIsInZhbCIsIk1hdGgiLCJyZXBpY2siLCJhdWRpb0RyaXZlciIsImdlbmVyYXRvciIsImNyZWF0ZUdlbmVyYXRvciIsImdlbmVyYXRvckN0eCIsImZyYW1lQ291bnQiLCJzYW1wbGVSYXRlIiwiYWR2YW5jZUZyYW1lRXZ0cyIsImVtaXRBZHZhbmNlRnJhbWUiLCJCVUZGRVJfU0laRSIsImF1ZGlvQ29udGV4dCIsIndpbmRvdyIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsInNjcmlwdE5vZGUiLCJjcmVhdGVTY3JpcHRQcm9jZXNzb3IiLCJvbmF1ZGlvcHJvY2VzcyIsImJ1ZmZlciIsIm91dHB1dEJ1ZmZlciIsImdldENoYW5uZWxEYXRhIiwiaSIsImxlbmd0aCIsInVwZGF0ZSIsImNvbm5lY3QiLCJkZXN0aW5hdGlvbiIsImRpc2Nvbm5lY3QiLCJjbG9zZSIsInNhbXBsZVVwb24iLCJ0b1NhbXBsZSIsInVwb25FdnRzIiwiaW5pdGlhbFZhbHVlIiwiaGVsZCIsInVwb24iLCJldmVyeVNlY29uZCIsInRpY2tFdnRzIiwiZW1pdFRpY2siLCJvbkludGVydmFsIiwidGltZXJJZCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImxvYWRBdWRpb0FzQXJyYXkiLCJ1cmwiLCJwY20iLCJhdWRpb0N0eCIsImNsZWFuZWRVcCIsInJlcXVlc3QiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJvbmxvYWQiLCJhdWRpb0RhdGEiLCJyZXNwb25zZSIsImRlY29kZUF1ZGlvRGF0YSIsInNlbmQiLCJhYm9ydCIsImNvbnNvbGVMb2ciLCJjb25zb2xlIiwibG9nIiwiaW50ZWdyYWwiLCJpbnRlZ3JhbmRGdW5jIiwiYWNjdW0iLCJwcmV2VGltZSIsImludGVncmFuZCIsImV4cEZvbGxvdyIsInRhcmdldFZhbHVlIiwic3BlZWRDb25zdGFudCIsImN1cnJlbnRWYWx1ZSIsInJlZENpcmNsZSIsInJhZGl1cyIsInAiLCJoYWxmUmFkaXVzIiwibGVmdCIsInRvcCIsIndpZHRoIiwiaGVpZ2h0IiwiZm9sbG93QXRTcGVlZDJkIiwidGFyZ2V0Iiwic3BlZWQiLCJpbml0aWFsIiwicG9zIiwiZHQiLCJkZWx0YSIsImRpc3QiLCJzcXJ0IiwiZXZlbnRXaGVuIiwiY29uZGl0aW9uIiwidmFsdWVUb0VtaXQiLCJlbWl0IiwicHJldkNvbmRpdGlvbiIsImJjb25kIiwiZXZlbnRBZnRlciIsInNlY29uZHMiLCJ2YWx1ZSIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJuZXZlckV2dHMiLCJuYW1lIiwibWFpbiIsInRvRml4ZWQiLCJtZCIsImF1ZGlvVGltZSIsIm5vaXNlIiwibGFzdENsaWNrVGltZSIsIkluZmluaXR5IiwiZGVjYXlpbmdHYWluIiwiZXhwIiwiY2xpY2siLCJjcmVhdGVDb3VudGVyIiwiYWN0aXZlQ291bnRlciIsInRlcm1pbmF0ZSIsImRpc3BsYXllZENvdW50IiwiY3JlYXRlQ2xvY2siLCJjbG9ja0FycmF5IiwicHVzaCIsIm51bXMiLCJtYXAiLCJjbG9jayIsImpvaW4iLCJ0YXJnZXRTcGVlZCIsImZsb29yIiwibXBvcyIsIm1pZHBvaW50IiwiYSIsImIiLCJjcG9zIiwiYWN0aW9uIiwicHJldlN0YXRlIiwibW92aW5nIiwiaW5pdGlhbFBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJhcnJpdmVkIiwicmVzdGluZyIsInByb2dyYW1MaXN0RWxlbSIsImdldEVsZW1lbnRCeUlkIiwicHJvZ3JhbVNvdXJjZUVsZW0iLCJjdXJyZW50Q29udGV4dCIsImZpeEluZGVudCIsImNvZGUiLCJzcGxpdCIsImxpbmUiLCJpZHgiLCJzdWJzdHIiLCJzdGFydFByb2dyYW0iLCJwcm9ncmFtIiwiY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQiLCJwcm9nIiwicHJvZ3JhbXMiLCJhbmNob3JFbGVtIiwic2V0QXR0cmlidXRlIiwicHJldmVudERlZmF1bHQiLCJpdGVtRWxlbSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQSxNQUFNO0FBQUVBLFFBQUY7QUFBVUMsa0JBQVY7QUFBNEJDLGVBQTVCO0FBQTJDQyxpQkFBM0M7QUFBNERDLGtCQUE1RDtBQUE4RUMsWUFBOUU7QUFB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aEM7O0FBQ0EsR0FBQyxNQUFNO0FBQ0xELGNBQVUsQ0FBQ3RLLGdCQUFYLENBQTRCLE9BQTVCLEVBQXNDVSxDQUFELElBQU87QUFDMUNBLE9BQUMsQ0FBQzhKLGNBQUY7QUFDQXhELGdCQUFVLENBQUMsTUFBTTtBQUFFO0FBQ2pCaUQsb0JBQVksQ0FBQ0csSUFBRCxDQUFaO0FBQ0QsT0FGUyxFQUVQLENBRk8sQ0FBVjtBQUdELEtBTEQ7QUFNRCxHQVBEOztBQVNBLFFBQU1LLFFBQVEsR0FBR3hNLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixJQUF2QixDQUFqQjtBQUNBdU0sVUFBUSxDQUFDbE0sV0FBVCxDQUFxQitMLFVBQXJCO0FBRUFmLGlCQUFlLENBQUNoTCxXQUFoQixDQUE0QmtNLFFBQTVCO0FBQ0Q7O0FBRURSLFlBQVksQ0FBQ0ksUUFBUSxDQUFDLENBQUQsQ0FBVCxDQUFaIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOT1RFOiBVc2luZyByZXF1aXJlIGluc3RlYWQgb2YgaW1wb3J0IGhlcmUgbWFrZXMgdGhlIHRoaW5nIHdoZXJlIHdlIHByaW50IHByb2dyYW0gdGV4dCB3b3JrIGJldHRlci5cbmNvbnN0IHsgdXNlVmFyLCB1c2VSZXF1ZXN0VXBkYXRlLCB1c2VJbml0aWFsaXplLCB1c2VFdmVudEVtaXR0ZXIsIHVzZUV2ZW50UmVjZWl2ZXIsIHVzZUR5bmFtaWMsIHVzZVJlZHVjZXIsIHVzZU1hY2hpbmUgfSA9IHJlcXVpcmUoJy4vcml2Jyk7XG5cbmZ1bmN0aW9uIHNob3dTdHJpbmcodikge1xuICBjb25zdCBlbGVtID0gdXNlVmFyKG51bGwpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGVsZW0uY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW0uY3VycmVudC5zdHlsZS5jc3NUZXh0ID0gJ2JvcmRlcjogMXB4IHNvbGlkIHJlZDsgY29sb3I6IGJsYWNrOyBmb250LXNpemU6IDI0cHg7IHBhZGRpbmc6IDVweDsgbWFyZ2luLXRvcDogMjBweCc7XG4gICAgZWxlbS5jdXJyZW50LnRleHRDb250ZW50ID0gJyh1bmRlZmluZWQpJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0uY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW0uY3VycmVudCk7XG4gICAgfVxuICB9KVxuXG4gIGVsZW0uY3VycmVudC50ZXh0Q29udGVudCA9ICdzaG93U3RyaW5nOiAnICsgKCh2ID09PSB1bmRlZmluZWQpID8gJyh1bmRlZmluZWQpJyA6IHYudG9TdHJpbmcoKSk7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGlvblRpbWUoKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IHRpbWUgPSB1c2VWYXIoKTtcbiAgY29uc3QgcmVxSWQgPSB1c2VWYXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBvbkZyYW1lID0gKHQpID0+IHtcbiAgICAgIHRpbWUuY3VycmVudCA9IDAuMDAxKnQ7XG4gICAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpOyAvLyByZXF1ZXN0IGFub3RoZXJcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9O1xuXG4gICAgdGltZS5jdXJyZW50ID0gMC4wMDEqcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcmVxSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvbkZyYW1lKTtcblxuICAgIHJldHVybiAoKSA9PiB7IC8vIGNsZWFudXBcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcUlkLmN1cnJlbnQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWUuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gYW5pbWF0aW9uRnJhbWVFdnRzKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCByZXFJZCA9IHVzZVZhcigpO1xuICBjb25zdCBbZnJhbWVFdnRzLCBlbWl0RnJhbWVdID0gdXNlRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25GcmFtZSA9ICh0KSA9PiB7XG4gICAgICBlbWl0RnJhbWUoKTtcbiAgICAgIHJlcUlkLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUob25GcmFtZSk7IC8vIHJlcXVlc3QgYW5vdGhlclxuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH07XG5cbiAgICByZXFJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG9uRnJhbWUpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxSWQuY3VycmVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZnJhbWVFdnRzO1xufVxuXG5mdW5jdGlvbiBjb3VudEV2ZW50cyhldnRzKSB7XG4gIGNvbnN0IGNvdW50ID0gdXNlVmFyKDApO1xuICBjb25zdCBldmVudCA9IHVzZUV2ZW50UmVjZWl2ZXIoZXZ0cyk7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgY291bnQuY3VycmVudCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50LmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdXNlQ2xpY2tFdnRzKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBbY2xpY2tFdnRzLCBlbWl0Q2xpY2tdID0gdXNlRXZlbnRFbWl0dGVyKCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSAoKSA9PiB7XG4gICAgICBlbWl0Q2xpY2soKTtcbiAgICAgIHJlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNsaWNrRXZ0cztcbn1cblxuZnVuY3Rpb24gbW91c2VEb3duKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBpc0Rvd24gPSB1c2VWYXIoZmFsc2UpOyAvLyB3ZSBjYW4ndCBwb2xsIGRvd24tbmVzcywgc28gd2UgYXNzdW1lIGl0J3MgaW5pdGlhbGx5IG5vdCBkb3duXG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSAoKSA9PiB7XG4gICAgICBpc0Rvd24uY3VycmVudCA9IHRydWU7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IG9uTW91c2VVcCA9ICgpID0+IHtcbiAgICAgIGlzRG93bi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBvbk1vdXNlVXApO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25Nb3VzZURvd24pO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VVcCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaXNEb3duLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdXNlUG9zaXRpb24oKSB7XG4gIGNvbnN0IHJlcXVlc3RVcGRhdGUgPSB1c2VSZXF1ZXN0VXBkYXRlKCk7XG4gIGNvbnN0IHBvc2l0aW9uID0gdXNlVmFyKHt4OiAwLCB5OiAwfSk7IC8vIHdlIGNhbid0IHBvbGwgcG9zaXRpb24sIHNvIHN0YXJ0IGl0IGF0IG9yaWdpblxuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uTW91c2VNb3ZlID0gKGUpID0+IHtcbiAgICAgIHBvc2l0aW9uLmN1cnJlbnQgPSB7XG4gICAgICAgIHg6IGUuY2xpZW50WCB8fCBlLnBhZ2VYLFxuICAgICAgICB5OiBlLmNsaWVudFkgfHwgZS5wYWdlWSxcbiAgICAgIH07XG4gICAgICByZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuXG4gICAgcmV0dXJuICgpID0+IHsgLy8gY2xlYW51cFxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBvc2l0aW9uLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbShyZXBpY2tFdnRzKSB7XG4gIGNvbnN0IHZhbCA9IHVzZVZhcihNYXRoLnJhbmRvbSgpKTtcbiAgY29uc3QgcmVwaWNrID0gdXNlRXZlbnRSZWNlaXZlcihyZXBpY2tFdnRzKTtcblxuICBpZiAocmVwaWNrKSB7XG4gICAgdmFsLmN1cnJlbnQgPSBNYXRoLnJhbmRvbSgpO1xuICB9XG5cbiAgcmV0dXJuIHZhbC5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBhdWRpb0RyaXZlcihnZW5lcmF0b3IpIHtcbiAgY29uc3QgY3JlYXRlR2VuZXJhdG9yID0gdXNlRHluYW1pYyhnZW5lcmF0b3IpO1xuICBjb25zdCBnZW5lcmF0b3JDdHggPSB1c2VWYXIoKTtcbiAgY29uc3QgZnJhbWVDb3VudCA9IHVzZVZhcigwKTtcbiAgY29uc3Qgc2FtcGxlUmF0ZSA9IHVzZVZhcigpO1xuICBjb25zdCBbYWR2YW5jZUZyYW1lRXZ0cywgZW1pdEFkdmFuY2VGcmFtZV0gPSB1c2VFdmVudEVtaXR0ZXIoKTtcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBnZW5lcmF0b3JDdHguY3VycmVudCA9IGNyZWF0ZUdlbmVyYXRvcigpO1xuXG4gICAgY29uc3QgQlVGRkVSX1NJWkUgPSAxMDI0O1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgIGNvbnN0IHNjcmlwdE5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlU2NyaXB0UHJvY2Vzc29yKEJVRkZFUl9TSVpFLCAwLCAxKTsgLy8gMCBpbnB1dCBjaGFubmVscywgMSBvdXRwdXQgY2hhbm5lbFxuICAgIHNjcmlwdE5vZGUub25hdWRpb3Byb2Nlc3MgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgYnVmZmVyID0gZS5vdXRwdXRCdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbWl0QWR2YW5jZUZyYW1lKHt9KTtcbiAgICAgICAgYnVmZmVyW2ldID0gZ2VuZXJhdG9yQ3R4LmN1cnJlbnQudXBkYXRlKGZyYW1lQ291bnQuY3VycmVudC9zYW1wbGVSYXRlLmN1cnJlbnQsIGFkdmFuY2VGcmFtZUV2dHMsIHNhbXBsZVJhdGUuY3VycmVudCk7XG4gICAgICAgIGZyYW1lQ291bnQuY3VycmVudCsrO1xuICAgICAgfVxuICAgIH07XG4gICAgc2NyaXB0Tm9kZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG5cbiAgICBzYW1wbGVSYXRlLmN1cnJlbnQgPSBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzY3JpcHROb2RlLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGF1ZGlvQ29udGV4dC5jbG9zZSgpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBNb3N0IG9mIG91ciBnZW5lcmF0b3IgdXBkYXRpbmcgd2lsbCBoYXBwZW4gaW4gdGhlIGF1ZGlvIHByb2Nlc3NpbmcgY2FsbGJhY2sgYWJvdmUuXG4gICAqIFRoaXMgdXBkYXRlIGhlcmUgaXMgZm9yIHdoZW4gdGhlIGF1ZGlvRHJpdmVyIHVwZGF0ZSBpcyBjYWxsZWQsIGUuZy4gd2hlbiBhbiBvdXRlciBzY29wZVxuICAgKiByZWZlcmVuY2UgdGhhdCB0aGUgZ2VuZXJhdG9yIGRlcGVuZHMgb24gaGFzIGNoYW5nZWQuIFNvIHdlIG11c3QgdXBkYXRlIHRoZSBnZW5lcmF0b3IsXG4gICAqIGJ1dCBkb24ndCBuZWVkIGl0cyBvdXRwdXQgYW1wbGl0dWRlLlxuICAgKi9cbiAgZ2VuZXJhdG9yQ3R4LmN1cnJlbnQudXBkYXRlKGZyYW1lQ291bnQuY3VycmVudC9zYW1wbGVSYXRlLmN1cnJlbnQsIGFkdmFuY2VGcmFtZUV2dHMsIHNhbXBsZVJhdGUuY3VycmVudCk7IC8vIE5PVEU6IHdlIGRpc2NhcmQgcmV0dmFsXG59XG5cbmZ1bmN0aW9uIHNhbXBsZVVwb24odG9TYW1wbGUsIHVwb25FdnRzLCBpbml0aWFsVmFsdWUpIHtcbiAgY29uc3QgaGVsZCA9IHVzZVZhcihpbml0aWFsVmFsdWUpO1xuICBjb25zdCB1cG9uID0gdXNlRXZlbnRSZWNlaXZlcih1cG9uRXZ0cyk7XG5cbiAgaWYgKHVwb24pIHtcbiAgICBoZWxkLmN1cnJlbnQgPSB0b1NhbXBsZTtcbiAgfVxuXG4gIHJldHVybiBoZWxkLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGV2ZXJ5U2Vjb25kKCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBbdGlja0V2dHMsIGVtaXRUaWNrXSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IG9uSW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgICBlbWl0VGljaygpO1xuICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lcklkID0gc2V0SW50ZXJ2YWwob25JbnRlcnZhbCwgMTAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBjbGVhckludGVydmFsKHRpbWVySWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRpY2tFdnRzO1xufVxuXG4vKipcbiAqIFVudGlsIGF1ZGlvIGlzIGxvYWRlZCBhbmQgZGVjb2RlZCwgYSBzaW5nbGUtc2FtcGxlIGJ1ZmZlciBvZiBzaWxlbmNlIGlzIHJldHVybmVkLlxuICovXG5mdW5jdGlvbiBsb2FkQXVkaW9Bc0FycmF5KHVybCkge1xuICBjb25zdCByZXF1ZXN0VXBkYXRlID0gdXNlUmVxdWVzdFVwZGF0ZSgpO1xuICBjb25zdCBwY20gPSB1c2VWYXIoWzBdKTsgLy8gdW50aWwgbG9hZGVkLCBqdXN0IHJldHVybiBzaW5nbGUgc2FtcGxlIG9mIHNpbGVuY2VcblxuICB1c2VJbml0aWFsaXplKCgpID0+IHtcbiAgICBjb25zdCBhdWRpb0N0eCA9IG5ldyAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgIGxldCBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIHJlcXVlc3Qub25sb2FkID0gKCkgPT4ge1xuICAgICAgY29uc3QgYXVkaW9EYXRhID0gcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIGF1ZGlvQ3R4LmRlY29kZUF1ZGlvRGF0YShhdWRpb0RhdGEsIGJ1ZmZlciA9PiB7XG4gICAgICAgIGlmICghY2xlYW5lZFVwKSB7XG4gICAgICAgICAgcGNtLmN1cnJlbnQgPSBidWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgICAgcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICByZXF1ZXN0LmFib3J0KCk7IC8vIGl0J3Mgc2FmZSB0byBhbHdheXMgYWJvcnQgaGVyZS4gaWYgYWxyZWFkeSBjb21wbGV0ZWQsIGl0IHdpbGwgYmUgaWdub3JlZFxuXG4gICAgICAvLyBkZWNvZGVBdWRpb0RhdGEgY2Fubm90IGJlIGNhbmNlbGVkLiBTbyB0byBiZSBjb3JyZWN0LCB3ZSBtdXN0IHNldCBhIGZsYWcgaGVyZSB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgZGVjb2RpbmcgaXMgaWdub3JlZFxuICAgICAgY2xlYW5lZFVwID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwY20uY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY29uc29sZUxvZyh2KSB7XG4gIGNvbnNvbGUubG9nKHYpO1xufVxuXG5mdW5jdGlvbiBpbnRlZ3JhbChpbnRlZ3JhbmRGdW5jLCB0aW1lLCBpbml0aWFsVmFsdWUgPSAwKSB7XG4gIGNvbnN0IGFjY3VtID0gdXNlVmFyKGluaXRpYWxWYWx1ZSk7XG4gIGNvbnN0IHByZXZUaW1lID0gdXNlVmFyKHRpbWUpO1xuXG4gIGNvbnN0IGludGVncmFuZCA9IGludGVncmFuZEZ1bmMoYWNjdW0uY3VycmVudCwgcHJldlRpbWUuY3VycmVudCk7XG4gIGFjY3VtLmN1cnJlbnQgKz0gKHRpbWUgLSBwcmV2VGltZS5jdXJyZW50KSppbnRlZ3JhbmQ7XG5cbiAgcHJldlRpbWUuY3VycmVudCA9IHRpbWU7XG5cbiAgcmV0dXJuIGFjY3VtLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGV4cEZvbGxvdyh0YXJnZXRWYWx1ZSwgc3BlZWRDb25zdGFudCwgdGltZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBpbnRlZ3JhbChjdXJyZW50VmFsdWUgPT4gc3BlZWRDb25zdGFudCoodGFyZ2V0VmFsdWUgLSBjdXJyZW50VmFsdWUpLCB0aW1lLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZWRDaXJjbGUocG9zaXRpb24sIHJhZGl1cyA9IDI1KSB7XG4gIGNvbnN0IGVsZW0gPSB1c2VWYXIobnVsbCk7XG5cbiAgdXNlSW5pdGlhbGl6ZSgoKSA9PiB7XG4gICAgZWxlbS5jdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbS5jdXJyZW50LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyBib3JkZXItcmFkaXVzOiA1MCU7IGJhY2tncm91bmQ6IHJlZDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHVzZXItc2VsZWN0OiBub25lJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0uY3VycmVudCk7XG5cbiAgICByZXR1cm4gKCkgPT4geyAvLyBjbGVhbnVwXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsZW0uY3VycmVudCk7XG4gICAgfVxuICB9KVxuXG4gIGNvbnN0IHAgPSBwb3NpdGlvbiB8fCB7eDogMCwgeTogMH07XG4gIGlmIChyYWRpdXMgPCAwKSB7XG4gICAgcmFkaXVzID0gMDtcbiAgfVxuICBjb25zdCBoYWxmUmFkaXVzID0gMC41KnJhZGl1cztcblxuICBlbGVtLmN1cnJlbnQuc3R5bGUubGVmdCA9IChwLnggLSBoYWxmUmFkaXVzKSArICdweCc7XG4gIGVsZW0uY3VycmVudC5zdHlsZS50b3AgPSAocC55IC0gaGFsZlJhZGl1cykgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUud2lkdGggPSByYWRpdXMgKyAncHgnO1xuICBlbGVtLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gcmFkaXVzICsgJ3B4Jztcbn1cblxuZnVuY3Rpb24gZm9sbG93QXRTcGVlZDJkKHRhcmdldCwgc3BlZWQsIHRpbWUsIGluaXRpYWwpIHtcbiAgY29uc3QgcG9zID0gdXNlVmFyKGluaXRpYWwpO1xuICBjb25zdCBwcmV2VGltZSA9IHVzZVZhcih0aW1lKTtcblxuICBjb25zdCBkdCA9IHRpbWUgLSBwcmV2VGltZS5jdXJyZW50O1xuICBjb25zdCBkZWx0YSA9IHt4OiB0YXJnZXQueC1wb3MuY3VycmVudC54LCB5OiB0YXJnZXQueS1wb3MuY3VycmVudC55fTtcbiAgY29uc3QgZGlzdCA9IE1hdGguc3FydChkZWx0YS54KmRlbHRhLnggKyBkZWx0YS55KmRlbHRhLnkpO1xuICBpZiAoc3BlZWQqZHQgPj0gZGlzdCkge1xuICAgIC8vIEp1bXAgdG8gdGFyZ2V0IHBvc2l0aW9uXG4gICAgcG9zLmN1cnJlbnQgPSB0YXJnZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gTk9URTogV2UgbXVzdCBub3QgbXV0YXRlIHBvcy5jdXJyZW50LCBzaW5jZSB3ZSByZXR1cm4gdGhhdFxuICAgIHBvcy5jdXJyZW50ID0ge1xuICAgICAgeDogcG9zLmN1cnJlbnQueCArIGR0KnNwZWVkKmRlbHRhLngvZGlzdCxcbiAgICAgIHk6IHBvcy5jdXJyZW50LnkgKyBkdCpzcGVlZCpkZWx0YS55L2Rpc3QsXG4gICAgfTtcbiAgfVxuXG4gIHByZXZUaW1lLmN1cnJlbnQgPSB0aW1lO1xuXG4gIHJldHVybiBwb3MuY3VycmVudDtcbn1cblxuLyoqXG4gKiBOb3RlIHRoYXQgdGhpcyBfd2lsbF8gZmlyZSBpbiBmaXJzdCBjYWxsIGlmIGNvbmRpdGlvbiBzdGFydHMgdHJ1dGh5XG4gKi9cbmZ1bmN0aW9uIGV2ZW50V2hlbihjb25kaXRpb24sIHZhbHVlVG9FbWl0KSB7XG4gIGNvbnN0IFtldnRzLCBlbWl0XSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuICBjb25zdCBwcmV2Q29uZGl0aW9uID0gdXNlVmFyKGZhbHNlKTtcblxuICBjb25zdCBiY29uZCA9ICEhY29uZGl0aW9uO1xuXG4gIGlmIChiY29uZCAmJiAhcHJldkNvbmRpdGlvbi5jdXJyZW50KSB7XG4gICAgZW1pdCh2YWx1ZVRvRW1pdCk7XG4gIH1cbiAgcHJldkNvbmRpdGlvbi5jdXJyZW50ID0gYmNvbmQ7XG5cbiAgcmV0dXJuIGV2dHM7XG59XG5cbi8qKlxuICogTm90ZSB0aGF0IHNlY29uZHMgYXJndW1lbnQgaXMgb25seSByZWFkIGluaXRpYWxseS4gQnV0IHZhbHVlVG9FbWl0IGlzIHJlLXJlYWQgb24gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBldmVudEFmdGVyKHNlY29uZHMsIHZhbHVlVG9FbWl0KSB7XG4gIGNvbnN0IFtldnRzLCBlbWl0XSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuICBjb25zdCB2YWx1ZSA9IHVzZVZhcih2YWx1ZVRvRW1pdCk7XG5cbiAgdmFsdWUuY3VycmVudCA9IHZhbHVlVG9FbWl0O1xuXG4gIHVzZUluaXRpYWxpemUoKCkgPT4ge1xuICAgIGNvbnN0IHRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGVtaXQodmFsdWUuY3VycmVudCk7XG4gICAgfSwgMTAwMCpzZWNvbmRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBldnRzO1xufVxuXG5mdW5jdGlvbiBuZXZlckV2dHMoKSB7XG4gIGNvbnN0IFtldnRzLCBlbWl0XSA9IHVzZUV2ZW50RW1pdHRlcigpO1xuICByZXR1cm4gZXZ0cztcbn1cblxuZXhwb3J0IGRlZmF1bHQgW1xuICB7XG4gICAgbmFtZTogJ2RvIG5vdGhpbmcnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnYW5pbWF0aW9uIHRpbWUnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcoYW5pbWF0aW9uVGltZSgpLnRvRml4ZWQoMykpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjb3VudCBjbGlja3MnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIHNob3dTdHJpbmcoY291bnRFdmVudHMobW91c2VDbGlja0V2dHMoKSkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdpcyBtb3VzZSBidXR0b24gZG93bicsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhtb3VzZURvd24oKSk7XG4gICAgfSxcbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ3JhbmRvbSBudW1iZXIsIGNsaWNrIHRvIHJlcGljaycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgc2hvd1N0cmluZyhyYW5kb20obW91c2VDbGlja0V2dHMoKSkpO1xuICAgIH0sXG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdhdWRpbyBub2lzZSB3aGVuIG1vdXNlIGlzIGRvd24nLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IG1kID0gbW91c2VEb3duKCk7XG4gICAgICBhdWRpb0RyaXZlcigoYXVkaW9UaW1lLCBhZHZhbmNlRnJhbWVFdnRzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vaXNlID0gcmFuZG9tKGFkdmFuY2VGcmFtZUV2dHMpIC0gMC41O1xuICAgICAgICByZXR1cm4gbWQgPyBub2lzZSA6IDA7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnZGVjYXlpbmcgbm9pc2UgdXBvbiBjbGljaycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgY2xpY2tFdnRzID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dHMpID0+IHtcbiAgICAgICAgY29uc3Qgbm9pc2UgPSByYW5kb20oYWR2YW5jZUZyYW1lRXZ0cykgLSAwLjU7XG4gICAgICAgIGNvbnN0IGxhc3RDbGlja1RpbWUgPSBzYW1wbGVVcG9uKGF1ZGlvVGltZSwgY2xpY2tFdnRzLCAtSW5maW5pdHkpO1xuICAgICAgICBjb25zdCBkZWNheWluZ0dhaW4gPSBNYXRoLmV4cCg1KihsYXN0Q2xpY2tUaW1lIC0gYXVkaW9UaW1lKSk7XG4gICAgICAgIHJldHVybiBkZWNheWluZ0dhaW4qbm9pc2U7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAncmVzZXR0aW5nIGZyYW1lIGNvdW50ZXIsIGNsaWNrIHRvIHJlc2V0JyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBmcmFtZUV2dHMgPSBhbmltYXRpb25GcmFtZUV2dHMoKTtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjbGljayA9IHVzZUV2ZW50UmVjZWl2ZXIoY2xpY2tFdnRzKTtcbiAgICAgIGNvbnN0IGNyZWF0ZUNvdW50ZXIgPSB1c2VEeW5hbWljKGNvdW50RXZlbnRzKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUNvdW50ZXIgPSB1c2VWYXIoKTtcblxuICAgICAgaWYgKGNsaWNrKSB7XG4gICAgICAgIGlmIChhY3RpdmVDb3VudGVyLmN1cnJlbnQpIHtcbiAgICAgICAgICBhY3RpdmVDb3VudGVyLmN1cnJlbnQudGVybWluYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50ID0gY3JlYXRlQ291bnRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKCFhY3RpdmVDb3VudGVyLmN1cnJlbnQpIHtcbiAgICAgICAgYWN0aXZlQ291bnRlci5jdXJyZW50ID0gY3JlYXRlQ291bnRlcigpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaXNwbGF5ZWRDb3VudCA9IGFjdGl2ZUNvdW50ZXIuY3VycmVudC51cGRhdGUoZnJhbWVFdnRzKTtcbiAgICAgIHNob3dTdHJpbmcoZGlzcGxheWVkQ291bnQpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2R5bmFtaWMgYXJyYXkgb2YgYXN5bmMgY2xvY2tzLCBjbGljayB0byBhZGQnLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IGNsaWNrRXZ0cyA9IG1vdXNlQ2xpY2tFdnRzKCk7XG4gICAgICBjb25zdCBjbGljayA9IHVzZUV2ZW50UmVjZWl2ZXIoY2xpY2tFdnRzKTtcbiAgICAgIGNvbnN0IGNyZWF0ZUNsb2NrID0gdXNlRHluYW1pYygoKSA9PiBjb3VudEV2ZW50cyhldmVyeVNlY29uZCgpKSk7XG4gICAgICBjb25zdCBjbG9ja0FycmF5ID0gdXNlVmFyKFtdKTtcblxuICAgICAgaWYgKGNsaWNrKSB7XG4gICAgICAgIGNsb2NrQXJyYXkuY3VycmVudC5wdXNoKGNyZWF0ZUNsb2NrKCkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBudW1zID0gY2xvY2tBcnJheS5jdXJyZW50Lm1hcChjbG9jayA9PiBjbG9jay51cGRhdGUoKSk7XG4gICAgICBzaG93U3RyaW5nKG51bXMuam9pbignICcpKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyZWNvcmQgcGxheWVyIHNwaW4gdXAvZG93biwgaG9sZCBtb3VzZSBkb3duIGFuZCByZWxlYXNlJyxcbiAgICBtYWluOiAoKSA9PiB7XG4gICAgICBjb25zdCBwY20gPSBsb2FkQXVkaW9Bc0FycmF5KCdhbWVuX2JyZWFrLm1wMycpO1xuICAgICAgc2hvd1N0cmluZyhwY20ubGVuZ3RoID4gMSA/ICdsb2FkZWQgYXVkaW8nIDogJ2xvYWRpbmcgYXVkaW8uLi4nKTtcbiAgICAgIGF1ZGlvRHJpdmVyKChhdWRpb1RpbWUsIGFkdmFuY2VGcmFtZUV2dHMsIHNhbXBsZVJhdGUpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BlZWQgPSBtb3VzZURvd24oKSA/IHNhbXBsZVJhdGUgOiAwO1xuICAgICAgICBjb25zdCBzcGVlZCA9IGV4cEZvbGxvdyh0YXJnZXRTcGVlZCwgMywgYXVkaW9UaW1lLCAwKTtcbiAgICAgICAgY29uc3QgcG9zID0gTWF0aC5mbG9vcihpbnRlZ3JhbCgoKSA9PiBzcGVlZCwgYXVkaW9UaW1lKSk7XG4gICAgICAgIHJldHVybiBwY21bcG9zICUgcGNtLmxlbmd0aF07IC8vIG1vZHVsbyBzbyBhcyB0byBsb29wXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdjaXJjbGUgZm9sbG93cyBtb3VzZScsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgcmVkQ2lyY2xlKG1vdXNlUG9zaXRpb24oKSk7XG4gICAgfVxuICB9LFxuXG4gIHtcbiAgICBuYW1lOiAnY2lyY2xlIGZvbGxvd3MgbW91c2UgYXQgbGltaXRlZCBzcGVlZCcsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgdGltZSA9IGFuaW1hdGlvblRpbWUoKTtcbiAgICAgIGNvbnN0IG1wb3MgPSBtb3VzZVBvc2l0aW9uKCk7XG4gICAgICByZWRDaXJjbGUoZm9sbG93QXRTcGVlZDJkKG1wb3MsIDMwMCwgdGltZSwgbXBvcykpO1xuICAgIH1cbiAgfSxcblxuICB7XG4gICAgbmFtZTogJ2NpcmNsZSBtb3ZlcyBoYWxmd2F5IHRvIG1vdXNlIHdpdGggZWFjaCBjbGljaycsXG4gICAgbWFpbjogKCkgPT4ge1xuICAgICAgY29uc3QgbWlkcG9pbnQgPSAoYSwgYikgPT4gKHt4OiAwLjUqKGEueCtiLngpLCB5OiAwLjUqKGEueStiLnkpfSk7XG4gICAgICBjb25zdCBtcG9zID0gbW91c2VQb3NpdGlvbigpO1xuICAgICAgY29uc3QgY2xpY2tFdnRzID0gbW91c2VDbGlja0V2dHMoKTtcbiAgICAgIGNvbnN0IGNwb3MgPSB1c2VSZWR1Y2VyKGNsaWNrRXZ0cywgKGFjdGlvbiwgcHJldlN0YXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBhY3Rpb24gPyBtaWRwb2ludChwcmV2U3RhdGUsIG1wb3MpIDogcHJldlN0YXRlO1xuICAgICAgfSwge3g6IDAsIHk6IDB9KTtcbiAgICAgIHJlZENpcmNsZShjcG9zKTtcbiAgICB9XG4gIH0sXG5cbiAge1xuICAgIG5hbWU6ICdyb2FtaW5nIGNpcmNsZSAoc3RhdGUgbWFjaGluZSknLFxuICAgIG1haW46ICgpID0+IHtcbiAgICAgIGNvbnN0IHRpbWUgPSBhbmltYXRpb25UaW1lKCk7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHVzZU1hY2hpbmUoe1xuICAgICAgICBtb3Zpbmc6IChpbml0aWFsUG9zaXRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHt4OiA1MDAqcmFuZG9tKG5ldmVyRXZ0cygpKSwgeTogNTAwKnJhbmRvbShuZXZlckV2dHMoKSl9O1xuICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZm9sbG93QXRTcGVlZDJkKHRhcmdldFBvc2l0aW9uLCAzMDAsIHRpbWUsIGluaXRpYWxQb3NpdGlvbik7XG4gICAgICAgICAgY29uc3QgYXJyaXZlZCA9IChwb3NpdGlvbi54ID09PSB0YXJnZXRQb3NpdGlvbi54KSAmJiAocG9zaXRpb24ueSA9PT0gdGFyZ2V0UG9zaXRpb24ueSk7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgZXZlbnRXaGVuKGFycml2ZWQsIFsncmVzdGluZycsIHBvc2l0aW9uXSlcbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICByZXN0aW5nOiAoaW5pdGlhbFBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGluaXRpYWxQb3NpdGlvbixcbiAgICAgICAgICAgIGV2ZW50QWZ0ZXIocmFuZG9tKG5ldmVyRXZ0cygpKSwgWydtb3ZpbmcnLCBpbml0aWFsUG9zaXRpb25dKVxuICAgICAgICAgIF07XG4gICAgICAgIH0sXG4gICAgICB9LCBbJ21vdmluZycsIHt4OiAwLCB5OiAwfV0pO1xuICAgICAgcmVkQ2lyY2xlKHBvc2l0aW9uKTtcbiAgICB9XG4gIH0sXG5cbl1cbiIsImltcG9ydCB7IGNyZWF0ZU5vSW5PdXRFeGVjdXRpb25Db250ZXh0IH0gZnJvbSAnLi9yaXYnO1xuaW1wb3J0IHByb2dyYW1zIGZyb20gJy4vcHJvZ3JhbXMnO1xuXG5jb25zdCBwcm9ncmFtTGlzdEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvZ3JhbS1saXN0Jyk7XG5jb25zdCBwcm9ncmFtU291cmNlRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9ncmFtLXNvdXJjZScpO1xuXG5sZXQgY3VycmVudENvbnRleHQ7XG5cbi8vIE5PVEU6IFRoaXMgaXMgYSBoYWNrIGJ1dCB3b3JrcyBmb3Igbm93XG5jb25zdCBmaXhJbmRlbnQgPSAoY29kZSkgPT4ge1xuICByZXR1cm4gY29kZS5zcGxpdCgnXFxuJykubWFwKChsaW5lLCBpZHgpID0+IChpZHggPT09IDApID8gbGluZSA6IGxpbmUuc3Vic3RyKDIpKS5qb2luKCdcXG4nKTtcbn1cblxuY29uc3Qgc3RhcnRQcm9ncmFtID0gKHByb2dyYW0pID0+IHtcbiAgaWYgKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgY3VycmVudENvbnRleHQudGVybWluYXRlKCk7XG4gICAgY3VycmVudENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBwcm9ncmFtU291cmNlRWxlbS50ZXh0Q29udGVudCA9IGZpeEluZGVudChwcm9ncmFtLm1haW4udG9TdHJpbmcoKSk7IC8vIGhhY2t5IGJ1dCB3b3JrcyBmb3Igbm93XG4gIGN1cnJlbnRDb250ZXh0ID0gY3JlYXRlTm9Jbk91dEV4ZWN1dGlvbkNvbnRleHQocHJvZ3JhbS5tYWluKTtcbiAgY3VycmVudENvbnRleHQudXBkYXRlKCk7IC8vIGRvIGluaXRpYWwgdXBkYXRlLiBhbnkgZnVydGhlciB1cGRhdGVzIHdpbGwgYmUgYXN5bmNcbn1cblxuZm9yIChjb25zdCBwcm9nIG9mIHByb2dyYW1zKSB7XG4gIGNvbnN0IGFuY2hvckVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGFuY2hvckVsZW0udGV4dENvbnRlbnQgPSBwcm9nLm5hbWU7XG4gIGFuY2hvckVsZW0uc2V0QXR0cmlidXRlKCdocmVmJywgJyMnKTtcbiAgKCgpID0+IHtcbiAgICBhbmNob3JFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4geyAvLyBzdGFydCBwcm9ncmFtIHdpdGggZGVsYXkgc28gaXQgZG9lc24ndCBnZXQgdGhpcyBjbGljayBldmVudFxuICAgICAgICBzdGFydFByb2dyYW0ocHJvZyk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfSkoKTtcblxuICBjb25zdCBpdGVtRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gIGl0ZW1FbGVtLmFwcGVuZENoaWxkKGFuY2hvckVsZW0pO1xuXG4gIHByb2dyYW1MaXN0RWxlbS5hcHBlbmRDaGlsZChpdGVtRWxlbSk7XG59XG5cbnN0YXJ0UHJvZ3JhbShwcm9ncmFtc1swXSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")}]);